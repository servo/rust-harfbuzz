/* automatically generated by rust-bindgen 0.60.1 */

#[doc = " hb_bool_t:"]
#[doc = ""]
#[doc = " Data type for booleans."]
#[doc = ""]
pub type hb_bool_t = ::std::os::raw::c_int;
#[doc = " hb_codepoint_t:"]
#[doc = ""]
#[doc = " Data type for holding Unicode codepoints. Also"]
#[doc = " used to hold glyph IDs."]
#[doc = ""]
pub type hb_codepoint_t = u32;
#[doc = " hb_position_t:"]
#[doc = ""]
#[doc = " Data type for holding a single coordinate value."]
#[doc = " Contour points and other multi-dimensional data are"]
#[doc = " stored as tuples of #hb_position_t's."]
#[doc = ""]
pub type hb_position_t = i32;
#[doc = " hb_mask_t:"]
#[doc = ""]
#[doc = " Data type for bitmasks."]
#[doc = ""]
pub type hb_mask_t = u32;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _hb_var_int_t {
    pub u32: u32,
    pub i32: i32,
    pub u16: [u16; 2usize],
    pub i16: [i16; 2usize],
    pub u8: [u8; 4usize],
    pub i8: [i8; 4usize],
}
#[test]
fn bindgen_test_layout__hb_var_int_t() {
    assert_eq!(
        ::std::mem::size_of::<_hb_var_int_t>(),
        4usize,
        concat!("Size of: ", stringify!(_hb_var_int_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_hb_var_int_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_hb_var_int_t))
    );
    fn test_field_u32() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_hb_var_int_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).u32) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_hb_var_int_t),
                "::",
                stringify!(u32)
            )
        );
    }
    test_field_u32();
    fn test_field_i32() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_hb_var_int_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).i32) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_hb_var_int_t),
                "::",
                stringify!(i32)
            )
        );
    }
    test_field_i32();
    fn test_field_u16() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_hb_var_int_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).u16) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_hb_var_int_t),
                "::",
                stringify!(u16)
            )
        );
    }
    test_field_u16();
    fn test_field_i16() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_hb_var_int_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).i16) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_hb_var_int_t),
                "::",
                stringify!(i16)
            )
        );
    }
    test_field_i16();
    fn test_field_u8() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_hb_var_int_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).u8) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_hb_var_int_t),
                "::",
                stringify!(u8)
            )
        );
    }
    test_field_u8();
    fn test_field_i8() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_hb_var_int_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).i8) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_hb_var_int_t),
                "::",
                stringify!(i8)
            )
        );
    }
    test_field_i8();
}
pub type hb_var_int_t = _hb_var_int_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _hb_var_num_t {
    pub f: ::std::os::raw::c_float,
    pub u32: u32,
    pub i32: i32,
    pub u16: [u16; 2usize],
    pub i16: [i16; 2usize],
    pub u8: [u8; 4usize],
    pub i8: [i8; 4usize],
}
#[test]
fn bindgen_test_layout__hb_var_num_t() {
    assert_eq!(
        ::std::mem::size_of::<_hb_var_num_t>(),
        4usize,
        concat!("Size of: ", stringify!(_hb_var_num_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_hb_var_num_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_hb_var_num_t))
    );
    fn test_field_f() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_hb_var_num_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).f) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_hb_var_num_t),
                "::",
                stringify!(f)
            )
        );
    }
    test_field_f();
    fn test_field_u32() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_hb_var_num_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).u32) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_hb_var_num_t),
                "::",
                stringify!(u32)
            )
        );
    }
    test_field_u32();
    fn test_field_i32() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_hb_var_num_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).i32) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_hb_var_num_t),
                "::",
                stringify!(i32)
            )
        );
    }
    test_field_i32();
    fn test_field_u16() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_hb_var_num_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).u16) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_hb_var_num_t),
                "::",
                stringify!(u16)
            )
        );
    }
    test_field_u16();
    fn test_field_i16() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_hb_var_num_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).i16) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_hb_var_num_t),
                "::",
                stringify!(i16)
            )
        );
    }
    test_field_i16();
    fn test_field_u8() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_hb_var_num_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).u8) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_hb_var_num_t),
                "::",
                stringify!(u8)
            )
        );
    }
    test_field_u8();
    fn test_field_i8() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_hb_var_num_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).i8) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_hb_var_num_t),
                "::",
                stringify!(i8)
            )
        );
    }
    test_field_i8();
}
pub type hb_var_num_t = _hb_var_num_t;
#[doc = " hb_tag_t:"]
#[doc = ""]
#[doc = " Data type for tag identifiers. Tags are four"]
#[doc = " byte integers, each byte representing a character."]
#[doc = ""]
#[doc = " Tags are used to identify tables, design-variation axes,"]
#[doc = " scripts, languages, font features, and baselines with"]
#[doc = " human-readable names."]
#[doc = ""]
pub type hb_tag_t = u32;
extern "C" {
    pub fn hb_tag_from_string(
        str_: *const ::std::os::raw::c_char,
        len: ::std::os::raw::c_int,
    ) -> hb_tag_t;
}
extern "C" {
    pub fn hb_tag_to_string(tag: hb_tag_t, buf: *mut ::std::os::raw::c_char);
}
pub const HB_DIRECTION_INVALID: hb_direction_t = 0;
pub const HB_DIRECTION_LTR: hb_direction_t = 4;
pub const HB_DIRECTION_RTL: hb_direction_t = 5;
pub const HB_DIRECTION_TTB: hb_direction_t = 6;
pub const HB_DIRECTION_BTT: hb_direction_t = 7;
#[doc = " hb_direction_t:"]
#[doc = " @HB_DIRECTION_INVALID: Initial, unset direction."]
#[doc = " @HB_DIRECTION_LTR: Text is set horizontally from left to right."]
#[doc = " @HB_DIRECTION_RTL: Text is set horizontally from right to left."]
#[doc = " @HB_DIRECTION_TTB: Text is set vertically from top to bottom."]
#[doc = " @HB_DIRECTION_BTT: Text is set vertically from bottom to top."]
#[doc = ""]
#[doc = " The direction of a text segment or buffer."]
#[doc = ""]
#[doc = " A segment can also be tested for horizontal or vertical"]
#[doc = " orientation (irrespective of specific direction) with"]
#[doc = " HB_DIRECTION_IS_HORIZONTAL() or HB_DIRECTION_IS_VERTICAL()."]
#[doc = ""]
pub type hb_direction_t = ::std::os::raw::c_uint;
extern "C" {
    pub fn hb_direction_from_string(
        str_: *const ::std::os::raw::c_char,
        len: ::std::os::raw::c_int,
    ) -> hb_direction_t;
}
extern "C" {
    pub fn hb_direction_to_string(direction: hb_direction_t) -> *const ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hb_language_impl_t {
    _unused: [u8; 0],
}
#[doc = " hb_language_t:"]
#[doc = ""]
#[doc = " Data type for languages. Each #hb_language_t corresponds to a BCP 47"]
#[doc = " language tag."]
#[doc = ""]
pub type hb_language_t = *const hb_language_impl_t;
extern "C" {
    pub fn hb_language_from_string(
        str_: *const ::std::os::raw::c_char,
        len: ::std::os::raw::c_int,
    ) -> hb_language_t;
}
extern "C" {
    pub fn hb_language_to_string(language: hb_language_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn hb_language_get_default() -> hb_language_t;
}
pub const HB_SCRIPT_COMMON: hb_script_t = 1517910393;
pub const HB_SCRIPT_INHERITED: hb_script_t = 1516858984;
pub const HB_SCRIPT_UNKNOWN: hb_script_t = 1517976186;
pub const HB_SCRIPT_ARABIC: hb_script_t = 1098015074;
pub const HB_SCRIPT_ARMENIAN: hb_script_t = 1098018158;
pub const HB_SCRIPT_BENGALI: hb_script_t = 1113943655;
pub const HB_SCRIPT_CYRILLIC: hb_script_t = 1132032620;
pub const HB_SCRIPT_DEVANAGARI: hb_script_t = 1147500129;
pub const HB_SCRIPT_GEORGIAN: hb_script_t = 1197830002;
pub const HB_SCRIPT_GREEK: hb_script_t = 1198679403;
pub const HB_SCRIPT_GUJARATI: hb_script_t = 1198877298;
pub const HB_SCRIPT_GURMUKHI: hb_script_t = 1198879349;
pub const HB_SCRIPT_HANGUL: hb_script_t = 1214344807;
pub const HB_SCRIPT_HAN: hb_script_t = 1214344809;
pub const HB_SCRIPT_HEBREW: hb_script_t = 1214603890;
pub const HB_SCRIPT_HIRAGANA: hb_script_t = 1214870113;
pub const HB_SCRIPT_KANNADA: hb_script_t = 1265525857;
pub const HB_SCRIPT_KATAKANA: hb_script_t = 1264676449;
pub const HB_SCRIPT_LAO: hb_script_t = 1281453935;
pub const HB_SCRIPT_LATIN: hb_script_t = 1281455214;
pub const HB_SCRIPT_MALAYALAM: hb_script_t = 1298954605;
pub const HB_SCRIPT_ORIYA: hb_script_t = 1332902241;
pub const HB_SCRIPT_TAMIL: hb_script_t = 1415671148;
pub const HB_SCRIPT_TELUGU: hb_script_t = 1415933045;
pub const HB_SCRIPT_THAI: hb_script_t = 1416126825;
pub const HB_SCRIPT_TIBETAN: hb_script_t = 1416192628;
pub const HB_SCRIPT_BOPOMOFO: hb_script_t = 1114599535;
pub const HB_SCRIPT_BRAILLE: hb_script_t = 1114792297;
pub const HB_SCRIPT_CANADIAN_SYLLABICS: hb_script_t = 1130458739;
pub const HB_SCRIPT_CHEROKEE: hb_script_t = 1130915186;
pub const HB_SCRIPT_ETHIOPIC: hb_script_t = 1165256809;
pub const HB_SCRIPT_KHMER: hb_script_t = 1265134962;
pub const HB_SCRIPT_MONGOLIAN: hb_script_t = 1299148391;
pub const HB_SCRIPT_MYANMAR: hb_script_t = 1299803506;
pub const HB_SCRIPT_OGHAM: hb_script_t = 1332175213;
pub const HB_SCRIPT_RUNIC: hb_script_t = 1383427698;
pub const HB_SCRIPT_SINHALA: hb_script_t = 1399418472;
pub const HB_SCRIPT_SYRIAC: hb_script_t = 1400468067;
pub const HB_SCRIPT_THAANA: hb_script_t = 1416126817;
pub const HB_SCRIPT_YI: hb_script_t = 1500080489;
pub const HB_SCRIPT_DESERET: hb_script_t = 1148416628;
pub const HB_SCRIPT_GOTHIC: hb_script_t = 1198486632;
pub const HB_SCRIPT_OLD_ITALIC: hb_script_t = 1232363884;
pub const HB_SCRIPT_BUHID: hb_script_t = 1114990692;
pub const HB_SCRIPT_HANUNOO: hb_script_t = 1214344815;
pub const HB_SCRIPT_TAGALOG: hb_script_t = 1416064103;
pub const HB_SCRIPT_TAGBANWA: hb_script_t = 1415669602;
pub const HB_SCRIPT_CYPRIOT: hb_script_t = 1131442804;
pub const HB_SCRIPT_LIMBU: hb_script_t = 1281977698;
pub const HB_SCRIPT_LINEAR_B: hb_script_t = 1281977954;
pub const HB_SCRIPT_OSMANYA: hb_script_t = 1332964705;
pub const HB_SCRIPT_SHAVIAN: hb_script_t = 1399349623;
pub const HB_SCRIPT_TAI_LE: hb_script_t = 1415670885;
pub const HB_SCRIPT_UGARITIC: hb_script_t = 1432838514;
pub const HB_SCRIPT_BUGINESE: hb_script_t = 1114990441;
pub const HB_SCRIPT_COPTIC: hb_script_t = 1131376756;
pub const HB_SCRIPT_GLAGOLITIC: hb_script_t = 1198285159;
pub const HB_SCRIPT_KHAROSHTHI: hb_script_t = 1265131890;
pub const HB_SCRIPT_NEW_TAI_LUE: hb_script_t = 1415670901;
pub const HB_SCRIPT_OLD_PERSIAN: hb_script_t = 1483761007;
pub const HB_SCRIPT_SYLOTI_NAGRI: hb_script_t = 1400466543;
pub const HB_SCRIPT_TIFINAGH: hb_script_t = 1415999079;
pub const HB_SCRIPT_BALINESE: hb_script_t = 1113681001;
pub const HB_SCRIPT_CUNEIFORM: hb_script_t = 1483961720;
pub const HB_SCRIPT_NKO: hb_script_t = 1315663727;
pub const HB_SCRIPT_PHAGS_PA: hb_script_t = 1349017959;
pub const HB_SCRIPT_PHOENICIAN: hb_script_t = 1349021304;
pub const HB_SCRIPT_CARIAN: hb_script_t = 1130459753;
pub const HB_SCRIPT_CHAM: hb_script_t = 1130914157;
pub const HB_SCRIPT_KAYAH_LI: hb_script_t = 1264675945;
pub const HB_SCRIPT_LEPCHA: hb_script_t = 1281716323;
pub const HB_SCRIPT_LYCIAN: hb_script_t = 1283023721;
pub const HB_SCRIPT_LYDIAN: hb_script_t = 1283023977;
pub const HB_SCRIPT_OL_CHIKI: hb_script_t = 1332503403;
pub const HB_SCRIPT_REJANG: hb_script_t = 1382706791;
pub const HB_SCRIPT_SAURASHTRA: hb_script_t = 1398895986;
pub const HB_SCRIPT_SUNDANESE: hb_script_t = 1400204900;
pub const HB_SCRIPT_VAI: hb_script_t = 1449224553;
pub const HB_SCRIPT_AVESTAN: hb_script_t = 1098281844;
pub const HB_SCRIPT_BAMUM: hb_script_t = 1113681269;
pub const HB_SCRIPT_EGYPTIAN_HIEROGLYPHS: hb_script_t = 1164409200;
pub const HB_SCRIPT_IMPERIAL_ARAMAIC: hb_script_t = 1098018153;
pub const HB_SCRIPT_INSCRIPTIONAL_PAHLAVI: hb_script_t = 1349020777;
pub const HB_SCRIPT_INSCRIPTIONAL_PARTHIAN: hb_script_t = 1349678185;
pub const HB_SCRIPT_JAVANESE: hb_script_t = 1247901281;
pub const HB_SCRIPT_KAITHI: hb_script_t = 1265920105;
pub const HB_SCRIPT_LISU: hb_script_t = 1281979253;
pub const HB_SCRIPT_MEETEI_MAYEK: hb_script_t = 1299473769;
pub const HB_SCRIPT_OLD_SOUTH_ARABIAN: hb_script_t = 1398895202;
pub const HB_SCRIPT_OLD_TURKIC: hb_script_t = 1332898664;
pub const HB_SCRIPT_SAMARITAN: hb_script_t = 1398893938;
pub const HB_SCRIPT_TAI_THAM: hb_script_t = 1281453665;
pub const HB_SCRIPT_TAI_VIET: hb_script_t = 1415673460;
pub const HB_SCRIPT_BATAK: hb_script_t = 1113683051;
pub const HB_SCRIPT_BRAHMI: hb_script_t = 1114792296;
pub const HB_SCRIPT_MANDAIC: hb_script_t = 1298230884;
pub const HB_SCRIPT_CHAKMA: hb_script_t = 1130457965;
pub const HB_SCRIPT_MEROITIC_CURSIVE: hb_script_t = 1298494051;
pub const HB_SCRIPT_MEROITIC_HIEROGLYPHS: hb_script_t = 1298494063;
pub const HB_SCRIPT_MIAO: hb_script_t = 1349284452;
pub const HB_SCRIPT_SHARADA: hb_script_t = 1399353956;
pub const HB_SCRIPT_SORA_SOMPENG: hb_script_t = 1399812705;
pub const HB_SCRIPT_TAKRI: hb_script_t = 1415670642;
pub const HB_SCRIPT_BASSA_VAH: hb_script_t = 1113682803;
pub const HB_SCRIPT_CAUCASIAN_ALBANIAN: hb_script_t = 1097295970;
pub const HB_SCRIPT_DUPLOYAN: hb_script_t = 1148547180;
pub const HB_SCRIPT_ELBASAN: hb_script_t = 1164730977;
pub const HB_SCRIPT_GRANTHA: hb_script_t = 1198678382;
pub const HB_SCRIPT_KHOJKI: hb_script_t = 1265135466;
pub const HB_SCRIPT_KHUDAWADI: hb_script_t = 1399418468;
pub const HB_SCRIPT_LINEAR_A: hb_script_t = 1281977953;
pub const HB_SCRIPT_MAHAJANI: hb_script_t = 1298229354;
pub const HB_SCRIPT_MANICHAEAN: hb_script_t = 1298230889;
pub const HB_SCRIPT_MENDE_KIKAKUI: hb_script_t = 1298493028;
pub const HB_SCRIPT_MODI: hb_script_t = 1299145833;
pub const HB_SCRIPT_MRO: hb_script_t = 1299345263;
pub const HB_SCRIPT_NABATAEAN: hb_script_t = 1315070324;
pub const HB_SCRIPT_OLD_NORTH_ARABIAN: hb_script_t = 1315009122;
pub const HB_SCRIPT_OLD_PERMIC: hb_script_t = 1348825709;
pub const HB_SCRIPT_PAHAWH_HMONG: hb_script_t = 1215131239;
pub const HB_SCRIPT_PALMYRENE: hb_script_t = 1348562029;
pub const HB_SCRIPT_PAU_CIN_HAU: hb_script_t = 1348564323;
pub const HB_SCRIPT_PSALTER_PAHLAVI: hb_script_t = 1349020784;
pub const HB_SCRIPT_SIDDHAM: hb_script_t = 1399415908;
pub const HB_SCRIPT_TIRHUTA: hb_script_t = 1416196712;
pub const HB_SCRIPT_WARANG_CITI: hb_script_t = 1466004065;
pub const HB_SCRIPT_AHOM: hb_script_t = 1097363309;
pub const HB_SCRIPT_ANATOLIAN_HIEROGLYPHS: hb_script_t = 1215067511;
pub const HB_SCRIPT_HATRAN: hb_script_t = 1214346354;
pub const HB_SCRIPT_MULTANI: hb_script_t = 1299541108;
pub const HB_SCRIPT_OLD_HUNGARIAN: hb_script_t = 1215655527;
pub const HB_SCRIPT_SIGNWRITING: hb_script_t = 1399287415;
pub const HB_SCRIPT_ADLAM: hb_script_t = 1097100397;
pub const HB_SCRIPT_BHAIKSUKI: hb_script_t = 1114139507;
pub const HB_SCRIPT_MARCHEN: hb_script_t = 1298231907;
pub const HB_SCRIPT_OSAGE: hb_script_t = 1332963173;
pub const HB_SCRIPT_TANGUT: hb_script_t = 1415671399;
pub const HB_SCRIPT_NEWA: hb_script_t = 1315272545;
pub const HB_SCRIPT_MASARAM_GONDI: hb_script_t = 1198485101;
pub const HB_SCRIPT_NUSHU: hb_script_t = 1316186229;
pub const HB_SCRIPT_SOYOMBO: hb_script_t = 1399814511;
pub const HB_SCRIPT_ZANABAZAR_SQUARE: hb_script_t = 1516334690;
pub const HB_SCRIPT_DOGRA: hb_script_t = 1148151666;
pub const HB_SCRIPT_GUNJALA_GONDI: hb_script_t = 1198485095;
pub const HB_SCRIPT_HANIFI_ROHINGYA: hb_script_t = 1383032935;
pub const HB_SCRIPT_MAKASAR: hb_script_t = 1298230113;
pub const HB_SCRIPT_MEDEFAIDRIN: hb_script_t = 1298490470;
pub const HB_SCRIPT_OLD_SOGDIAN: hb_script_t = 1399809903;
pub const HB_SCRIPT_SOGDIAN: hb_script_t = 1399809892;
pub const HB_SCRIPT_ELYMAIC: hb_script_t = 1164736877;
pub const HB_SCRIPT_NANDINAGARI: hb_script_t = 1315008100;
pub const HB_SCRIPT_NYIAKENG_PUACHUE_HMONG: hb_script_t = 1215131248;
pub const HB_SCRIPT_WANCHO: hb_script_t = 1466132591;
pub const HB_SCRIPT_CHORASMIAN: hb_script_t = 1130918515;
pub const HB_SCRIPT_DIVES_AKURU: hb_script_t = 1147756907;
pub const HB_SCRIPT_KHITAN_SMALL_SCRIPT: hb_script_t = 1265202291;
pub const HB_SCRIPT_YEZIDI: hb_script_t = 1499822697;
pub const HB_SCRIPT_CYPRO_MINOAN: hb_script_t = 1131441518;
pub const HB_SCRIPT_OLD_UYGHUR: hb_script_t = 1333094258;
pub const HB_SCRIPT_TANGSA: hb_script_t = 1416524641;
pub const HB_SCRIPT_TOTO: hb_script_t = 1416590447;
pub const HB_SCRIPT_VITHKUQI: hb_script_t = 1449751656;
pub const HB_SCRIPT_MATH: hb_script_t = 1517122664;
pub const HB_SCRIPT_INVALID: hb_script_t = 0;
pub const _HB_SCRIPT_MAX_VALUE: hb_script_t = 2147483647;
pub const _HB_SCRIPT_MAX_VALUE_SIGNED: hb_script_t = 2147483647;
#[doc = " hb_script_t:"]
#[doc = " @HB_SCRIPT_COMMON: `Zyyy`"]
#[doc = " @HB_SCRIPT_INHERITED: `Zinh`"]
#[doc = " @HB_SCRIPT_UNKNOWN: `Zzzz`"]
#[doc = " @HB_SCRIPT_ARABIC: `Arab`"]
#[doc = " @HB_SCRIPT_ARMENIAN: `Armn`"]
#[doc = " @HB_SCRIPT_BENGALI: `Beng`"]
#[doc = " @HB_SCRIPT_CYRILLIC: `Cyrl`"]
#[doc = " @HB_SCRIPT_DEVANAGARI: `Deva`"]
#[doc = " @HB_SCRIPT_GEORGIAN: `Geor`"]
#[doc = " @HB_SCRIPT_GREEK: `Grek`"]
#[doc = " @HB_SCRIPT_GUJARATI: `Gujr`"]
#[doc = " @HB_SCRIPT_GURMUKHI: `Guru`"]
#[doc = " @HB_SCRIPT_HANGUL: `Hang`"]
#[doc = " @HB_SCRIPT_HAN: `Hani`"]
#[doc = " @HB_SCRIPT_HEBREW: `Hebr`"]
#[doc = " @HB_SCRIPT_HIRAGANA: `Hira`"]
#[doc = " @HB_SCRIPT_KANNADA: `Knda`"]
#[doc = " @HB_SCRIPT_KATAKANA: `Kana`"]
#[doc = " @HB_SCRIPT_LAO: `Laoo`"]
#[doc = " @HB_SCRIPT_LATIN: `Latn`"]
#[doc = " @HB_SCRIPT_MALAYALAM: `Mlym`"]
#[doc = " @HB_SCRIPT_ORIYA: `Orya`"]
#[doc = " @HB_SCRIPT_TAMIL: `Taml`"]
#[doc = " @HB_SCRIPT_TELUGU: `Telu`"]
#[doc = " @HB_SCRIPT_THAI: `Thai`"]
#[doc = " @HB_SCRIPT_TIBETAN: `Tibt`"]
#[doc = " @HB_SCRIPT_BOPOMOFO: `Bopo`"]
#[doc = " @HB_SCRIPT_BRAILLE: `Brai`"]
#[doc = " @HB_SCRIPT_CANADIAN_SYLLABICS: `Cans`"]
#[doc = " @HB_SCRIPT_CHEROKEE: `Cher`"]
#[doc = " @HB_SCRIPT_ETHIOPIC: `Ethi`"]
#[doc = " @HB_SCRIPT_KHMER: `Khmr`"]
#[doc = " @HB_SCRIPT_MONGOLIAN: `Mong`"]
#[doc = " @HB_SCRIPT_MYANMAR: `Mymr`"]
#[doc = " @HB_SCRIPT_OGHAM: `Ogam`"]
#[doc = " @HB_SCRIPT_RUNIC: `Runr`"]
#[doc = " @HB_SCRIPT_SINHALA: `Sinh`"]
#[doc = " @HB_SCRIPT_SYRIAC: `Syrc`"]
#[doc = " @HB_SCRIPT_THAANA: `Thaa`"]
#[doc = " @HB_SCRIPT_YI: `Yiii`"]
#[doc = " @HB_SCRIPT_DESERET: `Dsrt`"]
#[doc = " @HB_SCRIPT_GOTHIC: `Goth`"]
#[doc = " @HB_SCRIPT_OLD_ITALIC: `Ital`"]
#[doc = " @HB_SCRIPT_BUHID: `Buhd`"]
#[doc = " @HB_SCRIPT_HANUNOO: `Hano`"]
#[doc = " @HB_SCRIPT_TAGALOG: `Tglg`"]
#[doc = " @HB_SCRIPT_TAGBANWA: `Tagb`"]
#[doc = " @HB_SCRIPT_CYPRIOT: `Cprt`"]
#[doc = " @HB_SCRIPT_LIMBU: `Limb`"]
#[doc = " @HB_SCRIPT_LINEAR_B: `Linb`"]
#[doc = " @HB_SCRIPT_OSMANYA: `Osma`"]
#[doc = " @HB_SCRIPT_SHAVIAN: `Shaw`"]
#[doc = " @HB_SCRIPT_TAI_LE: `Tale`"]
#[doc = " @HB_SCRIPT_UGARITIC: `Ugar`"]
#[doc = " @HB_SCRIPT_BUGINESE: `Bugi`"]
#[doc = " @HB_SCRIPT_COPTIC: `Copt`"]
#[doc = " @HB_SCRIPT_GLAGOLITIC: `Glag`"]
#[doc = " @HB_SCRIPT_KHAROSHTHI: `Khar`"]
#[doc = " @HB_SCRIPT_NEW_TAI_LUE: `Talu`"]
#[doc = " @HB_SCRIPT_OLD_PERSIAN: `Xpeo`"]
#[doc = " @HB_SCRIPT_SYLOTI_NAGRI: `Sylo`"]
#[doc = " @HB_SCRIPT_TIFINAGH: `Tfng`"]
#[doc = " @HB_SCRIPT_BALINESE: `Bali`"]
#[doc = " @HB_SCRIPT_CUNEIFORM: `Xsux`"]
#[doc = " @HB_SCRIPT_NKO: `Nkoo`"]
#[doc = " @HB_SCRIPT_PHAGS_PA: `Phag`"]
#[doc = " @HB_SCRIPT_PHOENICIAN: `Phnx`"]
#[doc = " @HB_SCRIPT_CARIAN: `Cari`"]
#[doc = " @HB_SCRIPT_CHAM: `Cham`"]
#[doc = " @HB_SCRIPT_KAYAH_LI: `Kali`"]
#[doc = " @HB_SCRIPT_LEPCHA: `Lepc`"]
#[doc = " @HB_SCRIPT_LYCIAN: `Lyci`"]
#[doc = " @HB_SCRIPT_LYDIAN: `Lydi`"]
#[doc = " @HB_SCRIPT_OL_CHIKI: `Olck`"]
#[doc = " @HB_SCRIPT_REJANG: `Rjng`"]
#[doc = " @HB_SCRIPT_SAURASHTRA: `Saur`"]
#[doc = " @HB_SCRIPT_SUNDANESE: `Sund`"]
#[doc = " @HB_SCRIPT_VAI: `Vaii`"]
#[doc = " @HB_SCRIPT_AVESTAN: `Avst`"]
#[doc = " @HB_SCRIPT_BAMUM: `Bamu`"]
#[doc = " @HB_SCRIPT_EGYPTIAN_HIEROGLYPHS: `Egyp`"]
#[doc = " @HB_SCRIPT_IMPERIAL_ARAMAIC: `Armi`"]
#[doc = " @HB_SCRIPT_INSCRIPTIONAL_PAHLAVI: `Phli`"]
#[doc = " @HB_SCRIPT_INSCRIPTIONAL_PARTHIAN: `Prti`"]
#[doc = " @HB_SCRIPT_JAVANESE: `Java`"]
#[doc = " @HB_SCRIPT_KAITHI: `Kthi`"]
#[doc = " @HB_SCRIPT_LISU: `Lisu`"]
#[doc = " @HB_SCRIPT_MEETEI_MAYEK: `Mtei`"]
#[doc = " @HB_SCRIPT_OLD_SOUTH_ARABIAN: `Sarb`"]
#[doc = " @HB_SCRIPT_OLD_TURKIC: `Orkh`"]
#[doc = " @HB_SCRIPT_SAMARITAN: `Samr`"]
#[doc = " @HB_SCRIPT_TAI_THAM: `Lana`"]
#[doc = " @HB_SCRIPT_TAI_VIET: `Tavt`"]
#[doc = " @HB_SCRIPT_BATAK: `Batk`"]
#[doc = " @HB_SCRIPT_BRAHMI: `Brah`"]
#[doc = " @HB_SCRIPT_MANDAIC: `Mand`"]
#[doc = " @HB_SCRIPT_CHAKMA: `Cakm`"]
#[doc = " @HB_SCRIPT_MEROITIC_CURSIVE: `Merc`"]
#[doc = " @HB_SCRIPT_MEROITIC_HIEROGLYPHS: `Mero`"]
#[doc = " @HB_SCRIPT_MIAO: `Plrd`"]
#[doc = " @HB_SCRIPT_SHARADA: `Shrd`"]
#[doc = " @HB_SCRIPT_SORA_SOMPENG: `Sora`"]
#[doc = " @HB_SCRIPT_TAKRI: `Takr`"]
#[doc = " @HB_SCRIPT_BASSA_VAH: `Bass`, Since: 0.9.30"]
#[doc = " @HB_SCRIPT_CAUCASIAN_ALBANIAN: `Aghb`, Since: 0.9.30"]
#[doc = " @HB_SCRIPT_DUPLOYAN: `Dupl`, Since: 0.9.30"]
#[doc = " @HB_SCRIPT_ELBASAN: `Elba`, Since: 0.9.30"]
#[doc = " @HB_SCRIPT_GRANTHA: `Gran`, Since: 0.9.30"]
#[doc = " @HB_SCRIPT_KHOJKI: `Khoj`, Since: 0.9.30"]
#[doc = " @HB_SCRIPT_KHUDAWADI: `Sind`, Since: 0.9.30"]
#[doc = " @HB_SCRIPT_LINEAR_A: `Lina`, Since: 0.9.30"]
#[doc = " @HB_SCRIPT_MAHAJANI: `Mahj`, Since: 0.9.30"]
#[doc = " @HB_SCRIPT_MANICHAEAN: `Mani`, Since: 0.9.30"]
#[doc = " @HB_SCRIPT_MENDE_KIKAKUI: `Mend`, Since: 0.9.30"]
#[doc = " @HB_SCRIPT_MODI: `Modi`, Since: 0.9.30"]
#[doc = " @HB_SCRIPT_MRO: `Mroo`, Since: 0.9.30"]
#[doc = " @HB_SCRIPT_NABATAEAN: `Nbat`, Since: 0.9.30"]
#[doc = " @HB_SCRIPT_OLD_NORTH_ARABIAN: `Narb`, Since: 0.9.30"]
#[doc = " @HB_SCRIPT_OLD_PERMIC: `Perm`, Since: 0.9.30"]
#[doc = " @HB_SCRIPT_PAHAWH_HMONG: `Hmng`, Since: 0.9.30"]
#[doc = " @HB_SCRIPT_PALMYRENE: `Palm`, Since: 0.9.30"]
#[doc = " @HB_SCRIPT_PAU_CIN_HAU: `Pauc`, Since: 0.9.30"]
#[doc = " @HB_SCRIPT_PSALTER_PAHLAVI: `Phlp`, Since: 0.9.30"]
#[doc = " @HB_SCRIPT_SIDDHAM: `Sidd`, Since: 0.9.30"]
#[doc = " @HB_SCRIPT_TIRHUTA: `Tirh`, Since: 0.9.30"]
#[doc = " @HB_SCRIPT_WARANG_CITI: `Wara`, Since: 0.9.30"]
#[doc = " @HB_SCRIPT_AHOM: `Ahom`, Since: 0.9.30"]
#[doc = " @HB_SCRIPT_ANATOLIAN_HIEROGLYPHS: `Hluw`, Since: 0.9.30"]
#[doc = " @HB_SCRIPT_HATRAN: `Hatr`, Since: 0.9.30"]
#[doc = " @HB_SCRIPT_MULTANI: `Mult`, Since: 0.9.30"]
#[doc = " @HB_SCRIPT_OLD_HUNGARIAN: `Hung`, Since: 0.9.30"]
#[doc = " @HB_SCRIPT_SIGNWRITING: `Sgnw`, Since: 0.9.30"]
#[doc = " @HB_SCRIPT_ADLAM: `Adlm`, Since: 1.3.0"]
#[doc = " @HB_SCRIPT_BHAIKSUKI: `Bhks`, Since: 1.3.0"]
#[doc = " @HB_SCRIPT_MARCHEN: `Marc`, Since: 1.3.0"]
#[doc = " @HB_SCRIPT_OSAGE: `Osge`, Since: 1.3.0"]
#[doc = " @HB_SCRIPT_TANGUT: `Tang`, Since: 1.3.0"]
#[doc = " @HB_SCRIPT_NEWA: `Newa`, Since: 1.3.0"]
#[doc = " @HB_SCRIPT_MASARAM_GONDI: `Gonm`, Since: 1.6.0"]
#[doc = " @HB_SCRIPT_NUSHU: `Nshu`, Since: 1.6.0"]
#[doc = " @HB_SCRIPT_SOYOMBO: `Soyo`, Since: 1.6.0"]
#[doc = " @HB_SCRIPT_ZANABAZAR_SQUARE: `Zanb`, Since: 1.6.0"]
#[doc = " @HB_SCRIPT_DOGRA: `Dogr`, Since: 1.8.0"]
#[doc = " @HB_SCRIPT_GUNJALA_GONDI: `Gong`, Since: 1.8.0"]
#[doc = " @HB_SCRIPT_HANIFI_ROHINGYA: `Rohg`, Since: 1.8.0"]
#[doc = " @HB_SCRIPT_MAKASAR: `Maka`, Since: 1.8.0"]
#[doc = " @HB_SCRIPT_MEDEFAIDRIN: `Medf`, Since: 1.8.0"]
#[doc = " @HB_SCRIPT_OLD_SOGDIAN: `Sogo`, Since: 1.8.0"]
#[doc = " @HB_SCRIPT_SOGDIAN: `Sogd`, Since: 1.8.0"]
#[doc = " @HB_SCRIPT_ELYMAIC: `Elym`, Since: 2.4.0"]
#[doc = " @HB_SCRIPT_NANDINAGARI: `Nand`, Since: 2.4.0"]
#[doc = " @HB_SCRIPT_NYIAKENG_PUACHUE_HMONG: `Hmnp`, Since: 2.4.0"]
#[doc = " @HB_SCRIPT_WANCHO: `Wcho`, Since: 2.4.0"]
#[doc = " @HB_SCRIPT_CHORASMIAN: `Chrs`, Since: 2.6.7"]
#[doc = " @HB_SCRIPT_DIVES_AKURU: `Diak`, Since: 2.6.7"]
#[doc = " @HB_SCRIPT_KHITAN_SMALL_SCRIPT: `Kits`, Since: 2.6.7"]
#[doc = " @HB_SCRIPT_YEZIDI: `Yezi`, Since: 2.6.7"]
#[doc = " @HB_SCRIPT_CYPRO_MINOAN: `Cpmn`, Since: 3.0.0"]
#[doc = " @HB_SCRIPT_OLD_UYGHUR: `Ougr`, Since: 3.0.0"]
#[doc = " @HB_SCRIPT_TANGSA: `Tnsa`, Since: 3.0.0"]
#[doc = " @HB_SCRIPT_TOTO: `Toto`, Since: 3.0.0"]
#[doc = " @HB_SCRIPT_VITHKUQI: `Vith`, Since: 3.0.0"]
#[doc = " @HB_SCRIPT_MATH: `Zmth`, Since: 3.4.0"]
#[doc = " @HB_SCRIPT_INVALID: No script set"]
#[doc = ""]
#[doc = " Data type for scripts. Each #hb_script_t's value is an #hb_tag_t corresponding"]
#[doc = " to the four-letter values defined by [ISO 15924](https://unicode.org/iso15924/)."]
#[doc = ""]
#[doc = " See also the Script (sc) property of the Unicode Character Database."]
#[doc = ""]
pub type hb_script_t = ::std::os::raw::c_uint;
extern "C" {
    pub fn hb_script_from_iso15924_tag(tag: hb_tag_t) -> hb_script_t;
}
extern "C" {
    pub fn hb_script_from_string(
        str_: *const ::std::os::raw::c_char,
        len: ::std::os::raw::c_int,
    ) -> hb_script_t;
}
extern "C" {
    pub fn hb_script_to_iso15924_tag(script: hb_script_t) -> hb_tag_t;
}
extern "C" {
    pub fn hb_script_get_horizontal_direction(script: hb_script_t) -> hb_direction_t;
}
#[doc = " hb_user_data_key_t:"]
#[doc = ""]
#[doc = " Data structure for holding user-data keys."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hb_user_data_key_t {
    pub unused: ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_hb_user_data_key_t() {
    assert_eq!(
        ::std::mem::size_of::<hb_user_data_key_t>(),
        1usize,
        concat!("Size of: ", stringify!(hb_user_data_key_t))
    );
    assert_eq!(
        ::std::mem::align_of::<hb_user_data_key_t>(),
        1usize,
        concat!("Alignment of ", stringify!(hb_user_data_key_t))
    );
    fn test_field_unused() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<hb_user_data_key_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).unused) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(hb_user_data_key_t),
                "::",
                stringify!(unused)
            )
        );
    }
    test_field_unused();
}
#[doc = " hb_destroy_func_t:"]
#[doc = " @user_data: the data to be destroyed"]
#[doc = ""]
#[doc = " A virtual method for destroy user-data callbacks."]
#[doc = ""]
pub type hb_destroy_func_t =
    ::std::option::Option<unsafe extern "C" fn(user_data: *mut ::std::os::raw::c_void)>;
#[doc = " hb_feature_t:"]
#[doc = " @tag: The #hb_tag_t tag of the feature"]
#[doc = " @value: The value of the feature. 0 disables the feature, non-zero (usually"]
#[doc = " 1) enables the feature.  For features implemented as lookup type 3 (like"]
#[doc = " 'salt') the @value is a one based index into the alternates."]
#[doc = " @start: the cluster to start applying this feature setting (inclusive)."]
#[doc = " @end: the cluster to end applying this feature setting (exclusive)."]
#[doc = ""]
#[doc = " The #hb_feature_t is the structure that holds information about requested"]
#[doc = " feature application. The feature will be applied with the given value to all"]
#[doc = " glyphs which are in clusters between @start (inclusive) and @end (exclusive)."]
#[doc = " Setting start to #HB_FEATURE_GLOBAL_START and end to #HB_FEATURE_GLOBAL_END"]
#[doc = " specifies that the feature always applies to the entire buffer."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hb_feature_t {
    pub tag: hb_tag_t,
    pub value: u32,
    pub start: ::std::os::raw::c_uint,
    pub end: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_hb_feature_t() {
    assert_eq!(
        ::std::mem::size_of::<hb_feature_t>(),
        16usize,
        concat!("Size of: ", stringify!(hb_feature_t))
    );
    assert_eq!(
        ::std::mem::align_of::<hb_feature_t>(),
        4usize,
        concat!("Alignment of ", stringify!(hb_feature_t))
    );
    fn test_field_tag() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<hb_feature_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tag) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(hb_feature_t),
                "::",
                stringify!(tag)
            )
        );
    }
    test_field_tag();
    fn test_field_value() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<hb_feature_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(hb_feature_t),
                "::",
                stringify!(value)
            )
        );
    }
    test_field_value();
    fn test_field_start() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<hb_feature_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).start) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(hb_feature_t),
                "::",
                stringify!(start)
            )
        );
    }
    test_field_start();
    fn test_field_end() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<hb_feature_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).end) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(hb_feature_t),
                "::",
                stringify!(end)
            )
        );
    }
    test_field_end();
}
extern "C" {
    pub fn hb_feature_from_string(
        str_: *const ::std::os::raw::c_char,
        len: ::std::os::raw::c_int,
        feature: *mut hb_feature_t,
    ) -> hb_bool_t;
}
extern "C" {
    pub fn hb_feature_to_string(
        feature: *mut hb_feature_t,
        buf: *mut ::std::os::raw::c_char,
        size: ::std::os::raw::c_uint,
    );
}
#[doc = " hb_variation_t:"]
#[doc = " @tag: The #hb_tag_t tag of the variation-axis name"]
#[doc = " @value: The value of the variation axis"]
#[doc = ""]
#[doc = " Data type for holding variation data. Registered OpenType"]
#[doc = " variation-axis tags are listed in"]
#[doc = " [OpenType Axis Tag Registry](https://docs.microsoft.com/en-us/typography/opentype/spec/dvaraxisreg)."]
#[doc = ""]
#[doc = " Since: 1.4.2"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hb_variation_t {
    pub tag: hb_tag_t,
    pub value: ::std::os::raw::c_float,
}
#[test]
fn bindgen_test_layout_hb_variation_t() {
    assert_eq!(
        ::std::mem::size_of::<hb_variation_t>(),
        8usize,
        concat!("Size of: ", stringify!(hb_variation_t))
    );
    assert_eq!(
        ::std::mem::align_of::<hb_variation_t>(),
        4usize,
        concat!("Alignment of ", stringify!(hb_variation_t))
    );
    fn test_field_tag() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<hb_variation_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tag) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(hb_variation_t),
                "::",
                stringify!(tag)
            )
        );
    }
    test_field_tag();
    fn test_field_value() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<hb_variation_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(hb_variation_t),
                "::",
                stringify!(value)
            )
        );
    }
    test_field_value();
}
extern "C" {
    pub fn hb_variation_from_string(
        str_: *const ::std::os::raw::c_char,
        len: ::std::os::raw::c_int,
        variation: *mut hb_variation_t,
    ) -> hb_bool_t;
}
extern "C" {
    pub fn hb_variation_to_string(
        variation: *mut hb_variation_t,
        buf: *mut ::std::os::raw::c_char,
        size: ::std::os::raw::c_uint,
    );
}
#[doc = " hb_color_t:"]
#[doc = ""]
#[doc = " Data type for holding color values. Colors are eight bits per"]
#[doc = " channel RGB plus alpha transparency."]
#[doc = ""]
#[doc = " Since: 2.1.0"]
pub type hb_color_t = u32;
extern "C" {
    pub fn hb_color_get_alpha(color: hb_color_t) -> u8;
}
extern "C" {
    pub fn hb_color_get_red(color: hb_color_t) -> u8;
}
extern "C" {
    pub fn hb_color_get_green(color: hb_color_t) -> u8;
}
extern "C" {
    pub fn hb_color_get_blue(color: hb_color_t) -> u8;
}
pub const HB_MEMORY_MODE_DUPLICATE: hb_memory_mode_t = 0;
pub const HB_MEMORY_MODE_READONLY: hb_memory_mode_t = 1;
pub const HB_MEMORY_MODE_WRITABLE: hb_memory_mode_t = 2;
pub const HB_MEMORY_MODE_READONLY_MAY_MAKE_WRITABLE: hb_memory_mode_t = 3;
#[doc = " hb_memory_mode_t:"]
#[doc = " @HB_MEMORY_MODE_DUPLICATE: HarfBuzz immediately makes a copy of the data."]
#[doc = " @HB_MEMORY_MODE_READONLY: HarfBuzz client will never modify the data,"]
#[doc = "     and HarfBuzz will never modify the data."]
#[doc = " @HB_MEMORY_MODE_WRITABLE: HarfBuzz client made a copy of the data solely"]
#[doc = "     for HarfBuzz, so HarfBuzz may modify the data."]
#[doc = " @HB_MEMORY_MODE_READONLY_MAY_MAKE_WRITABLE: See above"]
#[doc = ""]
#[doc = " Data type holding the memory modes available to"]
#[doc = " client programs."]
#[doc = ""]
#[doc = " Regarding these various memory-modes:"]
#[doc = ""]
#[doc = " - In no case shall the HarfBuzz client modify memory"]
#[doc = "   that is passed to HarfBuzz in a blob.  If there is"]
#[doc = "   any such possibility, @HB_MEMORY_MODE_DUPLICATE should be used"]
#[doc = "   such that HarfBuzz makes a copy immediately,"]
#[doc = ""]
#[doc = " - Use @HB_MEMORY_MODE_READONLY otherwise, unless you really really"]
#[doc = "   really know what you are doing,"]
#[doc = ""]
#[doc = " - @HB_MEMORY_MODE_WRITABLE is appropriate if you really made a"]
#[doc = "   copy of data solely for the purpose of passing to"]
#[doc = "   HarfBuzz and doing that just once (no reuse!),"]
#[doc = ""]
#[doc = " - If the font is mmap()ed, it's okay to use"]
#[doc = "   @HB_MEMORY_READONLY_MAY_MAKE_WRITABLE, however, using that mode"]
#[doc = "   correctly is very tricky.  Use @HB_MEMORY_MODE_READONLY instead."]
pub type hb_memory_mode_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hb_blob_t {
    _unused: [u8; 0],
}
extern "C" {
    pub fn hb_blob_create(
        data: *const ::std::os::raw::c_char,
        length: ::std::os::raw::c_uint,
        mode: hb_memory_mode_t,
        user_data: *mut ::std::os::raw::c_void,
        destroy: hb_destroy_func_t,
    ) -> *mut hb_blob_t;
}
extern "C" {
    pub fn hb_blob_create_or_fail(
        data: *const ::std::os::raw::c_char,
        length: ::std::os::raw::c_uint,
        mode: hb_memory_mode_t,
        user_data: *mut ::std::os::raw::c_void,
        destroy: hb_destroy_func_t,
    ) -> *mut hb_blob_t;
}
extern "C" {
    pub fn hb_blob_create_from_file(file_name: *const ::std::os::raw::c_char) -> *mut hb_blob_t;
}
extern "C" {
    pub fn hb_blob_create_from_file_or_fail(
        file_name: *const ::std::os::raw::c_char,
    ) -> *mut hb_blob_t;
}
extern "C" {
    pub fn hb_blob_create_sub_blob(
        parent: *mut hb_blob_t,
        offset: ::std::os::raw::c_uint,
        length: ::std::os::raw::c_uint,
    ) -> *mut hb_blob_t;
}
extern "C" {
    pub fn hb_blob_copy_writable_or_fail(blob: *mut hb_blob_t) -> *mut hb_blob_t;
}
extern "C" {
    pub fn hb_blob_get_empty() -> *mut hb_blob_t;
}
extern "C" {
    pub fn hb_blob_reference(blob: *mut hb_blob_t) -> *mut hb_blob_t;
}
extern "C" {
    pub fn hb_blob_destroy(blob: *mut hb_blob_t);
}
extern "C" {
    pub fn hb_blob_set_user_data(
        blob: *mut hb_blob_t,
        key: *mut hb_user_data_key_t,
        data: *mut ::std::os::raw::c_void,
        destroy: hb_destroy_func_t,
        replace: hb_bool_t,
    ) -> hb_bool_t;
}
extern "C" {
    pub fn hb_blob_get_user_data(
        blob: *mut hb_blob_t,
        key: *mut hb_user_data_key_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn hb_blob_make_immutable(blob: *mut hb_blob_t);
}
extern "C" {
    pub fn hb_blob_is_immutable(blob: *mut hb_blob_t) -> hb_bool_t;
}
extern "C" {
    pub fn hb_blob_get_length(blob: *mut hb_blob_t) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn hb_blob_get_data(
        blob: *mut hb_blob_t,
        length: *mut ::std::os::raw::c_uint,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn hb_blob_get_data_writable(
        blob: *mut hb_blob_t,
        length: *mut ::std::os::raw::c_uint,
    ) -> *mut ::std::os::raw::c_char;
}
pub const HB_UNICODE_GENERAL_CATEGORY_CONTROL: hb_unicode_general_category_t = 0;
pub const HB_UNICODE_GENERAL_CATEGORY_FORMAT: hb_unicode_general_category_t = 1;
pub const HB_UNICODE_GENERAL_CATEGORY_UNASSIGNED: hb_unicode_general_category_t = 2;
pub const HB_UNICODE_GENERAL_CATEGORY_PRIVATE_USE: hb_unicode_general_category_t = 3;
pub const HB_UNICODE_GENERAL_CATEGORY_SURROGATE: hb_unicode_general_category_t = 4;
pub const HB_UNICODE_GENERAL_CATEGORY_LOWERCASE_LETTER: hb_unicode_general_category_t = 5;
pub const HB_UNICODE_GENERAL_CATEGORY_MODIFIER_LETTER: hb_unicode_general_category_t = 6;
pub const HB_UNICODE_GENERAL_CATEGORY_OTHER_LETTER: hb_unicode_general_category_t = 7;
pub const HB_UNICODE_GENERAL_CATEGORY_TITLECASE_LETTER: hb_unicode_general_category_t = 8;
pub const HB_UNICODE_GENERAL_CATEGORY_UPPERCASE_LETTER: hb_unicode_general_category_t = 9;
pub const HB_UNICODE_GENERAL_CATEGORY_SPACING_MARK: hb_unicode_general_category_t = 10;
pub const HB_UNICODE_GENERAL_CATEGORY_ENCLOSING_MARK: hb_unicode_general_category_t = 11;
pub const HB_UNICODE_GENERAL_CATEGORY_NON_SPACING_MARK: hb_unicode_general_category_t = 12;
pub const HB_UNICODE_GENERAL_CATEGORY_DECIMAL_NUMBER: hb_unicode_general_category_t = 13;
pub const HB_UNICODE_GENERAL_CATEGORY_LETTER_NUMBER: hb_unicode_general_category_t = 14;
pub const HB_UNICODE_GENERAL_CATEGORY_OTHER_NUMBER: hb_unicode_general_category_t = 15;
pub const HB_UNICODE_GENERAL_CATEGORY_CONNECT_PUNCTUATION: hb_unicode_general_category_t = 16;
pub const HB_UNICODE_GENERAL_CATEGORY_DASH_PUNCTUATION: hb_unicode_general_category_t = 17;
pub const HB_UNICODE_GENERAL_CATEGORY_CLOSE_PUNCTUATION: hb_unicode_general_category_t = 18;
pub const HB_UNICODE_GENERAL_CATEGORY_FINAL_PUNCTUATION: hb_unicode_general_category_t = 19;
pub const HB_UNICODE_GENERAL_CATEGORY_INITIAL_PUNCTUATION: hb_unicode_general_category_t = 20;
pub const HB_UNICODE_GENERAL_CATEGORY_OTHER_PUNCTUATION: hb_unicode_general_category_t = 21;
pub const HB_UNICODE_GENERAL_CATEGORY_OPEN_PUNCTUATION: hb_unicode_general_category_t = 22;
pub const HB_UNICODE_GENERAL_CATEGORY_CURRENCY_SYMBOL: hb_unicode_general_category_t = 23;
pub const HB_UNICODE_GENERAL_CATEGORY_MODIFIER_SYMBOL: hb_unicode_general_category_t = 24;
pub const HB_UNICODE_GENERAL_CATEGORY_MATH_SYMBOL: hb_unicode_general_category_t = 25;
pub const HB_UNICODE_GENERAL_CATEGORY_OTHER_SYMBOL: hb_unicode_general_category_t = 26;
pub const HB_UNICODE_GENERAL_CATEGORY_LINE_SEPARATOR: hb_unicode_general_category_t = 27;
pub const HB_UNICODE_GENERAL_CATEGORY_PARAGRAPH_SEPARATOR: hb_unicode_general_category_t = 28;
pub const HB_UNICODE_GENERAL_CATEGORY_SPACE_SEPARATOR: hb_unicode_general_category_t = 29;
#[doc = " hb_unicode_general_category_t:"]
#[doc = " @HB_UNICODE_GENERAL_CATEGORY_CONTROL:              [Cc]"]
#[doc = " @HB_UNICODE_GENERAL_CATEGORY_FORMAT:\t\t      [Cf]"]
#[doc = " @HB_UNICODE_GENERAL_CATEGORY_UNASSIGNED:\t      [Cn]"]
#[doc = " @HB_UNICODE_GENERAL_CATEGORY_PRIVATE_USE:\t      [Co]"]
#[doc = " @HB_UNICODE_GENERAL_CATEGORY_SURROGATE:\t      [Cs]"]
#[doc = " @HB_UNICODE_GENERAL_CATEGORY_LOWERCASE_LETTER:     [Ll]"]
#[doc = " @HB_UNICODE_GENERAL_CATEGORY_MODIFIER_LETTER:      [Lm]"]
#[doc = " @HB_UNICODE_GENERAL_CATEGORY_OTHER_LETTER:\t      [Lo]"]
#[doc = " @HB_UNICODE_GENERAL_CATEGORY_TITLECASE_LETTER:     [Lt]"]
#[doc = " @HB_UNICODE_GENERAL_CATEGORY_UPPERCASE_LETTER:     [Lu]"]
#[doc = " @HB_UNICODE_GENERAL_CATEGORY_SPACING_MARK:\t      [Mc]"]
#[doc = " @HB_UNICODE_GENERAL_CATEGORY_ENCLOSING_MARK:\t      [Me]"]
#[doc = " @HB_UNICODE_GENERAL_CATEGORY_NON_SPACING_MARK:     [Mn]"]
#[doc = " @HB_UNICODE_GENERAL_CATEGORY_DECIMAL_NUMBER:\t      [Nd]"]
#[doc = " @HB_UNICODE_GENERAL_CATEGORY_LETTER_NUMBER:\t      [Nl]"]
#[doc = " @HB_UNICODE_GENERAL_CATEGORY_OTHER_NUMBER:\t      [No]"]
#[doc = " @HB_UNICODE_GENERAL_CATEGORY_CONNECT_PUNCTUATION:  [Pc]"]
#[doc = " @HB_UNICODE_GENERAL_CATEGORY_DASH_PUNCTUATION:     [Pd]"]
#[doc = " @HB_UNICODE_GENERAL_CATEGORY_CLOSE_PUNCTUATION:    [Pe]"]
#[doc = " @HB_UNICODE_GENERAL_CATEGORY_FINAL_PUNCTUATION:    [Pf]"]
#[doc = " @HB_UNICODE_GENERAL_CATEGORY_INITIAL_PUNCTUATION:  [Pi]"]
#[doc = " @HB_UNICODE_GENERAL_CATEGORY_OTHER_PUNCTUATION:    [Po]"]
#[doc = " @HB_UNICODE_GENERAL_CATEGORY_OPEN_PUNCTUATION:     [Ps]"]
#[doc = " @HB_UNICODE_GENERAL_CATEGORY_CURRENCY_SYMBOL:      [Sc]"]
#[doc = " @HB_UNICODE_GENERAL_CATEGORY_MODIFIER_SYMBOL:      [Sk]"]
#[doc = " @HB_UNICODE_GENERAL_CATEGORY_MATH_SYMBOL:\t      [Sm]"]
#[doc = " @HB_UNICODE_GENERAL_CATEGORY_OTHER_SYMBOL:\t      [So]"]
#[doc = " @HB_UNICODE_GENERAL_CATEGORY_LINE_SEPARATOR:\t      [Zl]"]
#[doc = " @HB_UNICODE_GENERAL_CATEGORY_PARAGRAPH_SEPARATOR:  [Zp]"]
#[doc = " @HB_UNICODE_GENERAL_CATEGORY_SPACE_SEPARATOR:      [Zs]"]
#[doc = ""]
#[doc = " Data type for the \"General_Category\" (gc) property from"]
#[doc = " the Unicode Character Database."]
pub type hb_unicode_general_category_t = ::std::os::raw::c_uint;
pub const HB_UNICODE_COMBINING_CLASS_NOT_REORDERED: hb_unicode_combining_class_t = 0;
pub const HB_UNICODE_COMBINING_CLASS_OVERLAY: hb_unicode_combining_class_t = 1;
pub const HB_UNICODE_COMBINING_CLASS_NUKTA: hb_unicode_combining_class_t = 7;
pub const HB_UNICODE_COMBINING_CLASS_KANA_VOICING: hb_unicode_combining_class_t = 8;
pub const HB_UNICODE_COMBINING_CLASS_VIRAMA: hb_unicode_combining_class_t = 9;
pub const HB_UNICODE_COMBINING_CLASS_CCC10: hb_unicode_combining_class_t = 10;
pub const HB_UNICODE_COMBINING_CLASS_CCC11: hb_unicode_combining_class_t = 11;
pub const HB_UNICODE_COMBINING_CLASS_CCC12: hb_unicode_combining_class_t = 12;
pub const HB_UNICODE_COMBINING_CLASS_CCC13: hb_unicode_combining_class_t = 13;
pub const HB_UNICODE_COMBINING_CLASS_CCC14: hb_unicode_combining_class_t = 14;
pub const HB_UNICODE_COMBINING_CLASS_CCC15: hb_unicode_combining_class_t = 15;
pub const HB_UNICODE_COMBINING_CLASS_CCC16: hb_unicode_combining_class_t = 16;
pub const HB_UNICODE_COMBINING_CLASS_CCC17: hb_unicode_combining_class_t = 17;
pub const HB_UNICODE_COMBINING_CLASS_CCC18: hb_unicode_combining_class_t = 18;
pub const HB_UNICODE_COMBINING_CLASS_CCC19: hb_unicode_combining_class_t = 19;
pub const HB_UNICODE_COMBINING_CLASS_CCC20: hb_unicode_combining_class_t = 20;
pub const HB_UNICODE_COMBINING_CLASS_CCC21: hb_unicode_combining_class_t = 21;
pub const HB_UNICODE_COMBINING_CLASS_CCC22: hb_unicode_combining_class_t = 22;
pub const HB_UNICODE_COMBINING_CLASS_CCC23: hb_unicode_combining_class_t = 23;
pub const HB_UNICODE_COMBINING_CLASS_CCC24: hb_unicode_combining_class_t = 24;
pub const HB_UNICODE_COMBINING_CLASS_CCC25: hb_unicode_combining_class_t = 25;
pub const HB_UNICODE_COMBINING_CLASS_CCC26: hb_unicode_combining_class_t = 26;
pub const HB_UNICODE_COMBINING_CLASS_CCC27: hb_unicode_combining_class_t = 27;
pub const HB_UNICODE_COMBINING_CLASS_CCC28: hb_unicode_combining_class_t = 28;
pub const HB_UNICODE_COMBINING_CLASS_CCC29: hb_unicode_combining_class_t = 29;
pub const HB_UNICODE_COMBINING_CLASS_CCC30: hb_unicode_combining_class_t = 30;
pub const HB_UNICODE_COMBINING_CLASS_CCC31: hb_unicode_combining_class_t = 31;
pub const HB_UNICODE_COMBINING_CLASS_CCC32: hb_unicode_combining_class_t = 32;
pub const HB_UNICODE_COMBINING_CLASS_CCC33: hb_unicode_combining_class_t = 33;
pub const HB_UNICODE_COMBINING_CLASS_CCC34: hb_unicode_combining_class_t = 34;
pub const HB_UNICODE_COMBINING_CLASS_CCC35: hb_unicode_combining_class_t = 35;
pub const HB_UNICODE_COMBINING_CLASS_CCC36: hb_unicode_combining_class_t = 36;
pub const HB_UNICODE_COMBINING_CLASS_CCC84: hb_unicode_combining_class_t = 84;
pub const HB_UNICODE_COMBINING_CLASS_CCC91: hb_unicode_combining_class_t = 91;
pub const HB_UNICODE_COMBINING_CLASS_CCC103: hb_unicode_combining_class_t = 103;
pub const HB_UNICODE_COMBINING_CLASS_CCC107: hb_unicode_combining_class_t = 107;
pub const HB_UNICODE_COMBINING_CLASS_CCC118: hb_unicode_combining_class_t = 118;
pub const HB_UNICODE_COMBINING_CLASS_CCC122: hb_unicode_combining_class_t = 122;
pub const HB_UNICODE_COMBINING_CLASS_CCC129: hb_unicode_combining_class_t = 129;
pub const HB_UNICODE_COMBINING_CLASS_CCC130: hb_unicode_combining_class_t = 130;
pub const HB_UNICODE_COMBINING_CLASS_CCC133: hb_unicode_combining_class_t = 132;
pub const HB_UNICODE_COMBINING_CLASS_ATTACHED_BELOW_LEFT: hb_unicode_combining_class_t = 200;
pub const HB_UNICODE_COMBINING_CLASS_ATTACHED_BELOW: hb_unicode_combining_class_t = 202;
pub const HB_UNICODE_COMBINING_CLASS_ATTACHED_ABOVE: hb_unicode_combining_class_t = 214;
pub const HB_UNICODE_COMBINING_CLASS_ATTACHED_ABOVE_RIGHT: hb_unicode_combining_class_t = 216;
pub const HB_UNICODE_COMBINING_CLASS_BELOW_LEFT: hb_unicode_combining_class_t = 218;
pub const HB_UNICODE_COMBINING_CLASS_BELOW: hb_unicode_combining_class_t = 220;
pub const HB_UNICODE_COMBINING_CLASS_BELOW_RIGHT: hb_unicode_combining_class_t = 222;
pub const HB_UNICODE_COMBINING_CLASS_LEFT: hb_unicode_combining_class_t = 224;
pub const HB_UNICODE_COMBINING_CLASS_RIGHT: hb_unicode_combining_class_t = 226;
pub const HB_UNICODE_COMBINING_CLASS_ABOVE_LEFT: hb_unicode_combining_class_t = 228;
pub const HB_UNICODE_COMBINING_CLASS_ABOVE: hb_unicode_combining_class_t = 230;
pub const HB_UNICODE_COMBINING_CLASS_ABOVE_RIGHT: hb_unicode_combining_class_t = 232;
pub const HB_UNICODE_COMBINING_CLASS_DOUBLE_BELOW: hb_unicode_combining_class_t = 233;
pub const HB_UNICODE_COMBINING_CLASS_DOUBLE_ABOVE: hb_unicode_combining_class_t = 234;
pub const HB_UNICODE_COMBINING_CLASS_IOTA_SUBSCRIPT: hb_unicode_combining_class_t = 240;
pub const HB_UNICODE_COMBINING_CLASS_INVALID: hb_unicode_combining_class_t = 255;
#[doc = " hb_unicode_combining_class_t:"]
#[doc = " @HB_UNICODE_COMBINING_CLASS_NOT_REORDERED: Spacing and enclosing marks; also many vowel and consonant signs, even if nonspacing"]
#[doc = " @HB_UNICODE_COMBINING_CLASS_OVERLAY: Marks which overlay a base letter or symbol"]
#[doc = " @HB_UNICODE_COMBINING_CLASS_NUKTA: Diacritic nukta marks in Brahmi-derived scripts"]
#[doc = " @HB_UNICODE_COMBINING_CLASS_KANA_VOICING: Hiragana/Katakana voicing marks"]
#[doc = " @HB_UNICODE_COMBINING_CLASS_VIRAMA: Viramas"]
#[doc = " @HB_UNICODE_COMBINING_CLASS_CCC10: [Hebrew]"]
#[doc = " @HB_UNICODE_COMBINING_CLASS_CCC11: [Hebrew]"]
#[doc = " @HB_UNICODE_COMBINING_CLASS_CCC12: [Hebrew]"]
#[doc = " @HB_UNICODE_COMBINING_CLASS_CCC13: [Hebrew]"]
#[doc = " @HB_UNICODE_COMBINING_CLASS_CCC14: [Hebrew]"]
#[doc = " @HB_UNICODE_COMBINING_CLASS_CCC15: [Hebrew]"]
#[doc = " @HB_UNICODE_COMBINING_CLASS_CCC16: [Hebrew]"]
#[doc = " @HB_UNICODE_COMBINING_CLASS_CCC17: [Hebrew]"]
#[doc = " @HB_UNICODE_COMBINING_CLASS_CCC18: [Hebrew]"]
#[doc = " @HB_UNICODE_COMBINING_CLASS_CCC19: [Hebrew]"]
#[doc = " @HB_UNICODE_COMBINING_CLASS_CCC20: [Hebrew]"]
#[doc = " @HB_UNICODE_COMBINING_CLASS_CCC21: [Hebrew]"]
#[doc = " @HB_UNICODE_COMBINING_CLASS_CCC22: [Hebrew]"]
#[doc = " @HB_UNICODE_COMBINING_CLASS_CCC23: [Hebrew]"]
#[doc = " @HB_UNICODE_COMBINING_CLASS_CCC24: [Hebrew]"]
#[doc = " @HB_UNICODE_COMBINING_CLASS_CCC25: [Hebrew]"]
#[doc = " @HB_UNICODE_COMBINING_CLASS_CCC26: [Hebrew]"]
#[doc = " @HB_UNICODE_COMBINING_CLASS_CCC27: [Arabic]"]
#[doc = " @HB_UNICODE_COMBINING_CLASS_CCC28: [Arabic]"]
#[doc = " @HB_UNICODE_COMBINING_CLASS_CCC29: [Arabic]"]
#[doc = " @HB_UNICODE_COMBINING_CLASS_CCC30: [Arabic]"]
#[doc = " @HB_UNICODE_COMBINING_CLASS_CCC31: [Arabic]"]
#[doc = " @HB_UNICODE_COMBINING_CLASS_CCC32: [Arabic]"]
#[doc = " @HB_UNICODE_COMBINING_CLASS_CCC33: [Arabic]"]
#[doc = " @HB_UNICODE_COMBINING_CLASS_CCC34: [Arabic]"]
#[doc = " @HB_UNICODE_COMBINING_CLASS_CCC35: [Arabic]"]
#[doc = " @HB_UNICODE_COMBINING_CLASS_CCC36: [Syriac]"]
#[doc = " @HB_UNICODE_COMBINING_CLASS_CCC84: [Telugu]"]
#[doc = " @HB_UNICODE_COMBINING_CLASS_CCC91: [Telugu]"]
#[doc = " @HB_UNICODE_COMBINING_CLASS_CCC103: [Thai]"]
#[doc = " @HB_UNICODE_COMBINING_CLASS_CCC107: [Thai]"]
#[doc = " @HB_UNICODE_COMBINING_CLASS_CCC118: [Lao]"]
#[doc = " @HB_UNICODE_COMBINING_CLASS_CCC122: [Lao]"]
#[doc = " @HB_UNICODE_COMBINING_CLASS_CCC129: [Tibetan]"]
#[doc = " @HB_UNICODE_COMBINING_CLASS_CCC130: [Tibetan]"]
#[doc = " @HB_UNICODE_COMBINING_CLASS_CCC133: [Tibetan]"]
#[doc = " @HB_UNICODE_COMBINING_CLASS_ATTACHED_BELOW_LEFT: Marks attached at the bottom left"]
#[doc = " @HB_UNICODE_COMBINING_CLASS_ATTACHED_BELOW: Marks attached directly below"]
#[doc = " @HB_UNICODE_COMBINING_CLASS_ATTACHED_ABOVE: Marks attached directly above"]
#[doc = " @HB_UNICODE_COMBINING_CLASS_ATTACHED_ABOVE_RIGHT: Marks attached at the top right"]
#[doc = " @HB_UNICODE_COMBINING_CLASS_BELOW_LEFT: Distinct marks at the bottom left"]
#[doc = " @HB_UNICODE_COMBINING_CLASS_BELOW: Distinct marks directly below"]
#[doc = " @HB_UNICODE_COMBINING_CLASS_BELOW_RIGHT: Distinct marks at the bottom right"]
#[doc = " @HB_UNICODE_COMBINING_CLASS_LEFT: Distinct marks to the left"]
#[doc = " @HB_UNICODE_COMBINING_CLASS_RIGHT: Distinct marks to the right"]
#[doc = " @HB_UNICODE_COMBINING_CLASS_ABOVE_LEFT: Distinct marks at the top left"]
#[doc = " @HB_UNICODE_COMBINING_CLASS_ABOVE: Distinct marks directly above"]
#[doc = " @HB_UNICODE_COMBINING_CLASS_ABOVE_RIGHT: Distinct marks at the top right"]
#[doc = " @HB_UNICODE_COMBINING_CLASS_DOUBLE_BELOW: Distinct marks subtending two bases"]
#[doc = " @HB_UNICODE_COMBINING_CLASS_DOUBLE_ABOVE: Distinct marks extending above two bases"]
#[doc = " @HB_UNICODE_COMBINING_CLASS_IOTA_SUBSCRIPT: Greek iota subscript only"]
#[doc = " @HB_UNICODE_COMBINING_CLASS_INVALID: Invalid combining class"]
#[doc = ""]
#[doc = " Data type for the Canonical_Combining_Class (ccc) property"]
#[doc = " from the Unicode Character Database."]
#[doc = ""]
#[doc = " <note>Note: newer versions of Unicode may add new values."]
#[doc = " Client programs should be ready to handle any value in the 0..254 range"]
#[doc = " being returned from hb_unicode_combining_class().</note>"]
#[doc = ""]
pub type hb_unicode_combining_class_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hb_unicode_funcs_t {
    _unused: [u8; 0],
}
extern "C" {
    pub fn hb_unicode_funcs_get_default() -> *mut hb_unicode_funcs_t;
}
extern "C" {
    pub fn hb_unicode_funcs_create(parent: *mut hb_unicode_funcs_t) -> *mut hb_unicode_funcs_t;
}
extern "C" {
    pub fn hb_unicode_funcs_get_empty() -> *mut hb_unicode_funcs_t;
}
extern "C" {
    pub fn hb_unicode_funcs_reference(ufuncs: *mut hb_unicode_funcs_t) -> *mut hb_unicode_funcs_t;
}
extern "C" {
    pub fn hb_unicode_funcs_destroy(ufuncs: *mut hb_unicode_funcs_t);
}
extern "C" {
    pub fn hb_unicode_funcs_set_user_data(
        ufuncs: *mut hb_unicode_funcs_t,
        key: *mut hb_user_data_key_t,
        data: *mut ::std::os::raw::c_void,
        destroy: hb_destroy_func_t,
        replace: hb_bool_t,
    ) -> hb_bool_t;
}
extern "C" {
    pub fn hb_unicode_funcs_get_user_data(
        ufuncs: *mut hb_unicode_funcs_t,
        key: *mut hb_user_data_key_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn hb_unicode_funcs_make_immutable(ufuncs: *mut hb_unicode_funcs_t);
}
extern "C" {
    pub fn hb_unicode_funcs_is_immutable(ufuncs: *mut hb_unicode_funcs_t) -> hb_bool_t;
}
extern "C" {
    pub fn hb_unicode_funcs_get_parent(ufuncs: *mut hb_unicode_funcs_t) -> *mut hb_unicode_funcs_t;
}
#[doc = " hb_unicode_combining_class_func_t:"]
#[doc = " @ufuncs: A Unicode-functions structure"]
#[doc = " @unicode: The code point to query"]
#[doc = " @user_data: User data pointer passed by the caller"]
#[doc = ""]
#[doc = " A virtual method for the #hb_unicode_funcs_t structure."]
#[doc = ""]
#[doc = " This method should retrieve the Canonical Combining Class (ccc)"]
#[doc = " property for a specified Unicode code point."]
#[doc = ""]
#[doc = " Return value: The #hb_unicode_combining_class_t of @unicode"]
#[doc = ""]
pub type hb_unicode_combining_class_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        ufuncs: *mut hb_unicode_funcs_t,
        unicode: hb_codepoint_t,
        user_data: *mut ::std::os::raw::c_void,
    ) -> hb_unicode_combining_class_t,
>;
#[doc = " hb_unicode_general_category_func_t:"]
#[doc = " @ufuncs: A Unicode-functions structure"]
#[doc = " @unicode: The code point to query"]
#[doc = " @user_data: User data pointer passed by the caller"]
#[doc = ""]
#[doc = " A virtual method for the #hb_unicode_funcs_t structure."]
#[doc = ""]
#[doc = " This method should retrieve the General Category property for"]
#[doc = " a specified Unicode code point."]
#[doc = ""]
#[doc = " Return value: The #hb_unicode_general_category_t of @unicode"]
#[doc = ""]
pub type hb_unicode_general_category_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        ufuncs: *mut hb_unicode_funcs_t,
        unicode: hb_codepoint_t,
        user_data: *mut ::std::os::raw::c_void,
    ) -> hb_unicode_general_category_t,
>;
#[doc = " hb_unicode_mirroring_func_t:"]
#[doc = " @ufuncs: A Unicode-functions structure"]
#[doc = " @unicode: The code point to query"]
#[doc = " @user_data: User data pointer passed by the caller"]
#[doc = ""]
#[doc = " A virtual method for the #hb_unicode_funcs_t structure."]
#[doc = ""]
#[doc = " This method should retrieve the Bi-Directional Mirroring Glyph"]
#[doc = " code point for a specified Unicode code point."]
#[doc = ""]
#[doc = " <note>Note: If a code point does not have a specified"]
#[doc = " Bi-Directional Mirroring Glyph defined, the method should"]
#[doc = " return the original code point.</note>"]
#[doc = ""]
#[doc = " Return value: The #hb_codepoint_t of the Mirroring Glyph for @unicode"]
#[doc = ""]
pub type hb_unicode_mirroring_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        ufuncs: *mut hb_unicode_funcs_t,
        unicode: hb_codepoint_t,
        user_data: *mut ::std::os::raw::c_void,
    ) -> hb_codepoint_t,
>;
#[doc = " hb_unicode_script_func_t:"]
#[doc = " @ufuncs: A Unicode-functions structure"]
#[doc = " @unicode: The code point to query"]
#[doc = " @user_data: User data pointer passed by the caller"]
#[doc = ""]
#[doc = " A virtual method for the #hb_unicode_funcs_t structure."]
#[doc = ""]
#[doc = " This method should retrieve the Script property for a"]
#[doc = " specified Unicode code point."]
#[doc = ""]
#[doc = " Return value: The #hb_script_t of @unicode"]
#[doc = ""]
pub type hb_unicode_script_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        ufuncs: *mut hb_unicode_funcs_t,
        unicode: hb_codepoint_t,
        user_data: *mut ::std::os::raw::c_void,
    ) -> hb_script_t,
>;
#[doc = " hb_unicode_compose_func_t:"]
#[doc = " @ufuncs: A Unicode-functions structure"]
#[doc = " @a: The first code point to compose"]
#[doc = " @b: The second code point to compose"]
#[doc = " @ab: (out): The composed code point"]
#[doc = " @user_data: user data pointer passed by the caller"]
#[doc = ""]
#[doc = " A virtual method for the #hb_unicode_funcs_t structure."]
#[doc = ""]
#[doc = " This method should compose a sequence of two input Unicode code"]
#[doc = " points by canonical equivalence, returning the composed code"]
#[doc = " point in a #hb_codepoint_t output parameter (if successful)."]
#[doc = " The method must return an #hb_bool_t indicating the success"]
#[doc = " of the composition."]
#[doc = ""]
#[doc = " Return value: %true is @a,@b composed, %false otherwise"]
#[doc = ""]
pub type hb_unicode_compose_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        ufuncs: *mut hb_unicode_funcs_t,
        a: hb_codepoint_t,
        b: hb_codepoint_t,
        ab: *mut hb_codepoint_t,
        user_data: *mut ::std::os::raw::c_void,
    ) -> hb_bool_t,
>;
#[doc = " hb_unicode_decompose_func_t:"]
#[doc = " @ufuncs: A Unicode-functions structure"]
#[doc = " @ab: The code point to decompose"]
#[doc = " @a: (out): The first decomposed code point"]
#[doc = " @b: (out): The second decomposed code point"]
#[doc = " @user_data: user data pointer passed by the caller"]
#[doc = ""]
#[doc = " A virtual method for the #hb_unicode_funcs_t structure."]
#[doc = ""]
#[doc = " This method should decompose an input Unicode code point,"]
#[doc = " returning the two decomposed code points in #hb_codepoint_t"]
#[doc = " output parameters (if successful). The method must return an"]
#[doc = " #hb_bool_t indicating the success of the composition."]
#[doc = ""]
#[doc = " Return value: %true if @ab decomposed, %false otherwise"]
#[doc = ""]
pub type hb_unicode_decompose_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        ufuncs: *mut hb_unicode_funcs_t,
        ab: hb_codepoint_t,
        a: *mut hb_codepoint_t,
        b: *mut hb_codepoint_t,
        user_data: *mut ::std::os::raw::c_void,
    ) -> hb_bool_t,
>;
extern "C" {
    #[doc = " hb_unicode_funcs_set_combining_class_func:"]
    #[doc = " @ufuncs: A Unicode-functions structure"]
    #[doc = " @func: (closure user_data) (destroy destroy) (scope notified): The callback function to assign"]
    #[doc = " @user_data: Data to pass to @func"]
    #[doc = " @destroy: (nullable): The function to call when @user_data is not needed anymore"]
    #[doc = ""]
    #[doc = " Sets the implementation function for #hb_unicode_combining_class_func_t."]
    #[doc = ""]
    #[doc = " Since: 0.9.2"]
    pub fn hb_unicode_funcs_set_combining_class_func(
        ufuncs: *mut hb_unicode_funcs_t,
        func: hb_unicode_combining_class_func_t,
        user_data: *mut ::std::os::raw::c_void,
        destroy: hb_destroy_func_t,
    );
}
extern "C" {
    #[doc = " hb_unicode_funcs_set_general_category_func:"]
    #[doc = " @ufuncs: A Unicode-functions structure"]
    #[doc = " @func: (closure user_data) (destroy destroy) (scope notified): The callback function to assign"]
    #[doc = " @user_data: Data to pass to @func"]
    #[doc = " @destroy: (nullable): The function to call when @user_data is not needed anymore"]
    #[doc = ""]
    #[doc = " Sets the implementation function for #hb_unicode_general_category_func_t."]
    #[doc = ""]
    #[doc = " Since: 0.9.2"]
    pub fn hb_unicode_funcs_set_general_category_func(
        ufuncs: *mut hb_unicode_funcs_t,
        func: hb_unicode_general_category_func_t,
        user_data: *mut ::std::os::raw::c_void,
        destroy: hb_destroy_func_t,
    );
}
extern "C" {
    #[doc = " hb_unicode_funcs_set_mirroring_func:"]
    #[doc = " @ufuncs: A Unicode-functions structure"]
    #[doc = " @func: (closure user_data) (destroy destroy) (scope notified): The callback function to assign"]
    #[doc = " @user_data: Data to pass to @func"]
    #[doc = " @destroy: (nullable): The function to call when @user_data is not needed anymore"]
    #[doc = ""]
    #[doc = " Sets the implementation function for #hb_unicode_mirroring_func_t."]
    #[doc = ""]
    #[doc = " Since: 0.9.2"]
    pub fn hb_unicode_funcs_set_mirroring_func(
        ufuncs: *mut hb_unicode_funcs_t,
        func: hb_unicode_mirroring_func_t,
        user_data: *mut ::std::os::raw::c_void,
        destroy: hb_destroy_func_t,
    );
}
extern "C" {
    #[doc = " hb_unicode_funcs_set_script_func:"]
    #[doc = " @ufuncs: A Unicode-functions structure"]
    #[doc = " @func: (closure user_data) (destroy destroy) (scope notified): The callback function to assign"]
    #[doc = " @user_data: Data to pass to @func"]
    #[doc = " @destroy: (nullable): The function to call when @user_data is not needed anymore"]
    #[doc = ""]
    #[doc = " Sets the implementation function for #hb_unicode_script_func_t."]
    #[doc = ""]
    #[doc = " Since: 0.9.2"]
    pub fn hb_unicode_funcs_set_script_func(
        ufuncs: *mut hb_unicode_funcs_t,
        func: hb_unicode_script_func_t,
        user_data: *mut ::std::os::raw::c_void,
        destroy: hb_destroy_func_t,
    );
}
extern "C" {
    #[doc = " hb_unicode_funcs_set_compose_func:"]
    #[doc = " @ufuncs: A Unicode-functions structure"]
    #[doc = " @func: (closure user_data) (destroy destroy) (scope notified): The callback function to assign"]
    #[doc = " @user_data: Data to pass to @func"]
    #[doc = " @destroy: (nullable): The function to call when @user_data is not needed anymore"]
    #[doc = ""]
    #[doc = " Sets the implementation function for #hb_unicode_compose_func_t."]
    #[doc = ""]
    #[doc = " Since: 0.9.2"]
    pub fn hb_unicode_funcs_set_compose_func(
        ufuncs: *mut hb_unicode_funcs_t,
        func: hb_unicode_compose_func_t,
        user_data: *mut ::std::os::raw::c_void,
        destroy: hb_destroy_func_t,
    );
}
extern "C" {
    #[doc = " hb_unicode_funcs_set_decompose_func:"]
    #[doc = " @ufuncs: A Unicode-functions structure"]
    #[doc = " @func: (closure user_data) (destroy destroy) (scope notified): The callback function to assign"]
    #[doc = " @user_data: Data to pass to @func"]
    #[doc = " @destroy: (nullable): The function to call when @user_data is not needed anymore"]
    #[doc = ""]
    #[doc = " Sets the implementation function for #hb_unicode_decompose_func_t."]
    #[doc = ""]
    #[doc = " Since: 0.9.2"]
    pub fn hb_unicode_funcs_set_decompose_func(
        ufuncs: *mut hb_unicode_funcs_t,
        func: hb_unicode_decompose_func_t,
        user_data: *mut ::std::os::raw::c_void,
        destroy: hb_destroy_func_t,
    );
}
extern "C" {
    #[doc = " hb_unicode_combining_class:"]
    #[doc = " @ufuncs: The Unicode-functions structure"]
    #[doc = " @unicode: The code point to query"]
    #[doc = ""]
    #[doc = " Retrieves the Canonical Combining Class (ccc) property"]
    #[doc = " of code point @unicode."]
    #[doc = ""]
    #[doc = " Return value: The #hb_unicode_combining_class_t of @unicode"]
    #[doc = ""]
    #[doc = " Since: 0.9.2"]
    pub fn hb_unicode_combining_class(
        ufuncs: *mut hb_unicode_funcs_t,
        unicode: hb_codepoint_t,
    ) -> hb_unicode_combining_class_t;
}
extern "C" {
    #[doc = " hb_unicode_general_category:"]
    #[doc = " @ufuncs: The Unicode-functions structure"]
    #[doc = " @unicode: The code point to query"]
    #[doc = ""]
    #[doc = " Retrieves the General Category (gc) property"]
    #[doc = " of code point @unicode."]
    #[doc = ""]
    #[doc = " Return value: The #hb_unicode_general_category_t of @unicode"]
    #[doc = ""]
    #[doc = " Since: 0.9.2"]
    pub fn hb_unicode_general_category(
        ufuncs: *mut hb_unicode_funcs_t,
        unicode: hb_codepoint_t,
    ) -> hb_unicode_general_category_t;
}
extern "C" {
    #[doc = " hb_unicode_mirroring:"]
    #[doc = " @ufuncs: The Unicode-functions structure"]
    #[doc = " @unicode: The code point to query"]
    #[doc = ""]
    #[doc = " Retrieves the Bi-directional Mirroring Glyph code"]
    #[doc = " point defined for code point @unicode."]
    #[doc = ""]
    #[doc = " Return value: The #hb_codepoint_t of the Mirroring Glyph for @unicode"]
    #[doc = ""]
    #[doc = " Since: 0.9.2"]
    pub fn hb_unicode_mirroring(
        ufuncs: *mut hb_unicode_funcs_t,
        unicode: hb_codepoint_t,
    ) -> hb_codepoint_t;
}
extern "C" {
    #[doc = " hb_unicode_script:"]
    #[doc = " @ufuncs: The Unicode-functions structure"]
    #[doc = " @unicode: The code point to query"]
    #[doc = ""]
    #[doc = " Retrieves the #hb_script_t script to which code"]
    #[doc = " point @unicode belongs."]
    #[doc = ""]
    #[doc = " Return value: The #hb_script_t of @unicode"]
    #[doc = ""]
    #[doc = " Since: 0.9.2"]
    pub fn hb_unicode_script(
        ufuncs: *mut hb_unicode_funcs_t,
        unicode: hb_codepoint_t,
    ) -> hb_script_t;
}
extern "C" {
    pub fn hb_unicode_compose(
        ufuncs: *mut hb_unicode_funcs_t,
        a: hb_codepoint_t,
        b: hb_codepoint_t,
        ab: *mut hb_codepoint_t,
    ) -> hb_bool_t;
}
extern "C" {
    pub fn hb_unicode_decompose(
        ufuncs: *mut hb_unicode_funcs_t,
        ab: hb_codepoint_t,
        a: *mut hb_codepoint_t,
        b: *mut hb_codepoint_t,
    ) -> hb_bool_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hb_set_t {
    _unused: [u8; 0],
}
extern "C" {
    pub fn hb_set_create() -> *mut hb_set_t;
}
extern "C" {
    pub fn hb_set_get_empty() -> *mut hb_set_t;
}
extern "C" {
    pub fn hb_set_reference(set: *mut hb_set_t) -> *mut hb_set_t;
}
extern "C" {
    pub fn hb_set_destroy(set: *mut hb_set_t);
}
extern "C" {
    pub fn hb_set_set_user_data(
        set: *mut hb_set_t,
        key: *mut hb_user_data_key_t,
        data: *mut ::std::os::raw::c_void,
        destroy: hb_destroy_func_t,
        replace: hb_bool_t,
    ) -> hb_bool_t;
}
extern "C" {
    pub fn hb_set_get_user_data(
        set: *mut hb_set_t,
        key: *mut hb_user_data_key_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn hb_set_allocation_successful(set: *const hb_set_t) -> hb_bool_t;
}
extern "C" {
    pub fn hb_set_copy(set: *const hb_set_t) -> *mut hb_set_t;
}
extern "C" {
    pub fn hb_set_clear(set: *mut hb_set_t);
}
extern "C" {
    pub fn hb_set_is_empty(set: *const hb_set_t) -> hb_bool_t;
}
extern "C" {
    pub fn hb_set_invert(set: *mut hb_set_t);
}
extern "C" {
    pub fn hb_set_has(set: *const hb_set_t, codepoint: hb_codepoint_t) -> hb_bool_t;
}
extern "C" {
    pub fn hb_set_add(set: *mut hb_set_t, codepoint: hb_codepoint_t);
}
extern "C" {
    pub fn hb_set_add_range(set: *mut hb_set_t, first: hb_codepoint_t, last: hb_codepoint_t);
}
extern "C" {
    pub fn hb_set_add_sorted_array(
        set: *mut hb_set_t,
        sorted_codepoints: *const hb_codepoint_t,
        num_codepoints: ::std::os::raw::c_uint,
    );
}
extern "C" {
    pub fn hb_set_del(set: *mut hb_set_t, codepoint: hb_codepoint_t);
}
extern "C" {
    pub fn hb_set_del_range(set: *mut hb_set_t, first: hb_codepoint_t, last: hb_codepoint_t);
}
extern "C" {
    pub fn hb_set_is_equal(set: *const hb_set_t, other: *const hb_set_t) -> hb_bool_t;
}
extern "C" {
    pub fn hb_set_is_subset(set: *const hb_set_t, larger_set: *const hb_set_t) -> hb_bool_t;
}
extern "C" {
    pub fn hb_set_set(set: *mut hb_set_t, other: *const hb_set_t);
}
extern "C" {
    pub fn hb_set_union(set: *mut hb_set_t, other: *const hb_set_t);
}
extern "C" {
    pub fn hb_set_intersect(set: *mut hb_set_t, other: *const hb_set_t);
}
extern "C" {
    pub fn hb_set_subtract(set: *mut hb_set_t, other: *const hb_set_t);
}
extern "C" {
    pub fn hb_set_symmetric_difference(set: *mut hb_set_t, other: *const hb_set_t);
}
extern "C" {
    pub fn hb_set_get_population(set: *const hb_set_t) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn hb_set_get_min(set: *const hb_set_t) -> hb_codepoint_t;
}
extern "C" {
    pub fn hb_set_get_max(set: *const hb_set_t) -> hb_codepoint_t;
}
extern "C" {
    pub fn hb_set_next(set: *const hb_set_t, codepoint: *mut hb_codepoint_t) -> hb_bool_t;
}
extern "C" {
    pub fn hb_set_previous(set: *const hb_set_t, codepoint: *mut hb_codepoint_t) -> hb_bool_t;
}
extern "C" {
    pub fn hb_set_next_range(
        set: *const hb_set_t,
        first: *mut hb_codepoint_t,
        last: *mut hb_codepoint_t,
    ) -> hb_bool_t;
}
extern "C" {
    pub fn hb_set_previous_range(
        set: *const hb_set_t,
        first: *mut hb_codepoint_t,
        last: *mut hb_codepoint_t,
    ) -> hb_bool_t;
}
extern "C" {
    pub fn hb_set_next_many(
        set: *const hb_set_t,
        codepoint: hb_codepoint_t,
        out: *mut hb_codepoint_t,
        size: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn hb_face_count(blob: *mut hb_blob_t) -> ::std::os::raw::c_uint;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hb_face_t {
    _unused: [u8; 0],
}
extern "C" {
    pub fn hb_face_create(blob: *mut hb_blob_t, index: ::std::os::raw::c_uint) -> *mut hb_face_t;
}
#[doc = " hb_reference_table_func_t:"]
#[doc = " @face: an #hb_face_t to reference table for"]
#[doc = " @tag: the tag of the table to reference"]
#[doc = " @user_data: User data pointer passed by the caller"]
#[doc = ""]
#[doc = " Callback function for hb_face_create_for_tables()."]
#[doc = ""]
#[doc = " Return value: (transfer full): A pointer to the @tag table within @face"]
#[doc = ""]
#[doc = " Since: 0.9.2"]
pub type hb_reference_table_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        face: *mut hb_face_t,
        tag: hb_tag_t,
        user_data: *mut ::std::os::raw::c_void,
    ) -> *mut hb_blob_t,
>;
extern "C" {
    pub fn hb_face_create_for_tables(
        reference_table_func: hb_reference_table_func_t,
        user_data: *mut ::std::os::raw::c_void,
        destroy: hb_destroy_func_t,
    ) -> *mut hb_face_t;
}
extern "C" {
    pub fn hb_face_get_empty() -> *mut hb_face_t;
}
extern "C" {
    pub fn hb_face_reference(face: *mut hb_face_t) -> *mut hb_face_t;
}
extern "C" {
    pub fn hb_face_destroy(face: *mut hb_face_t);
}
extern "C" {
    pub fn hb_face_set_user_data(
        face: *mut hb_face_t,
        key: *mut hb_user_data_key_t,
        data: *mut ::std::os::raw::c_void,
        destroy: hb_destroy_func_t,
        replace: hb_bool_t,
    ) -> hb_bool_t;
}
extern "C" {
    pub fn hb_face_get_user_data(
        face: *const hb_face_t,
        key: *mut hb_user_data_key_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn hb_face_make_immutable(face: *mut hb_face_t);
}
extern "C" {
    pub fn hb_face_is_immutable(face: *const hb_face_t) -> hb_bool_t;
}
extern "C" {
    pub fn hb_face_reference_table(face: *const hb_face_t, tag: hb_tag_t) -> *mut hb_blob_t;
}
extern "C" {
    pub fn hb_face_reference_blob(face: *mut hb_face_t) -> *mut hb_blob_t;
}
extern "C" {
    pub fn hb_face_set_index(face: *mut hb_face_t, index: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn hb_face_get_index(face: *const hb_face_t) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn hb_face_set_upem(face: *mut hb_face_t, upem: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn hb_face_get_upem(face: *const hb_face_t) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn hb_face_set_glyph_count(face: *mut hb_face_t, glyph_count: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn hb_face_get_glyph_count(face: *const hb_face_t) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn hb_face_get_table_tags(
        face: *const hb_face_t,
        start_offset: ::std::os::raw::c_uint,
        table_count: *mut ::std::os::raw::c_uint,
        table_tags: *mut hb_tag_t,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn hb_face_collect_unicodes(face: *mut hb_face_t, out: *mut hb_set_t);
}
extern "C" {
    pub fn hb_face_collect_variation_selectors(face: *mut hb_face_t, out: *mut hb_set_t);
}
extern "C" {
    pub fn hb_face_collect_variation_unicodes(
        face: *mut hb_face_t,
        variation_selector: hb_codepoint_t,
        out: *mut hb_set_t,
    );
}
extern "C" {
    pub fn hb_face_builder_create() -> *mut hb_face_t;
}
extern "C" {
    pub fn hb_face_builder_add_table(
        face: *mut hb_face_t,
        tag: hb_tag_t,
        blob: *mut hb_blob_t,
    ) -> hb_bool_t;
}
#[doc = " hb_draw_state_t"]
#[doc = " @path_open: Whether there is an open path"]
#[doc = " @path_start_x: X component of the start of current path"]
#[doc = " @path_start_y: Y component of the start of current path"]
#[doc = " @current_x: X component of current point"]
#[doc = " @current_y: Y component of current point"]
#[doc = ""]
#[doc = " Current drawing state."]
#[doc = ""]
#[doc = " Since: 4.0.0"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct hb_draw_state_t {
    pub path_open: hb_bool_t,
    pub path_start_x: ::std::os::raw::c_float,
    pub path_start_y: ::std::os::raw::c_float,
    pub current_x: ::std::os::raw::c_float,
    pub current_y: ::std::os::raw::c_float,
    pub reserved1: hb_var_num_t,
    pub reserved2: hb_var_num_t,
    pub reserved3: hb_var_num_t,
    pub reserved4: hb_var_num_t,
    pub reserved5: hb_var_num_t,
    pub reserved6: hb_var_num_t,
    pub reserved7: hb_var_num_t,
}
#[test]
fn bindgen_test_layout_hb_draw_state_t() {
    assert_eq!(
        ::std::mem::size_of::<hb_draw_state_t>(),
        48usize,
        concat!("Size of: ", stringify!(hb_draw_state_t))
    );
    assert_eq!(
        ::std::mem::align_of::<hb_draw_state_t>(),
        4usize,
        concat!("Alignment of ", stringify!(hb_draw_state_t))
    );
    fn test_field_path_open() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<hb_draw_state_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).path_open) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(hb_draw_state_t),
                "::",
                stringify!(path_open)
            )
        );
    }
    test_field_path_open();
    fn test_field_path_start_x() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<hb_draw_state_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).path_start_x) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(hb_draw_state_t),
                "::",
                stringify!(path_start_x)
            )
        );
    }
    test_field_path_start_x();
    fn test_field_path_start_y() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<hb_draw_state_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).path_start_y) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(hb_draw_state_t),
                "::",
                stringify!(path_start_y)
            )
        );
    }
    test_field_path_start_y();
    fn test_field_current_x() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<hb_draw_state_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).current_x) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(hb_draw_state_t),
                "::",
                stringify!(current_x)
            )
        );
    }
    test_field_current_x();
    fn test_field_current_y() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<hb_draw_state_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).current_y) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(hb_draw_state_t),
                "::",
                stringify!(current_y)
            )
        );
    }
    test_field_current_y();
    fn test_field_reserved1() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<hb_draw_state_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved1) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(hb_draw_state_t),
                "::",
                stringify!(reserved1)
            )
        );
    }
    test_field_reserved1();
    fn test_field_reserved2() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<hb_draw_state_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved2) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(hb_draw_state_t),
                "::",
                stringify!(reserved2)
            )
        );
    }
    test_field_reserved2();
    fn test_field_reserved3() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<hb_draw_state_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved3) as usize - ptr as usize
            },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(hb_draw_state_t),
                "::",
                stringify!(reserved3)
            )
        );
    }
    test_field_reserved3();
    fn test_field_reserved4() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<hb_draw_state_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved4) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(hb_draw_state_t),
                "::",
                stringify!(reserved4)
            )
        );
    }
    test_field_reserved4();
    fn test_field_reserved5() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<hb_draw_state_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved5) as usize - ptr as usize
            },
            36usize,
            concat!(
                "Offset of field: ",
                stringify!(hb_draw_state_t),
                "::",
                stringify!(reserved5)
            )
        );
    }
    test_field_reserved5();
    fn test_field_reserved6() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<hb_draw_state_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved6) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(hb_draw_state_t),
                "::",
                stringify!(reserved6)
            )
        );
    }
    test_field_reserved6();
    fn test_field_reserved7() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<hb_draw_state_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved7) as usize - ptr as usize
            },
            44usize,
            concat!(
                "Offset of field: ",
                stringify!(hb_draw_state_t),
                "::",
                stringify!(reserved7)
            )
        );
    }
    test_field_reserved7();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hb_draw_funcs_t {
    _unused: [u8; 0],
}
#[doc = " hb_draw_move_to_func_t:"]
#[doc = " @dfuncs: draw functions object"]
#[doc = " @draw_data: The data accompanying the draw functions"]
#[doc = " @st: current draw state"]
#[doc = " @to_x: X component of target point"]
#[doc = " @to_y: Y component of target point"]
#[doc = " @user_data: User data pointer passed by the caller"]
#[doc = ""]
#[doc = " A virtual method for the #hb_draw_funcs_t to perform a \"move-to\" draw"]
#[doc = " operation."]
#[doc = ""]
#[doc = " Since: 4.0.0"]
#[doc = ""]
pub type hb_draw_move_to_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        dfuncs: *mut hb_draw_funcs_t,
        draw_data: *mut ::std::os::raw::c_void,
        st: *mut hb_draw_state_t,
        to_x: ::std::os::raw::c_float,
        to_y: ::std::os::raw::c_float,
        user_data: *mut ::std::os::raw::c_void,
    ),
>;
#[doc = " hb_draw_line_to_func_t:"]
#[doc = " @dfuncs: draw functions object"]
#[doc = " @draw_data: The data accompanying the draw functions"]
#[doc = " @st: current draw state"]
#[doc = " @to_x: X component of target point"]
#[doc = " @to_y: Y component of target point"]
#[doc = " @user_data: User data pointer passed by the caller"]
#[doc = ""]
#[doc = " A virtual method for the #hb_draw_funcs_t to perform a \"line-to\" draw"]
#[doc = " operation."]
#[doc = ""]
#[doc = " Since: 4.0.0"]
#[doc = ""]
pub type hb_draw_line_to_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        dfuncs: *mut hb_draw_funcs_t,
        draw_data: *mut ::std::os::raw::c_void,
        st: *mut hb_draw_state_t,
        to_x: ::std::os::raw::c_float,
        to_y: ::std::os::raw::c_float,
        user_data: *mut ::std::os::raw::c_void,
    ),
>;
#[doc = " hb_draw_quadratic_to_func_t:"]
#[doc = " @dfuncs: draw functions object"]
#[doc = " @draw_data: The data accompanying the draw functions"]
#[doc = " @st: current draw state"]
#[doc = " @control_x: X component of control point"]
#[doc = " @control_y: Y component of control point"]
#[doc = " @to_x: X component of target point"]
#[doc = " @to_y: Y component of target point"]
#[doc = " @user_data: User data pointer passed by the caller"]
#[doc = ""]
#[doc = " A virtual method for the #hb_draw_funcs_t to perform a \"quadratic-to\" draw"]
#[doc = " operation."]
#[doc = ""]
#[doc = " Since: 4.0.0"]
#[doc = ""]
pub type hb_draw_quadratic_to_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        dfuncs: *mut hb_draw_funcs_t,
        draw_data: *mut ::std::os::raw::c_void,
        st: *mut hb_draw_state_t,
        control_x: ::std::os::raw::c_float,
        control_y: ::std::os::raw::c_float,
        to_x: ::std::os::raw::c_float,
        to_y: ::std::os::raw::c_float,
        user_data: *mut ::std::os::raw::c_void,
    ),
>;
#[doc = " hb_draw_cubic_to_func_t:"]
#[doc = " @dfuncs: draw functions object"]
#[doc = " @draw_data: The data accompanying the draw functions"]
#[doc = " @st: current draw state"]
#[doc = " @control1_x: X component of first control point"]
#[doc = " @control1_y: Y component of first control point"]
#[doc = " @control2_x: X component of second control point"]
#[doc = " @control2_y: Y component of second control point"]
#[doc = " @to_x: X component of target point"]
#[doc = " @to_y: Y component of target point"]
#[doc = " @user_data: User data pointer passed by the caller"]
#[doc = ""]
#[doc = " A virtual method for the #hb_draw_funcs_t to perform a \"cubic-to\" draw"]
#[doc = " operation."]
#[doc = ""]
#[doc = " Since: 4.0.0"]
#[doc = ""]
pub type hb_draw_cubic_to_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        dfuncs: *mut hb_draw_funcs_t,
        draw_data: *mut ::std::os::raw::c_void,
        st: *mut hb_draw_state_t,
        control1_x: ::std::os::raw::c_float,
        control1_y: ::std::os::raw::c_float,
        control2_x: ::std::os::raw::c_float,
        control2_y: ::std::os::raw::c_float,
        to_x: ::std::os::raw::c_float,
        to_y: ::std::os::raw::c_float,
        user_data: *mut ::std::os::raw::c_void,
    ),
>;
#[doc = " hb_draw_close_path_func_t:"]
#[doc = " @dfuncs: draw functions object"]
#[doc = " @draw_data: The data accompanying the draw functions"]
#[doc = " @st: current draw state"]
#[doc = " @user_data: User data pointer passed by the caller"]
#[doc = ""]
#[doc = " A virtual method for the #hb_draw_funcs_t to perform a \"close-path\" draw"]
#[doc = " operation."]
#[doc = ""]
#[doc = " Since: 4.0.0"]
#[doc = ""]
pub type hb_draw_close_path_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        dfuncs: *mut hb_draw_funcs_t,
        draw_data: *mut ::std::os::raw::c_void,
        st: *mut hb_draw_state_t,
        user_data: *mut ::std::os::raw::c_void,
    ),
>;
extern "C" {
    #[doc = " hb_draw_funcs_set_move_to_func:"]
    #[doc = " @dfuncs: draw functions object"]
    #[doc = " @func: (closure user_data) (destroy destroy) (scope notified): move-to callback"]
    #[doc = " @user_data: Data to pass to @func"]
    #[doc = " @destroy: (nullable): The function to call when @user_data is not needed anymore"]
    #[doc = ""]
    #[doc = " Sets move-to callback to the draw functions object."]
    #[doc = ""]
    #[doc = " Since: 4.0.0"]
    pub fn hb_draw_funcs_set_move_to_func(
        dfuncs: *mut hb_draw_funcs_t,
        func: hb_draw_move_to_func_t,
        user_data: *mut ::std::os::raw::c_void,
        destroy: hb_destroy_func_t,
    );
}
extern "C" {
    #[doc = " hb_draw_funcs_set_line_to_func:"]
    #[doc = " @dfuncs: draw functions object"]
    #[doc = " @func: (closure user_data) (destroy destroy) (scope notified): line-to callback"]
    #[doc = " @user_data: Data to pass to @func"]
    #[doc = " @destroy: (nullable): The function to call when @user_data is not needed anymore"]
    #[doc = ""]
    #[doc = " Sets line-to callback to the draw functions object."]
    #[doc = ""]
    #[doc = " Since: 4.0.0"]
    pub fn hb_draw_funcs_set_line_to_func(
        dfuncs: *mut hb_draw_funcs_t,
        func: hb_draw_line_to_func_t,
        user_data: *mut ::std::os::raw::c_void,
        destroy: hb_destroy_func_t,
    );
}
extern "C" {
    #[doc = " hb_draw_funcs_set_quadratic_to_func:"]
    #[doc = " @dfuncs: draw functions object"]
    #[doc = " @func: (closure user_data) (destroy destroy) (scope notified): quadratic-to callback"]
    #[doc = " @user_data: Data to pass to @func"]
    #[doc = " @destroy: (nullable): The function to call when @user_data is not needed anymore"]
    #[doc = ""]
    #[doc = " Sets quadratic-to callback to the draw functions object."]
    #[doc = ""]
    #[doc = " Since: 4.0.0"]
    pub fn hb_draw_funcs_set_quadratic_to_func(
        dfuncs: *mut hb_draw_funcs_t,
        func: hb_draw_quadratic_to_func_t,
        user_data: *mut ::std::os::raw::c_void,
        destroy: hb_destroy_func_t,
    );
}
extern "C" {
    #[doc = " hb_draw_funcs_set_cubic_to_func:"]
    #[doc = " @dfuncs: draw functions"]
    #[doc = " @func: (closure user_data) (destroy destroy) (scope notified): cubic-to callback"]
    #[doc = " @user_data: Data to pass to @func"]
    #[doc = " @destroy: (nullable): The function to call when @user_data is not needed anymore"]
    #[doc = ""]
    #[doc = " Sets cubic-to callback to the draw functions object."]
    #[doc = ""]
    #[doc = " Since: 4.0.0"]
    pub fn hb_draw_funcs_set_cubic_to_func(
        dfuncs: *mut hb_draw_funcs_t,
        func: hb_draw_cubic_to_func_t,
        user_data: *mut ::std::os::raw::c_void,
        destroy: hb_destroy_func_t,
    );
}
extern "C" {
    #[doc = " hb_draw_funcs_set_close_path_func:"]
    #[doc = " @dfuncs: draw functions object"]
    #[doc = " @func: (closure user_data) (destroy destroy) (scope notified): close-path callback"]
    #[doc = " @user_data: Data to pass to @func"]
    #[doc = " @destroy: (nullable): The function to call when @user_data is not needed anymore"]
    #[doc = ""]
    #[doc = " Sets close-path callback to the draw functions object."]
    #[doc = ""]
    #[doc = " Since: 4.0.0"]
    pub fn hb_draw_funcs_set_close_path_func(
        dfuncs: *mut hb_draw_funcs_t,
        func: hb_draw_close_path_func_t,
        user_data: *mut ::std::os::raw::c_void,
        destroy: hb_destroy_func_t,
    );
}
extern "C" {
    pub fn hb_draw_funcs_create() -> *mut hb_draw_funcs_t;
}
extern "C" {
    pub fn hb_draw_funcs_reference(dfuncs: *mut hb_draw_funcs_t) -> *mut hb_draw_funcs_t;
}
extern "C" {
    pub fn hb_draw_funcs_destroy(dfuncs: *mut hb_draw_funcs_t);
}
extern "C" {
    pub fn hb_draw_funcs_make_immutable(dfuncs: *mut hb_draw_funcs_t);
}
extern "C" {
    pub fn hb_draw_funcs_is_immutable(dfuncs: *mut hb_draw_funcs_t) -> hb_bool_t;
}
extern "C" {
    pub fn hb_draw_move_to(
        dfuncs: *mut hb_draw_funcs_t,
        draw_data: *mut ::std::os::raw::c_void,
        st: *mut hb_draw_state_t,
        to_x: ::std::os::raw::c_float,
        to_y: ::std::os::raw::c_float,
    );
}
extern "C" {
    pub fn hb_draw_line_to(
        dfuncs: *mut hb_draw_funcs_t,
        draw_data: *mut ::std::os::raw::c_void,
        st: *mut hb_draw_state_t,
        to_x: ::std::os::raw::c_float,
        to_y: ::std::os::raw::c_float,
    );
}
extern "C" {
    pub fn hb_draw_quadratic_to(
        dfuncs: *mut hb_draw_funcs_t,
        draw_data: *mut ::std::os::raw::c_void,
        st: *mut hb_draw_state_t,
        control_x: ::std::os::raw::c_float,
        control_y: ::std::os::raw::c_float,
        to_x: ::std::os::raw::c_float,
        to_y: ::std::os::raw::c_float,
    );
}
extern "C" {
    pub fn hb_draw_cubic_to(
        dfuncs: *mut hb_draw_funcs_t,
        draw_data: *mut ::std::os::raw::c_void,
        st: *mut hb_draw_state_t,
        control1_x: ::std::os::raw::c_float,
        control1_y: ::std::os::raw::c_float,
        control2_x: ::std::os::raw::c_float,
        control2_y: ::std::os::raw::c_float,
        to_x: ::std::os::raw::c_float,
        to_y: ::std::os::raw::c_float,
    );
}
extern "C" {
    pub fn hb_draw_close_path(
        dfuncs: *mut hb_draw_funcs_t,
        draw_data: *mut ::std::os::raw::c_void,
        st: *mut hb_draw_state_t,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hb_font_t {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hb_font_funcs_t {
    _unused: [u8; 0],
}
extern "C" {
    pub fn hb_font_funcs_create() -> *mut hb_font_funcs_t;
}
extern "C" {
    pub fn hb_font_funcs_get_empty() -> *mut hb_font_funcs_t;
}
extern "C" {
    pub fn hb_font_funcs_reference(ffuncs: *mut hb_font_funcs_t) -> *mut hb_font_funcs_t;
}
extern "C" {
    pub fn hb_font_funcs_destroy(ffuncs: *mut hb_font_funcs_t);
}
extern "C" {
    pub fn hb_font_funcs_set_user_data(
        ffuncs: *mut hb_font_funcs_t,
        key: *mut hb_user_data_key_t,
        data: *mut ::std::os::raw::c_void,
        destroy: hb_destroy_func_t,
        replace: hb_bool_t,
    ) -> hb_bool_t;
}
extern "C" {
    pub fn hb_font_funcs_get_user_data(
        ffuncs: *mut hb_font_funcs_t,
        key: *mut hb_user_data_key_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn hb_font_funcs_make_immutable(ffuncs: *mut hb_font_funcs_t);
}
extern "C" {
    pub fn hb_font_funcs_is_immutable(ffuncs: *mut hb_font_funcs_t) -> hb_bool_t;
}
#[doc = " hb_font_extents_t:"]
#[doc = " @ascender: The height of typographic ascenders."]
#[doc = " @descender: The depth of typographic descenders."]
#[doc = " @line_gap: The suggested line-spacing gap."]
#[doc = ""]
#[doc = " Font-wide extent values, measured in font units."]
#[doc = ""]
#[doc = " Note that typically @ascender is positive and @descender"]
#[doc = " negative, in coordinate systems that grow up."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hb_font_extents_t {
    pub ascender: hb_position_t,
    pub descender: hb_position_t,
    pub line_gap: hb_position_t,
    pub reserved9: hb_position_t,
    pub reserved8: hb_position_t,
    pub reserved7: hb_position_t,
    pub reserved6: hb_position_t,
    pub reserved5: hb_position_t,
    pub reserved4: hb_position_t,
    pub reserved3: hb_position_t,
    pub reserved2: hb_position_t,
    pub reserved1: hb_position_t,
}
#[test]
fn bindgen_test_layout_hb_font_extents_t() {
    assert_eq!(
        ::std::mem::size_of::<hb_font_extents_t>(),
        48usize,
        concat!("Size of: ", stringify!(hb_font_extents_t))
    );
    assert_eq!(
        ::std::mem::align_of::<hb_font_extents_t>(),
        4usize,
        concat!("Alignment of ", stringify!(hb_font_extents_t))
    );
    fn test_field_ascender() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<hb_font_extents_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ascender) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(hb_font_extents_t),
                "::",
                stringify!(ascender)
            )
        );
    }
    test_field_ascender();
    fn test_field_descender() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<hb_font_extents_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).descender) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(hb_font_extents_t),
                "::",
                stringify!(descender)
            )
        );
    }
    test_field_descender();
    fn test_field_line_gap() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<hb_font_extents_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).line_gap) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(hb_font_extents_t),
                "::",
                stringify!(line_gap)
            )
        );
    }
    test_field_line_gap();
    fn test_field_reserved9() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<hb_font_extents_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved9) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(hb_font_extents_t),
                "::",
                stringify!(reserved9)
            )
        );
    }
    test_field_reserved9();
    fn test_field_reserved8() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<hb_font_extents_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved8) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(hb_font_extents_t),
                "::",
                stringify!(reserved8)
            )
        );
    }
    test_field_reserved8();
    fn test_field_reserved7() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<hb_font_extents_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved7) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(hb_font_extents_t),
                "::",
                stringify!(reserved7)
            )
        );
    }
    test_field_reserved7();
    fn test_field_reserved6() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<hb_font_extents_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved6) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(hb_font_extents_t),
                "::",
                stringify!(reserved6)
            )
        );
    }
    test_field_reserved6();
    fn test_field_reserved5() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<hb_font_extents_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved5) as usize - ptr as usize
            },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(hb_font_extents_t),
                "::",
                stringify!(reserved5)
            )
        );
    }
    test_field_reserved5();
    fn test_field_reserved4() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<hb_font_extents_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved4) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(hb_font_extents_t),
                "::",
                stringify!(reserved4)
            )
        );
    }
    test_field_reserved4();
    fn test_field_reserved3() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<hb_font_extents_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved3) as usize - ptr as usize
            },
            36usize,
            concat!(
                "Offset of field: ",
                stringify!(hb_font_extents_t),
                "::",
                stringify!(reserved3)
            )
        );
    }
    test_field_reserved3();
    fn test_field_reserved2() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<hb_font_extents_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved2) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(hb_font_extents_t),
                "::",
                stringify!(reserved2)
            )
        );
    }
    test_field_reserved2();
    fn test_field_reserved1() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<hb_font_extents_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved1) as usize - ptr as usize
            },
            44usize,
            concat!(
                "Offset of field: ",
                stringify!(hb_font_extents_t),
                "::",
                stringify!(reserved1)
            )
        );
    }
    test_field_reserved1();
}
#[doc = " hb_glyph_extents_t:"]
#[doc = " @x_bearing: Distance from the x-origin to the left extremum of the glyph."]
#[doc = " @y_bearing: Distance from the top extremum of the glyph to the y-origin."]
#[doc = " @width: Distance from the left extremum of the glyph to the right extremum."]
#[doc = " @height: Distance from the top extremum of the glyph to the bottom extremum."]
#[doc = ""]
#[doc = " Glyph extent values, measured in font units."]
#[doc = ""]
#[doc = " Note that @height is negative, in coordinate systems that grow up."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hb_glyph_extents_t {
    pub x_bearing: hb_position_t,
    pub y_bearing: hb_position_t,
    pub width: hb_position_t,
    pub height: hb_position_t,
}
#[test]
fn bindgen_test_layout_hb_glyph_extents_t() {
    assert_eq!(
        ::std::mem::size_of::<hb_glyph_extents_t>(),
        16usize,
        concat!("Size of: ", stringify!(hb_glyph_extents_t))
    );
    assert_eq!(
        ::std::mem::align_of::<hb_glyph_extents_t>(),
        4usize,
        concat!("Alignment of ", stringify!(hb_glyph_extents_t))
    );
    fn test_field_x_bearing() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<hb_glyph_extents_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).x_bearing) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(hb_glyph_extents_t),
                "::",
                stringify!(x_bearing)
            )
        );
    }
    test_field_x_bearing();
    fn test_field_y_bearing() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<hb_glyph_extents_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).y_bearing) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(hb_glyph_extents_t),
                "::",
                stringify!(y_bearing)
            )
        );
    }
    test_field_y_bearing();
    fn test_field_width() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<hb_glyph_extents_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).width) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(hb_glyph_extents_t),
                "::",
                stringify!(width)
            )
        );
    }
    test_field_width();
    fn test_field_height() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<hb_glyph_extents_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).height) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(hb_glyph_extents_t),
                "::",
                stringify!(height)
            )
        );
    }
    test_field_height();
}
#[doc = " hb_font_get_font_extents_func_t:"]
#[doc = " @font: #hb_font_t to work upon"]
#[doc = " @font_data: @font user data pointer"]
#[doc = " @extents: (out): The font extents retrieved"]
#[doc = " @user_data: User data pointer passed by the caller"]
#[doc = ""]
#[doc = " This method should retrieve the extents for a font."]
#[doc = ""]
pub type hb_font_get_font_extents_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        font: *mut hb_font_t,
        font_data: *mut ::std::os::raw::c_void,
        extents: *mut hb_font_extents_t,
        user_data: *mut ::std::os::raw::c_void,
    ) -> hb_bool_t,
>;
#[doc = " hb_font_get_font_h_extents_func_t:"]
#[doc = ""]
#[doc = " A virtual method for the #hb_font_funcs_t of an #hb_font_t object."]
#[doc = ""]
#[doc = " This method should retrieve the extents for a font, for horizontal-direction"]
#[doc = " text segments. Extents must be returned in an #hb_glyph_extents output"]
#[doc = " parameter."]
#[doc = ""]
pub type hb_font_get_font_h_extents_func_t = hb_font_get_font_extents_func_t;
#[doc = " hb_font_get_font_v_extents_func_t:"]
#[doc = ""]
#[doc = " A virtual method for the #hb_font_funcs_t of an #hb_font_t object."]
#[doc = ""]
#[doc = " This method should retrieve the extents for a font, for vertical-direction"]
#[doc = " text segments. Extents must be returned in an #hb_glyph_extents output"]
#[doc = " parameter."]
#[doc = ""]
pub type hb_font_get_font_v_extents_func_t = hb_font_get_font_extents_func_t;
#[doc = " hb_font_get_nominal_glyph_func_t:"]
#[doc = " @font: #hb_font_t to work upon"]
#[doc = " @font_data: @font user data pointer"]
#[doc = " @unicode: The Unicode code point to query"]
#[doc = " @glyph: (out): The glyph ID retrieved"]
#[doc = " @user_data: User data pointer passed by the caller"]
#[doc = ""]
#[doc = " A virtual method for the #hb_font_funcs_t of an #hb_font_t object."]
#[doc = ""]
#[doc = " This method should retrieve the nominal glyph ID for a specified Unicode code"]
#[doc = " point. Glyph IDs must be returned in a #hb_codepoint_t output parameter."]
#[doc = ""]
#[doc = " Return value: %true if data found, %false otherwise"]
#[doc = ""]
pub type hb_font_get_nominal_glyph_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        font: *mut hb_font_t,
        font_data: *mut ::std::os::raw::c_void,
        unicode: hb_codepoint_t,
        glyph: *mut hb_codepoint_t,
        user_data: *mut ::std::os::raw::c_void,
    ) -> hb_bool_t,
>;
#[doc = " hb_font_get_variation_glyph_func_t:"]
#[doc = " @font: #hb_font_t to work upon"]
#[doc = " @font_data: @font user data pointer"]
#[doc = " @unicode: The Unicode code point to query"]
#[doc = " @variation_selector: The  variation-selector code point to query"]
#[doc = " @glyph: (out): The glyph ID retrieved"]
#[doc = " @user_data: User data pointer passed by the caller"]
#[doc = ""]
#[doc = " A virtual method for the #hb_font_funcs_t of an #hb_font_t object."]
#[doc = ""]
#[doc = " This method should retrieve the glyph ID for a specified Unicode code point"]
#[doc = " followed by a specified Variation Selector code point. Glyph IDs must be"]
#[doc = " returned in a #hb_codepoint_t output parameter."]
#[doc = ""]
#[doc = " Return value: %true if data found, %false otherwise"]
#[doc = ""]
pub type hb_font_get_variation_glyph_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        font: *mut hb_font_t,
        font_data: *mut ::std::os::raw::c_void,
        unicode: hb_codepoint_t,
        variation_selector: hb_codepoint_t,
        glyph: *mut hb_codepoint_t,
        user_data: *mut ::std::os::raw::c_void,
    ) -> hb_bool_t,
>;
#[doc = " hb_font_get_nominal_glyphs_func_t:"]
#[doc = " @font: #hb_font_t to work upon"]
#[doc = " @font_data: @font user data pointer"]
#[doc = " @count: number of code points to query"]
#[doc = " @first_unicode: The first Unicode code point to query"]
#[doc = " @unicode_stride: The stride between successive code points"]
#[doc = " @first_glyph: (out): The first glyph ID retrieved"]
#[doc = " @glyph_stride: The stride between successive glyph IDs"]
#[doc = " @user_data: User data pointer passed by the caller"]
#[doc = ""]
#[doc = " A virtual method for the #hb_font_funcs_t of an #hb_font_t object."]
#[doc = ""]
#[doc = " This method should retrieve the nominal glyph IDs for a sequence of"]
#[doc = " Unicode code points. Glyph IDs must be returned in a #hb_codepoint_t"]
#[doc = " output parameter."]
#[doc = ""]
#[doc = " Return value: the number of code points processed"]
#[doc = ""]
pub type hb_font_get_nominal_glyphs_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        font: *mut hb_font_t,
        font_data: *mut ::std::os::raw::c_void,
        count: ::std::os::raw::c_uint,
        first_unicode: *const hb_codepoint_t,
        unicode_stride: ::std::os::raw::c_uint,
        first_glyph: *mut hb_codepoint_t,
        glyph_stride: ::std::os::raw::c_uint,
        user_data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_uint,
>;
#[doc = " hb_font_get_glyph_advance_func_t:"]
#[doc = " @font: #hb_font_t to work upon"]
#[doc = " @font_data: @font user data pointer"]
#[doc = " @glyph: The glyph ID to query"]
#[doc = " @user_data: User data pointer passed by the caller"]
#[doc = ""]
#[doc = " A virtual method for the #hb_font_funcs_t of an #hb_font_t object."]
#[doc = ""]
#[doc = " This method should retrieve the advance for a specified glyph. The"]
#[doc = " method must return an #hb_position_t."]
#[doc = ""]
#[doc = " Return value: The advance of @glyph within @font"]
#[doc = ""]
pub type hb_font_get_glyph_advance_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        font: *mut hb_font_t,
        font_data: *mut ::std::os::raw::c_void,
        glyph: hb_codepoint_t,
        user_data: *mut ::std::os::raw::c_void,
    ) -> hb_position_t,
>;
#[doc = " hb_font_get_glyph_h_advance_func_t:"]
#[doc = ""]
#[doc = " A virtual method for the #hb_font_funcs_t of an #hb_font_t object."]
#[doc = ""]
#[doc = " This method should retrieve the advance for a specified glyph, in"]
#[doc = " horizontal-direction text segments. Advances must be returned in"]
#[doc = " an #hb_position_t output parameter."]
#[doc = ""]
pub type hb_font_get_glyph_h_advance_func_t = hb_font_get_glyph_advance_func_t;
#[doc = " hb_font_get_glyph_v_advance_func_t:"]
#[doc = ""]
#[doc = " A virtual method for the #hb_font_funcs_t of an #hb_font_t object."]
#[doc = ""]
#[doc = " This method should retrieve the advance for a specified glyph, in"]
#[doc = " vertical-direction text segments. Advances must be returned in"]
#[doc = " an #hb_position_t output parameter."]
#[doc = ""]
pub type hb_font_get_glyph_v_advance_func_t = hb_font_get_glyph_advance_func_t;
#[doc = " hb_font_get_glyph_advances_func_t:"]
#[doc = " @font: #hb_font_t to work upon"]
#[doc = " @font_data: @font user data pointer"]
#[doc = " @count: The number of glyph IDs in the sequence queried"]
#[doc = " @first_glyph: The first glyph ID to query"]
#[doc = " @glyph_stride: The stride between successive glyph IDs"]
#[doc = " @first_advance: (out): The first advance retrieved"]
#[doc = " @advance_stride: The stride between successive advances"]
#[doc = " @user_data: User data pointer passed by the caller"]
#[doc = ""]
#[doc = " A virtual method for the #hb_font_funcs_t of an #hb_font_t object."]
#[doc = ""]
#[doc = " This method should retrieve the advances for a sequence of glyphs."]
#[doc = ""]
pub type hb_font_get_glyph_advances_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        font: *mut hb_font_t,
        font_data: *mut ::std::os::raw::c_void,
        count: ::std::os::raw::c_uint,
        first_glyph: *const hb_codepoint_t,
        glyph_stride: ::std::os::raw::c_uint,
        first_advance: *mut hb_position_t,
        advance_stride: ::std::os::raw::c_uint,
        user_data: *mut ::std::os::raw::c_void,
    ),
>;
#[doc = " hb_font_get_glyph_h_advances_func_t:"]
#[doc = ""]
#[doc = " A virtual method for the #hb_font_funcs_t of an #hb_font_t object."]
#[doc = ""]
#[doc = " This method should retrieve the advances for a sequence of glyphs, in"]
#[doc = " horizontal-direction text segments."]
#[doc = ""]
pub type hb_font_get_glyph_h_advances_func_t = hb_font_get_glyph_advances_func_t;
#[doc = " hb_font_get_glyph_v_advances_func_t:"]
#[doc = ""]
#[doc = " A virtual method for the #hb_font_funcs_t of an #hb_font_t object."]
#[doc = ""]
#[doc = " This method should retrieve the advances for a sequence of glyphs, in"]
#[doc = " vertical-direction text segments."]
#[doc = ""]
pub type hb_font_get_glyph_v_advances_func_t = hb_font_get_glyph_advances_func_t;
#[doc = " hb_font_get_glyph_origin_func_t:"]
#[doc = " @font: #hb_font_t to work upon"]
#[doc = " @font_data: @font user data pointer"]
#[doc = " @glyph: The glyph ID to query"]
#[doc = " @x: (out): The X coordinate of the origin"]
#[doc = " @y: (out): The Y coordinate of the origin"]
#[doc = " @user_data: User data pointer passed by the caller"]
#[doc = ""]
#[doc = " A virtual method for the #hb_font_funcs_t of an #hb_font_t object."]
#[doc = ""]
#[doc = " This method should retrieve the (X,Y) coordinates (in font units) of the"]
#[doc = " origin for a glyph. Each coordinate must be returned in an #hb_position_t"]
#[doc = " output parameter."]
#[doc = ""]
#[doc = " Return value: %true if data found, %false otherwise"]
#[doc = ""]
pub type hb_font_get_glyph_origin_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        font: *mut hb_font_t,
        font_data: *mut ::std::os::raw::c_void,
        glyph: hb_codepoint_t,
        x: *mut hb_position_t,
        y: *mut hb_position_t,
        user_data: *mut ::std::os::raw::c_void,
    ) -> hb_bool_t,
>;
#[doc = " hb_font_get_glyph_h_origin_func_t:"]
#[doc = ""]
#[doc = " A virtual method for the #hb_font_funcs_t of an #hb_font_t object."]
#[doc = ""]
#[doc = " This method should retrieve the (X,Y) coordinates (in font units) of the"]
#[doc = " origin for a glyph, for horizontal-direction text segments. Each"]
#[doc = " coordinate must be returned in an #hb_position_t output parameter."]
#[doc = ""]
pub type hb_font_get_glyph_h_origin_func_t = hb_font_get_glyph_origin_func_t;
#[doc = " hb_font_get_glyph_v_origin_func_t:"]
#[doc = ""]
#[doc = " A virtual method for the #hb_font_funcs_t of an #hb_font_t object."]
#[doc = ""]
#[doc = " This method should retrieve the (X,Y) coordinates (in font units) of the"]
#[doc = " origin for a glyph, for vertical-direction text segments. Each coordinate"]
#[doc = " must be returned in an #hb_position_t output parameter."]
#[doc = ""]
pub type hb_font_get_glyph_v_origin_func_t = hb_font_get_glyph_origin_func_t;
#[doc = " hb_font_get_glyph_kerning_func_t:"]
#[doc = " @font: #hb_font_t to work upon"]
#[doc = " @font_data: @font user data pointer"]
#[doc = " @first_glyph: The glyph ID of the first glyph in the glyph pair"]
#[doc = " @second_glyph: The glyph ID of the second glyph in the glyph pair"]
#[doc = " @user_data: User data pointer passed by the caller"]
#[doc = ""]
#[doc = " This method should retrieve the kerning-adjustment value for a glyph-pair in"]
#[doc = " the specified font, for horizontal text segments."]
#[doc = ""]
pub type hb_font_get_glyph_kerning_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        font: *mut hb_font_t,
        font_data: *mut ::std::os::raw::c_void,
        first_glyph: hb_codepoint_t,
        second_glyph: hb_codepoint_t,
        user_data: *mut ::std::os::raw::c_void,
    ) -> hb_position_t,
>;
#[doc = " hb_font_get_glyph_h_kerning_func_t:"]
#[doc = ""]
#[doc = " A virtual method for the #hb_font_funcs_t of an #hb_font_t object."]
#[doc = ""]
#[doc = " This method should retrieve the kerning-adjustment value for a glyph-pair in"]
#[doc = " the specified font, for horizontal text segments."]
#[doc = ""]
pub type hb_font_get_glyph_h_kerning_func_t = hb_font_get_glyph_kerning_func_t;
#[doc = " hb_font_get_glyph_extents_func_t:"]
#[doc = " @font: #hb_font_t to work upon"]
#[doc = " @font_data: @font user data pointer"]
#[doc = " @glyph: The glyph ID to query"]
#[doc = " @extents: (out): The #hb_glyph_extents_t retrieved"]
#[doc = " @user_data: User data pointer passed by the caller"]
#[doc = ""]
#[doc = " A virtual method for the #hb_font_funcs_t of an #hb_font_t object."]
#[doc = ""]
#[doc = " This method should retrieve the extents for a specified glyph. Extents must be"]
#[doc = " returned in an #hb_glyph_extents output parameter."]
#[doc = ""]
#[doc = " Return value: %true if data found, %false otherwise"]
#[doc = ""]
pub type hb_font_get_glyph_extents_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        font: *mut hb_font_t,
        font_data: *mut ::std::os::raw::c_void,
        glyph: hb_codepoint_t,
        extents: *mut hb_glyph_extents_t,
        user_data: *mut ::std::os::raw::c_void,
    ) -> hb_bool_t,
>;
#[doc = " hb_font_get_glyph_contour_point_func_t:"]
#[doc = " @font: #hb_font_t to work upon"]
#[doc = " @font_data: @font user data pointer"]
#[doc = " @glyph: The glyph ID to query"]
#[doc = " @point_index: The contour-point index to query"]
#[doc = " @x: (out): The X value retrieved for the contour point"]
#[doc = " @y: (out): The Y value retrieved for the contour point"]
#[doc = " @user_data: User data pointer passed by the caller"]
#[doc = ""]
#[doc = " A virtual method for the #hb_font_funcs_t of an #hb_font_t object."]
#[doc = ""]
#[doc = " This method should retrieve the (X,Y) coordinates (in font units) for a"]
#[doc = " specified contour point in a glyph. Each coordinate must be returned as"]
#[doc = " an #hb_position_t output parameter."]
#[doc = ""]
#[doc = " Return value: %true if data found, %false otherwise"]
#[doc = ""]
pub type hb_font_get_glyph_contour_point_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        font: *mut hb_font_t,
        font_data: *mut ::std::os::raw::c_void,
        glyph: hb_codepoint_t,
        point_index: ::std::os::raw::c_uint,
        x: *mut hb_position_t,
        y: *mut hb_position_t,
        user_data: *mut ::std::os::raw::c_void,
    ) -> hb_bool_t,
>;
#[doc = " hb_font_get_glyph_name_func_t:"]
#[doc = " @font: #hb_font_t to work upon"]
#[doc = " @font_data: @font user data pointer"]
#[doc = " @glyph: The glyph ID to query"]
#[doc = " @name: (out) (array length=size): Name string retrieved for the glyph ID"]
#[doc = " @size: Length of the glyph-name string retrieved"]
#[doc = " @user_data: User data pointer passed by the caller"]
#[doc = ""]
#[doc = " A virtual method for the #hb_font_funcs_t of an #hb_font_t object."]
#[doc = ""]
#[doc = " This method should retrieve the glyph name that corresponds to a"]
#[doc = " glyph ID. The name should be returned in a string output parameter."]
#[doc = ""]
#[doc = " Return value: %true if data found, %false otherwise"]
#[doc = ""]
pub type hb_font_get_glyph_name_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        font: *mut hb_font_t,
        font_data: *mut ::std::os::raw::c_void,
        glyph: hb_codepoint_t,
        name: *mut ::std::os::raw::c_char,
        size: ::std::os::raw::c_uint,
        user_data: *mut ::std::os::raw::c_void,
    ) -> hb_bool_t,
>;
#[doc = " hb_font_get_glyph_from_name_func_t:"]
#[doc = " @font: #hb_font_t to work upon"]
#[doc = " @font_data: @font user data pointer"]
#[doc = " @name: (array length=len): The name string to query"]
#[doc = " @len: The length of the name queried"]
#[doc = " @glyph: (out): The glyph ID retrieved"]
#[doc = " @user_data: User data pointer passed by the caller"]
#[doc = ""]
#[doc = " A virtual method for the #hb_font_funcs_t of an #hb_font_t object."]
#[doc = ""]
#[doc = " This method should retrieve the glyph ID that corresponds to a glyph-name"]
#[doc = " string."]
#[doc = ""]
#[doc = " Return value: %true if data found, %false otherwise"]
#[doc = ""]
pub type hb_font_get_glyph_from_name_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        font: *mut hb_font_t,
        font_data: *mut ::std::os::raw::c_void,
        name: *const ::std::os::raw::c_char,
        len: ::std::os::raw::c_int,
        glyph: *mut hb_codepoint_t,
        user_data: *mut ::std::os::raw::c_void,
    ) -> hb_bool_t,
>;
#[doc = " hb_font_get_glyph_shape_func_t:"]
#[doc = " @font: #hb_font_t to work upon"]
#[doc = " @font_data: @font user data pointer"]
#[doc = " @glyph: The glyph ID to query"]
#[doc = " @draw_funcs: The draw functions to send the shape data to"]
#[doc = " @draw_data: The data accompanying the draw functions"]
#[doc = " @user_data: User data pointer passed by the caller"]
#[doc = ""]
#[doc = " A virtual method for the #hb_font_funcs_t of an #hb_font_t object."]
#[doc = ""]
#[doc = " Since: 4.0.0"]
#[doc = ""]
pub type hb_font_get_glyph_shape_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        font: *mut hb_font_t,
        font_data: *mut ::std::os::raw::c_void,
        glyph: hb_codepoint_t,
        draw_funcs: *mut hb_draw_funcs_t,
        draw_data: *mut ::std::os::raw::c_void,
        user_data: *mut ::std::os::raw::c_void,
    ),
>;
extern "C" {
    #[doc = " hb_font_funcs_set_font_h_extents_func:"]
    #[doc = " @ffuncs: A font-function structure"]
    #[doc = " @func: (closure user_data) (destroy destroy) (scope notified): The callback function to assign"]
    #[doc = " @user_data: Data to pass to @func"]
    #[doc = " @destroy: (nullable): The function to call when @user_data is not needed anymore"]
    #[doc = ""]
    #[doc = " Sets the implementation function for #hb_font_get_font_h_extents_func_t."]
    #[doc = ""]
    #[doc = " Since: 1.1.2"]
    pub fn hb_font_funcs_set_font_h_extents_func(
        ffuncs: *mut hb_font_funcs_t,
        func: hb_font_get_font_h_extents_func_t,
        user_data: *mut ::std::os::raw::c_void,
        destroy: hb_destroy_func_t,
    );
}
extern "C" {
    #[doc = " hb_font_funcs_set_font_v_extents_func:"]
    #[doc = " @ffuncs: A font-function structure"]
    #[doc = " @func: (closure user_data) (destroy destroy) (scope notified): The callback function to assign"]
    #[doc = " @user_data: Data to pass to @func"]
    #[doc = " @destroy: (nullable): The function to call when @user_data is not needed anymore"]
    #[doc = ""]
    #[doc = " Sets the implementation function for #hb_font_get_font_v_extents_func_t."]
    #[doc = ""]
    #[doc = " Since: 1.1.2"]
    pub fn hb_font_funcs_set_font_v_extents_func(
        ffuncs: *mut hb_font_funcs_t,
        func: hb_font_get_font_v_extents_func_t,
        user_data: *mut ::std::os::raw::c_void,
        destroy: hb_destroy_func_t,
    );
}
extern "C" {
    #[doc = " hb_font_funcs_set_nominal_glyph_func:"]
    #[doc = " @ffuncs: A font-function structure"]
    #[doc = " @func: (closure user_data) (destroy destroy) (scope notified): The callback function to assign"]
    #[doc = " @user_data: Data to pass to @func"]
    #[doc = " @destroy: (nullable): The function to call when @user_data is not needed anymore"]
    #[doc = ""]
    #[doc = " Sets the implementation function for #hb_font_get_nominal_glyph_func_t."]
    #[doc = ""]
    #[doc = " Since: 1.2.3"]
    pub fn hb_font_funcs_set_nominal_glyph_func(
        ffuncs: *mut hb_font_funcs_t,
        func: hb_font_get_nominal_glyph_func_t,
        user_data: *mut ::std::os::raw::c_void,
        destroy: hb_destroy_func_t,
    );
}
extern "C" {
    #[doc = " hb_font_funcs_set_nominal_glyphs_func:"]
    #[doc = " @ffuncs: A font-function structure"]
    #[doc = " @func: (closure user_data) (destroy destroy) (scope notified): The callback function to assign"]
    #[doc = " @user_data: Data to pass to @func"]
    #[doc = " @destroy: (nullable): The function to call when @user_data is not needed anymore"]
    #[doc = ""]
    #[doc = " Sets the implementation function for #hb_font_get_nominal_glyphs_func_t."]
    #[doc = ""]
    #[doc = " Since: 2.0.0"]
    pub fn hb_font_funcs_set_nominal_glyphs_func(
        ffuncs: *mut hb_font_funcs_t,
        func: hb_font_get_nominal_glyphs_func_t,
        user_data: *mut ::std::os::raw::c_void,
        destroy: hb_destroy_func_t,
    );
}
extern "C" {
    #[doc = " hb_font_funcs_set_variation_glyph_func:"]
    #[doc = " @ffuncs: A font-function structure"]
    #[doc = " @func: (closure user_data) (destroy destroy) (scope notified): The callback function to assign"]
    #[doc = " @user_data: Data to pass to @func"]
    #[doc = " @destroy: (nullable): The function to call when @user_data is not needed anymore"]
    #[doc = ""]
    #[doc = " Sets the implementation function for #hb_font_get_variation_glyph_func_t."]
    #[doc = ""]
    #[doc = " Since: 1.2.3"]
    pub fn hb_font_funcs_set_variation_glyph_func(
        ffuncs: *mut hb_font_funcs_t,
        func: hb_font_get_variation_glyph_func_t,
        user_data: *mut ::std::os::raw::c_void,
        destroy: hb_destroy_func_t,
    );
}
extern "C" {
    #[doc = " hb_font_funcs_set_glyph_h_advance_func:"]
    #[doc = " @ffuncs: A font-function structure"]
    #[doc = " @func: (closure user_data) (destroy destroy) (scope notified): The callback function to assign"]
    #[doc = " @user_data: Data to pass to @func"]
    #[doc = " @destroy: (nullable): The function to call when @user_data is not needed anymore"]
    #[doc = ""]
    #[doc = " Sets the implementation function for #hb_font_get_glyph_h_advance_func_t."]
    #[doc = ""]
    #[doc = " Since: 0.9.2"]
    pub fn hb_font_funcs_set_glyph_h_advance_func(
        ffuncs: *mut hb_font_funcs_t,
        func: hb_font_get_glyph_h_advance_func_t,
        user_data: *mut ::std::os::raw::c_void,
        destroy: hb_destroy_func_t,
    );
}
extern "C" {
    #[doc = " hb_font_funcs_set_glyph_v_advance_func:"]
    #[doc = " @ffuncs: A font-function structure"]
    #[doc = " @func: (closure user_data) (destroy destroy) (scope notified): The callback function to assign"]
    #[doc = " @user_data: Data to pass to @func"]
    #[doc = " @destroy: (nullable): The function to call when @user_data is not needed anymore"]
    #[doc = ""]
    #[doc = " Sets the implementation function for #hb_font_get_glyph_v_advance_func_t."]
    #[doc = ""]
    #[doc = " Since: 0.9.2"]
    pub fn hb_font_funcs_set_glyph_v_advance_func(
        ffuncs: *mut hb_font_funcs_t,
        func: hb_font_get_glyph_v_advance_func_t,
        user_data: *mut ::std::os::raw::c_void,
        destroy: hb_destroy_func_t,
    );
}
extern "C" {
    #[doc = " hb_font_funcs_set_glyph_h_advances_func:"]
    #[doc = " @ffuncs: A font-function structure"]
    #[doc = " @func: (closure user_data) (destroy destroy) (scope notified): The callback function to assign"]
    #[doc = " @user_data: Data to pass to @func"]
    #[doc = " @destroy: (nullable): The function to call when @user_data is not needed anymore"]
    #[doc = ""]
    #[doc = " Sets the implementation function for #hb_font_get_glyph_h_advances_func_t."]
    #[doc = ""]
    #[doc = " Since: 1.8.6"]
    pub fn hb_font_funcs_set_glyph_h_advances_func(
        ffuncs: *mut hb_font_funcs_t,
        func: hb_font_get_glyph_h_advances_func_t,
        user_data: *mut ::std::os::raw::c_void,
        destroy: hb_destroy_func_t,
    );
}
extern "C" {
    #[doc = " hb_font_funcs_set_glyph_v_advances_func:"]
    #[doc = " @ffuncs: A font-function structure"]
    #[doc = " @func: (closure user_data) (destroy destroy) (scope notified): The callback function to assign"]
    #[doc = " @user_data: Data to pass to @func"]
    #[doc = " @destroy: (nullable): The function to call when @user_data is not needed anymore"]
    #[doc = ""]
    #[doc = " Sets the implementation function for #hb_font_get_glyph_v_advances_func_t."]
    #[doc = ""]
    #[doc = " Since: 1.8.6"]
    pub fn hb_font_funcs_set_glyph_v_advances_func(
        ffuncs: *mut hb_font_funcs_t,
        func: hb_font_get_glyph_v_advances_func_t,
        user_data: *mut ::std::os::raw::c_void,
        destroy: hb_destroy_func_t,
    );
}
extern "C" {
    #[doc = " hb_font_funcs_set_glyph_h_origin_func:"]
    #[doc = " @ffuncs: A font-function structure"]
    #[doc = " @func: (closure user_data) (destroy destroy) (scope notified): The callback function to assign"]
    #[doc = " @user_data: Data to pass to @func"]
    #[doc = " @destroy: (nullable): The function to call when @user_data is not needed anymore"]
    #[doc = ""]
    #[doc = " Sets the implementation function for #hb_font_get_glyph_h_origin_func_t."]
    #[doc = ""]
    #[doc = " Since: 0.9.2"]
    pub fn hb_font_funcs_set_glyph_h_origin_func(
        ffuncs: *mut hb_font_funcs_t,
        func: hb_font_get_glyph_h_origin_func_t,
        user_data: *mut ::std::os::raw::c_void,
        destroy: hb_destroy_func_t,
    );
}
extern "C" {
    #[doc = " hb_font_funcs_set_glyph_v_origin_func:"]
    #[doc = " @ffuncs: A font-function structure"]
    #[doc = " @func: (closure user_data) (destroy destroy) (scope notified): The callback function to assign"]
    #[doc = " @user_data: Data to pass to @func"]
    #[doc = " @destroy: (nullable): The function to call when @user_data is not needed anymore"]
    #[doc = ""]
    #[doc = " Sets the implementation function for #hb_font_get_glyph_v_origin_func_t."]
    #[doc = ""]
    #[doc = " Since: 0.9.2"]
    pub fn hb_font_funcs_set_glyph_v_origin_func(
        ffuncs: *mut hb_font_funcs_t,
        func: hb_font_get_glyph_v_origin_func_t,
        user_data: *mut ::std::os::raw::c_void,
        destroy: hb_destroy_func_t,
    );
}
extern "C" {
    #[doc = " hb_font_funcs_set_glyph_h_kerning_func:"]
    #[doc = " @ffuncs: A font-function structure"]
    #[doc = " @func: (closure user_data) (destroy destroy) (scope notified): The callback function to assign"]
    #[doc = " @user_data: Data to pass to @func"]
    #[doc = " @destroy: (nullable): The function to call when @user_data is not needed anymore"]
    #[doc = ""]
    #[doc = " Sets the implementation function for #hb_font_get_glyph_h_kerning_func_t."]
    #[doc = ""]
    #[doc = " Since: 0.9.2"]
    pub fn hb_font_funcs_set_glyph_h_kerning_func(
        ffuncs: *mut hb_font_funcs_t,
        func: hb_font_get_glyph_h_kerning_func_t,
        user_data: *mut ::std::os::raw::c_void,
        destroy: hb_destroy_func_t,
    );
}
extern "C" {
    #[doc = " hb_font_funcs_set_glyph_extents_func:"]
    #[doc = " @ffuncs: A font-function structure"]
    #[doc = " @func: (closure user_data) (destroy destroy) (scope notified): The callback function to assign"]
    #[doc = " @user_data: Data to pass to @func"]
    #[doc = " @destroy: (nullable): The function to call when @user_data is not needed anymore"]
    #[doc = ""]
    #[doc = " Sets the implementation function for #hb_font_get_glyph_extents_func_t."]
    #[doc = ""]
    #[doc = " Since: 0.9.2"]
    pub fn hb_font_funcs_set_glyph_extents_func(
        ffuncs: *mut hb_font_funcs_t,
        func: hb_font_get_glyph_extents_func_t,
        user_data: *mut ::std::os::raw::c_void,
        destroy: hb_destroy_func_t,
    );
}
extern "C" {
    #[doc = " hb_font_funcs_set_glyph_contour_point_func:"]
    #[doc = " @ffuncs: A font-function structure"]
    #[doc = " @func: (closure user_data) (destroy destroy) (scope notified): The callback function to assign"]
    #[doc = " @user_data: Data to pass to @func"]
    #[doc = " @destroy: (nullable): The function to call when @user_data is not needed anymore"]
    #[doc = ""]
    #[doc = " Sets the implementation function for #hb_font_get_glyph_contour_point_func_t."]
    #[doc = ""]
    #[doc = " Since: 0.9.2"]
    pub fn hb_font_funcs_set_glyph_contour_point_func(
        ffuncs: *mut hb_font_funcs_t,
        func: hb_font_get_glyph_contour_point_func_t,
        user_data: *mut ::std::os::raw::c_void,
        destroy: hb_destroy_func_t,
    );
}
extern "C" {
    #[doc = " hb_font_funcs_set_glyph_name_func:"]
    #[doc = " @ffuncs: A font-function structure"]
    #[doc = " @func: (closure user_data) (destroy destroy) (scope notified): The callback function to assign"]
    #[doc = " @user_data: Data to pass to @func"]
    #[doc = " @destroy: (nullable): The function to call when @user_data is not needed anymore"]
    #[doc = ""]
    #[doc = " Sets the implementation function for #hb_font_get_glyph_name_func_t."]
    #[doc = ""]
    #[doc = " Since: 0.9.2"]
    pub fn hb_font_funcs_set_glyph_name_func(
        ffuncs: *mut hb_font_funcs_t,
        func: hb_font_get_glyph_name_func_t,
        user_data: *mut ::std::os::raw::c_void,
        destroy: hb_destroy_func_t,
    );
}
extern "C" {
    #[doc = " hb_font_funcs_set_glyph_from_name_func:"]
    #[doc = " @ffuncs: A font-function structure"]
    #[doc = " @func: (closure user_data) (destroy destroy) (scope notified): The callback function to assign"]
    #[doc = " @user_data: Data to pass to @func"]
    #[doc = " @destroy: (nullable): The function to call when @user_data is not needed anymore"]
    #[doc = ""]
    #[doc = " Sets the implementation function for #hb_font_get_glyph_from_name_func_t."]
    #[doc = ""]
    #[doc = " Since: 0.9.2"]
    pub fn hb_font_funcs_set_glyph_from_name_func(
        ffuncs: *mut hb_font_funcs_t,
        func: hb_font_get_glyph_from_name_func_t,
        user_data: *mut ::std::os::raw::c_void,
        destroy: hb_destroy_func_t,
    );
}
extern "C" {
    #[doc = " hb_font_funcs_set_glyph_shape_func:"]
    #[doc = " @ffuncs: A font-function structure"]
    #[doc = " @func: (closure user_data) (destroy destroy) (scope notified): The callback function to assign"]
    #[doc = " @user_data: Data to pass to @func"]
    #[doc = " @destroy: (nullable): The function to call when @user_data is not needed anymore"]
    #[doc = ""]
    #[doc = " Sets the implementation function for #hb_font_get_glyph_shape_func_t."]
    #[doc = ""]
    #[doc = " Since: 4.0.0"]
    pub fn hb_font_funcs_set_glyph_shape_func(
        ffuncs: *mut hb_font_funcs_t,
        func: hb_font_get_glyph_shape_func_t,
        user_data: *mut ::std::os::raw::c_void,
        destroy: hb_destroy_func_t,
    );
}
extern "C" {
    pub fn hb_font_get_h_extents(
        font: *mut hb_font_t,
        extents: *mut hb_font_extents_t,
    ) -> hb_bool_t;
}
extern "C" {
    pub fn hb_font_get_v_extents(
        font: *mut hb_font_t,
        extents: *mut hb_font_extents_t,
    ) -> hb_bool_t;
}
extern "C" {
    pub fn hb_font_get_nominal_glyph(
        font: *mut hb_font_t,
        unicode: hb_codepoint_t,
        glyph: *mut hb_codepoint_t,
    ) -> hb_bool_t;
}
extern "C" {
    pub fn hb_font_get_variation_glyph(
        font: *mut hb_font_t,
        unicode: hb_codepoint_t,
        variation_selector: hb_codepoint_t,
        glyph: *mut hb_codepoint_t,
    ) -> hb_bool_t;
}
extern "C" {
    pub fn hb_font_get_nominal_glyphs(
        font: *mut hb_font_t,
        count: ::std::os::raw::c_uint,
        first_unicode: *const hb_codepoint_t,
        unicode_stride: ::std::os::raw::c_uint,
        first_glyph: *mut hb_codepoint_t,
        glyph_stride: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn hb_font_get_glyph_h_advance(
        font: *mut hb_font_t,
        glyph: hb_codepoint_t,
    ) -> hb_position_t;
}
extern "C" {
    pub fn hb_font_get_glyph_v_advance(
        font: *mut hb_font_t,
        glyph: hb_codepoint_t,
    ) -> hb_position_t;
}
extern "C" {
    pub fn hb_font_get_glyph_h_advances(
        font: *mut hb_font_t,
        count: ::std::os::raw::c_uint,
        first_glyph: *const hb_codepoint_t,
        glyph_stride: ::std::os::raw::c_uint,
        first_advance: *mut hb_position_t,
        advance_stride: ::std::os::raw::c_uint,
    );
}
extern "C" {
    pub fn hb_font_get_glyph_v_advances(
        font: *mut hb_font_t,
        count: ::std::os::raw::c_uint,
        first_glyph: *const hb_codepoint_t,
        glyph_stride: ::std::os::raw::c_uint,
        first_advance: *mut hb_position_t,
        advance_stride: ::std::os::raw::c_uint,
    );
}
extern "C" {
    pub fn hb_font_get_glyph_h_origin(
        font: *mut hb_font_t,
        glyph: hb_codepoint_t,
        x: *mut hb_position_t,
        y: *mut hb_position_t,
    ) -> hb_bool_t;
}
extern "C" {
    pub fn hb_font_get_glyph_v_origin(
        font: *mut hb_font_t,
        glyph: hb_codepoint_t,
        x: *mut hb_position_t,
        y: *mut hb_position_t,
    ) -> hb_bool_t;
}
extern "C" {
    pub fn hb_font_get_glyph_h_kerning(
        font: *mut hb_font_t,
        left_glyph: hb_codepoint_t,
        right_glyph: hb_codepoint_t,
    ) -> hb_position_t;
}
extern "C" {
    pub fn hb_font_get_glyph_extents(
        font: *mut hb_font_t,
        glyph: hb_codepoint_t,
        extents: *mut hb_glyph_extents_t,
    ) -> hb_bool_t;
}
extern "C" {
    pub fn hb_font_get_glyph_contour_point(
        font: *mut hb_font_t,
        glyph: hb_codepoint_t,
        point_index: ::std::os::raw::c_uint,
        x: *mut hb_position_t,
        y: *mut hb_position_t,
    ) -> hb_bool_t;
}
extern "C" {
    pub fn hb_font_get_glyph_name(
        font: *mut hb_font_t,
        glyph: hb_codepoint_t,
        name: *mut ::std::os::raw::c_char,
        size: ::std::os::raw::c_uint,
    ) -> hb_bool_t;
}
extern "C" {
    pub fn hb_font_get_glyph_from_name(
        font: *mut hb_font_t,
        name: *const ::std::os::raw::c_char,
        len: ::std::os::raw::c_int,
        glyph: *mut hb_codepoint_t,
    ) -> hb_bool_t;
}
extern "C" {
    pub fn hb_font_get_glyph_shape(
        font: *mut hb_font_t,
        glyph: hb_codepoint_t,
        dfuncs: *mut hb_draw_funcs_t,
        draw_data: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn hb_font_get_glyph(
        font: *mut hb_font_t,
        unicode: hb_codepoint_t,
        variation_selector: hb_codepoint_t,
        glyph: *mut hb_codepoint_t,
    ) -> hb_bool_t;
}
extern "C" {
    pub fn hb_font_get_extents_for_direction(
        font: *mut hb_font_t,
        direction: hb_direction_t,
        extents: *mut hb_font_extents_t,
    );
}
extern "C" {
    pub fn hb_font_get_glyph_advance_for_direction(
        font: *mut hb_font_t,
        glyph: hb_codepoint_t,
        direction: hb_direction_t,
        x: *mut hb_position_t,
        y: *mut hb_position_t,
    );
}
extern "C" {
    pub fn hb_font_get_glyph_advances_for_direction(
        font: *mut hb_font_t,
        direction: hb_direction_t,
        count: ::std::os::raw::c_uint,
        first_glyph: *const hb_codepoint_t,
        glyph_stride: ::std::os::raw::c_uint,
        first_advance: *mut hb_position_t,
        advance_stride: ::std::os::raw::c_uint,
    );
}
extern "C" {
    pub fn hb_font_get_glyph_origin_for_direction(
        font: *mut hb_font_t,
        glyph: hb_codepoint_t,
        direction: hb_direction_t,
        x: *mut hb_position_t,
        y: *mut hb_position_t,
    );
}
extern "C" {
    pub fn hb_font_add_glyph_origin_for_direction(
        font: *mut hb_font_t,
        glyph: hb_codepoint_t,
        direction: hb_direction_t,
        x: *mut hb_position_t,
        y: *mut hb_position_t,
    );
}
extern "C" {
    pub fn hb_font_subtract_glyph_origin_for_direction(
        font: *mut hb_font_t,
        glyph: hb_codepoint_t,
        direction: hb_direction_t,
        x: *mut hb_position_t,
        y: *mut hb_position_t,
    );
}
extern "C" {
    pub fn hb_font_get_glyph_kerning_for_direction(
        font: *mut hb_font_t,
        first_glyph: hb_codepoint_t,
        second_glyph: hb_codepoint_t,
        direction: hb_direction_t,
        x: *mut hb_position_t,
        y: *mut hb_position_t,
    );
}
extern "C" {
    pub fn hb_font_get_glyph_extents_for_origin(
        font: *mut hb_font_t,
        glyph: hb_codepoint_t,
        direction: hb_direction_t,
        extents: *mut hb_glyph_extents_t,
    ) -> hb_bool_t;
}
extern "C" {
    pub fn hb_font_get_glyph_contour_point_for_origin(
        font: *mut hb_font_t,
        glyph: hb_codepoint_t,
        point_index: ::std::os::raw::c_uint,
        direction: hb_direction_t,
        x: *mut hb_position_t,
        y: *mut hb_position_t,
    ) -> hb_bool_t;
}
extern "C" {
    pub fn hb_font_glyph_to_string(
        font: *mut hb_font_t,
        glyph: hb_codepoint_t,
        s: *mut ::std::os::raw::c_char,
        size: ::std::os::raw::c_uint,
    );
}
extern "C" {
    pub fn hb_font_glyph_from_string(
        font: *mut hb_font_t,
        s: *const ::std::os::raw::c_char,
        len: ::std::os::raw::c_int,
        glyph: *mut hb_codepoint_t,
    ) -> hb_bool_t;
}
extern "C" {
    pub fn hb_font_create(face: *mut hb_face_t) -> *mut hb_font_t;
}
extern "C" {
    pub fn hb_font_create_sub_font(parent: *mut hb_font_t) -> *mut hb_font_t;
}
extern "C" {
    pub fn hb_font_get_empty() -> *mut hb_font_t;
}
extern "C" {
    pub fn hb_font_reference(font: *mut hb_font_t) -> *mut hb_font_t;
}
extern "C" {
    pub fn hb_font_destroy(font: *mut hb_font_t);
}
extern "C" {
    pub fn hb_font_set_user_data(
        font: *mut hb_font_t,
        key: *mut hb_user_data_key_t,
        data: *mut ::std::os::raw::c_void,
        destroy: hb_destroy_func_t,
        replace: hb_bool_t,
    ) -> hb_bool_t;
}
extern "C" {
    pub fn hb_font_get_user_data(
        font: *mut hb_font_t,
        key: *mut hb_user_data_key_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn hb_font_make_immutable(font: *mut hb_font_t);
}
extern "C" {
    pub fn hb_font_is_immutable(font: *mut hb_font_t) -> hb_bool_t;
}
extern "C" {
    pub fn hb_font_set_parent(font: *mut hb_font_t, parent: *mut hb_font_t);
}
extern "C" {
    pub fn hb_font_get_parent(font: *mut hb_font_t) -> *mut hb_font_t;
}
extern "C" {
    pub fn hb_font_set_face(font: *mut hb_font_t, face: *mut hb_face_t);
}
extern "C" {
    pub fn hb_font_get_face(font: *mut hb_font_t) -> *mut hb_face_t;
}
extern "C" {
    pub fn hb_font_set_funcs(
        font: *mut hb_font_t,
        klass: *mut hb_font_funcs_t,
        font_data: *mut ::std::os::raw::c_void,
        destroy: hb_destroy_func_t,
    );
}
extern "C" {
    pub fn hb_font_set_funcs_data(
        font: *mut hb_font_t,
        font_data: *mut ::std::os::raw::c_void,
        destroy: hb_destroy_func_t,
    );
}
extern "C" {
    pub fn hb_font_set_scale(
        font: *mut hb_font_t,
        x_scale: ::std::os::raw::c_int,
        y_scale: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn hb_font_get_scale(
        font: *mut hb_font_t,
        x_scale: *mut ::std::os::raw::c_int,
        y_scale: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn hb_font_set_ppem(
        font: *mut hb_font_t,
        x_ppem: ::std::os::raw::c_uint,
        y_ppem: ::std::os::raw::c_uint,
    );
}
extern "C" {
    pub fn hb_font_get_ppem(
        font: *mut hb_font_t,
        x_ppem: *mut ::std::os::raw::c_uint,
        y_ppem: *mut ::std::os::raw::c_uint,
    );
}
extern "C" {
    pub fn hb_font_set_ptem(font: *mut hb_font_t, ptem: ::std::os::raw::c_float);
}
extern "C" {
    pub fn hb_font_get_ptem(font: *mut hb_font_t) -> ::std::os::raw::c_float;
}
extern "C" {
    pub fn hb_font_set_synthetic_slant(font: *mut hb_font_t, slant: ::std::os::raw::c_float);
}
extern "C" {
    pub fn hb_font_get_synthetic_slant(font: *mut hb_font_t) -> ::std::os::raw::c_float;
}
extern "C" {
    pub fn hb_font_set_variations(
        font: *mut hb_font_t,
        variations: *const hb_variation_t,
        variations_length: ::std::os::raw::c_uint,
    );
}
extern "C" {
    pub fn hb_font_set_var_coords_design(
        font: *mut hb_font_t,
        coords: *const ::std::os::raw::c_float,
        coords_length: ::std::os::raw::c_uint,
    );
}
extern "C" {
    pub fn hb_font_get_var_coords_design(
        font: *mut hb_font_t,
        length: *mut ::std::os::raw::c_uint,
    ) -> *const ::std::os::raw::c_float;
}
extern "C" {
    pub fn hb_font_set_var_coords_normalized(
        font: *mut hb_font_t,
        coords: *const ::std::os::raw::c_int,
        coords_length: ::std::os::raw::c_uint,
    );
}
extern "C" {
    pub fn hb_font_get_var_coords_normalized(
        font: *mut hb_font_t,
        length: *mut ::std::os::raw::c_uint,
    ) -> *const ::std::os::raw::c_int;
}
extern "C" {
    pub fn hb_font_set_var_named_instance(
        font: *mut hb_font_t,
        instance_index: ::std::os::raw::c_uint,
    );
}
#[doc = " hb_glyph_info_t:"]
#[doc = " @codepoint: either a Unicode code point (before shaping) or a glyph index"]
#[doc = "             (after shaping)."]
#[doc = " @cluster: the index of the character in the original text that corresponds"]
#[doc = "           to this #hb_glyph_info_t, or whatever the client passes to"]
#[doc = "           hb_buffer_add(). More than one #hb_glyph_info_t can have the same"]
#[doc = "           @cluster value, if they resulted from the same character (e.g. one"]
#[doc = "           to many glyph substitution), and when more than one character gets"]
#[doc = "           merged in the same glyph (e.g. many to one glyph substitution) the"]
#[doc = "           #hb_glyph_info_t will have the smallest cluster value of them."]
#[doc = "           By default some characters are merged into the same cluster"]
#[doc = "           (e.g. combining marks have the same cluster as their bases)"]
#[doc = "           even if they are separate glyphs, hb_buffer_set_cluster_level()"]
#[doc = "           allow selecting more fine-grained cluster handling."]
#[doc = ""]
#[doc = " The #hb_glyph_info_t is the structure that holds information about the"]
#[doc = " glyphs and their relation to input text."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct hb_glyph_info_t {
    pub codepoint: hb_codepoint_t,
    pub mask: hb_mask_t,
    pub cluster: u32,
    pub var1: hb_var_int_t,
    pub var2: hb_var_int_t,
}
#[test]
fn bindgen_test_layout_hb_glyph_info_t() {
    assert_eq!(
        ::std::mem::size_of::<hb_glyph_info_t>(),
        20usize,
        concat!("Size of: ", stringify!(hb_glyph_info_t))
    );
    assert_eq!(
        ::std::mem::align_of::<hb_glyph_info_t>(),
        4usize,
        concat!("Alignment of ", stringify!(hb_glyph_info_t))
    );
    fn test_field_codepoint() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<hb_glyph_info_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).codepoint) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(hb_glyph_info_t),
                "::",
                stringify!(codepoint)
            )
        );
    }
    test_field_codepoint();
    fn test_field_mask() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<hb_glyph_info_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).mask) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(hb_glyph_info_t),
                "::",
                stringify!(mask)
            )
        );
    }
    test_field_mask();
    fn test_field_cluster() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<hb_glyph_info_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cluster) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(hb_glyph_info_t),
                "::",
                stringify!(cluster)
            )
        );
    }
    test_field_cluster();
    fn test_field_var1() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<hb_glyph_info_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).var1) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(hb_glyph_info_t),
                "::",
                stringify!(var1)
            )
        );
    }
    test_field_var1();
    fn test_field_var2() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<hb_glyph_info_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).var2) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(hb_glyph_info_t),
                "::",
                stringify!(var2)
            )
        );
    }
    test_field_var2();
}
pub const HB_GLYPH_FLAG_UNSAFE_TO_BREAK: hb_glyph_flags_t = 1;
pub const HB_GLYPH_FLAG_UNSAFE_TO_CONCAT: hb_glyph_flags_t = 2;
pub const HB_GLYPH_FLAG_DEFINED: hb_glyph_flags_t = 3;
#[doc = " hb_glyph_flags_t:"]
#[doc = " @HB_GLYPH_FLAG_UNSAFE_TO_BREAK: Indicates that if input text is broken at the"]
#[doc = " \t\t\t\t   beginning of the cluster this glyph is part of,"]
#[doc = " \t\t\t\t   then both sides need to be re-shaped, as the"]
#[doc = " \t\t\t\t   result might be different."]
#[doc = " \t\t\t\t   On the flip side, it means that when this"]
#[doc = " \t\t\t\t   flag is not present, then it is safe to break"]
#[doc = " \t\t\t\t   the glyph-run at the beginning of this"]
#[doc = " \t\t\t\t   cluster, and the two sides will represent the"]
#[doc = " \t\t\t\t   exact same result one would get if breaking"]
#[doc = " \t\t\t\t   input text at the beginning of this cluster"]
#[doc = " \t\t\t\t   and shaping the two sides separately."]
#[doc = " \t\t\t\t   This can be used to optimize paragraph"]
#[doc = " \t\t\t\t   layout, by avoiding re-shaping of each line"]
#[doc = " \t\t\t\t   after line-breaking."]
#[doc = " @HB_GLYPH_FLAG_UNSAFE_TO_CONCAT: Indicates that if input text is changed on one"]
#[doc = " \t\t\t\t   side of the beginning of the cluster this glyph"]
#[doc = " \t\t\t\t   is part of, then the shaping results for the"]
#[doc = " \t\t\t\t   other side might change."]
#[doc = " \t\t\t\t   Note that the absence of this flag will NOT by"]
#[doc = " \t\t\t\t   itself mean that it IS safe to concat text."]
#[doc = " \t\t\t\t   Only two pieces of text both of which clear of"]
#[doc = " \t\t\t\t   this flag can be concatenated safely."]
#[doc = " \t\t\t\t   This can be used to optimize paragraph"]
#[doc = " \t\t\t\t   layout, by avoiding re-shaping of each line"]
#[doc = " \t\t\t\t   after line-breaking, by limiting the"]
#[doc = " \t\t\t\t   reshaping to a small piece around the"]
#[doc = " \t\t\t\t   breaking positin only, even if the breaking"]
#[doc = " \t\t\t\t   position carries the"]
#[doc = " \t\t\t\t   #HB_GLYPH_FLAG_UNSAFE_TO_BREAK or when"]
#[doc = " \t\t\t\t   hyphenation or other text transformation"]
#[doc = " \t\t\t\t   happens at line-break position, in the following"]
#[doc = " \t\t\t\t   way:"]
#[doc = " \t\t\t\t   1. Iterate back from the line-break position"]
#[doc = " \t\t\t\t   until the first cluster start position that is"]
#[doc = " \t\t\t\t   NOT unsafe-to-concat, 2. shape the segment from"]
#[doc = " \t\t\t\t   there till the end of line, 3. check whether the"]
#[doc = " \t\t\t\t   resulting glyph-run also is clear of the"]
#[doc = " \t\t\t\t   unsafe-to-concat at its start-of-text position;"]
#[doc = " \t\t\t\t   if it is, just splice it into place and the line"]
#[doc = " \t\t\t\t   is shaped; If not, move on to a position further"]
#[doc = " \t\t\t\t   back that is clear of unsafe-to-concat and retry"]
#[doc = " \t\t\t\t   from there, and repeat."]
#[doc = " \t\t\t\t   At the start of next line a similar algorithm can"]
#[doc = " \t\t\t\t   be implemented. That is: 1. Iterate forward from"]
#[doc = " \t\t\t\t   the line-break position until the first cluster"]
#[doc = " \t\t\t\t   start position that is NOT unsafe-to-concat, 2."]
#[doc = " \t\t\t\t   shape the segment from beginning of the line to"]
#[doc = " \t\t\t\t   that position, 3. check whether the resulting"]
#[doc = " \t\t\t\t   glyph-run also is clear of the unsafe-to-concat"]
#[doc = " \t\t\t\t   at its end-of-text position; if it is, just splice"]
#[doc = " \t\t\t\t   it into place and the beginning is shaped; If not,"]
#[doc = " \t\t\t\t   move on to a position further forward that is clear"]
#[doc = " \t\t\t\t   of unsafe-to-concat and retry up to there, and repeat."]
#[doc = " \t\t\t\t   A slight complication will arise in the"]
#[doc = " \t\t\t\t   implementation of the algorithm above,"]
#[doc = " \t\t\t\t   because while our buffer API has a way to"]
#[doc = " \t\t\t\t   return flags for position corresponding to"]
#[doc = " \t\t\t\t   start-of-text, there is currently no position"]
#[doc = " \t\t\t\t   corresponding to end-of-text.  This limitation"]
#[doc = " \t\t\t\t   can be alleviated by shaping more text than needed"]
#[doc = " \t\t\t\t   and looking for unsafe-to-concat flag within text"]
#[doc = " \t\t\t\t   clusters."]
#[doc = " \t\t\t\t   The #HB_GLYPH_FLAG_UNSAFE_TO_BREAK flag will"]
#[doc = " \t\t\t\t   always imply this flag."]
#[doc = "\t\t\t\t   To use this flag, you must enable the buffer flag"]
#[doc = "\t\t\t\t   @HB_BUFFER_FLAG_PRODUCE_UNSAFE_TO_CONCAT during"]
#[doc = "\t\t\t\t   shaping, otherwise the buffer flag will not be"]
#[doc = "\t\t\t\t   reliably produced."]
#[doc = " \t\t\t\t   Since: 4.0.0"]
#[doc = " @HB_GLYPH_FLAG_DEFINED: All the currently defined flags."]
#[doc = ""]
#[doc = " Flags for #hb_glyph_info_t."]
#[doc = ""]
#[doc = " Since: 1.5.0"]
pub type hb_glyph_flags_t = ::std::os::raw::c_uint;
extern "C" {
    pub fn hb_glyph_info_get_glyph_flags(info: *const hb_glyph_info_t) -> hb_glyph_flags_t;
}
#[doc = " hb_glyph_position_t:"]
#[doc = " @x_advance: how much the line advances after drawing this glyph when setting"]
#[doc = "             text in horizontal direction."]
#[doc = " @y_advance: how much the line advances after drawing this glyph when setting"]
#[doc = "             text in vertical direction."]
#[doc = " @x_offset: how much the glyph moves on the X-axis before drawing it, this"]
#[doc = "            should not affect how much the line advances."]
#[doc = " @y_offset: how much the glyph moves on the Y-axis before drawing it, this"]
#[doc = "            should not affect how much the line advances."]
#[doc = ""]
#[doc = " The #hb_glyph_position_t is the structure that holds the positions of the"]
#[doc = " glyph in both horizontal and vertical directions. All positions in"]
#[doc = " #hb_glyph_position_t are relative to the current point."]
#[doc = ""]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct hb_glyph_position_t {
    pub x_advance: hb_position_t,
    pub y_advance: hb_position_t,
    pub x_offset: hb_position_t,
    pub y_offset: hb_position_t,
    pub var: hb_var_int_t,
}
#[test]
fn bindgen_test_layout_hb_glyph_position_t() {
    assert_eq!(
        ::std::mem::size_of::<hb_glyph_position_t>(),
        20usize,
        concat!("Size of: ", stringify!(hb_glyph_position_t))
    );
    assert_eq!(
        ::std::mem::align_of::<hb_glyph_position_t>(),
        4usize,
        concat!("Alignment of ", stringify!(hb_glyph_position_t))
    );
    fn test_field_x_advance() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<hb_glyph_position_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).x_advance) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(hb_glyph_position_t),
                "::",
                stringify!(x_advance)
            )
        );
    }
    test_field_x_advance();
    fn test_field_y_advance() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<hb_glyph_position_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).y_advance) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(hb_glyph_position_t),
                "::",
                stringify!(y_advance)
            )
        );
    }
    test_field_y_advance();
    fn test_field_x_offset() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<hb_glyph_position_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).x_offset) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(hb_glyph_position_t),
                "::",
                stringify!(x_offset)
            )
        );
    }
    test_field_x_offset();
    fn test_field_y_offset() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<hb_glyph_position_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).y_offset) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(hb_glyph_position_t),
                "::",
                stringify!(y_offset)
            )
        );
    }
    test_field_y_offset();
    fn test_field_var() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<hb_glyph_position_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).var) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(hb_glyph_position_t),
                "::",
                stringify!(var)
            )
        );
    }
    test_field_var();
}
#[doc = " hb_segment_properties_t:"]
#[doc = " @direction: the #hb_direction_t of the buffer, see hb_buffer_set_direction()."]
#[doc = " @script: the #hb_script_t of the buffer, see hb_buffer_set_script()."]
#[doc = " @language: the #hb_language_t of the buffer, see hb_buffer_set_language()."]
#[doc = ""]
#[doc = " The structure that holds various text properties of an #hb_buffer_t. Can be"]
#[doc = " set and retrieved using hb_buffer_set_segment_properties() and"]
#[doc = " hb_buffer_get_segment_properties(), respectively."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hb_segment_properties_t {
    pub direction: hb_direction_t,
    pub script: hb_script_t,
    pub language: hb_language_t,
    pub reserved1: *mut ::std::os::raw::c_void,
    pub reserved2: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_hb_segment_properties_t() {
    assert_eq!(
        ::std::mem::size_of::<hb_segment_properties_t>(),
        32usize,
        concat!("Size of: ", stringify!(hb_segment_properties_t))
    );
    assert_eq!(
        ::std::mem::align_of::<hb_segment_properties_t>(),
        8usize,
        concat!("Alignment of ", stringify!(hb_segment_properties_t))
    );
    fn test_field_direction() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<hb_segment_properties_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).direction) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(hb_segment_properties_t),
                "::",
                stringify!(direction)
            )
        );
    }
    test_field_direction();
    fn test_field_script() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<hb_segment_properties_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).script) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(hb_segment_properties_t),
                "::",
                stringify!(script)
            )
        );
    }
    test_field_script();
    fn test_field_language() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<hb_segment_properties_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).language) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(hb_segment_properties_t),
                "::",
                stringify!(language)
            )
        );
    }
    test_field_language();
    fn test_field_reserved1() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<hb_segment_properties_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved1) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(hb_segment_properties_t),
                "::",
                stringify!(reserved1)
            )
        );
    }
    test_field_reserved1();
    fn test_field_reserved2() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<hb_segment_properties_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved2) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(hb_segment_properties_t),
                "::",
                stringify!(reserved2)
            )
        );
    }
    test_field_reserved2();
}
extern "C" {
    pub fn hb_segment_properties_equal(
        a: *const hb_segment_properties_t,
        b: *const hb_segment_properties_t,
    ) -> hb_bool_t;
}
extern "C" {
    pub fn hb_segment_properties_hash(p: *const hb_segment_properties_t) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn hb_segment_properties_overlay(
        p: *mut hb_segment_properties_t,
        src: *const hb_segment_properties_t,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hb_buffer_t {
    _unused: [u8; 0],
}
extern "C" {
    pub fn hb_buffer_create() -> *mut hb_buffer_t;
}
extern "C" {
    pub fn hb_buffer_create_similar(src: *const hb_buffer_t) -> *mut hb_buffer_t;
}
extern "C" {
    pub fn hb_buffer_reset(buffer: *mut hb_buffer_t);
}
extern "C" {
    pub fn hb_buffer_get_empty() -> *mut hb_buffer_t;
}
extern "C" {
    pub fn hb_buffer_reference(buffer: *mut hb_buffer_t) -> *mut hb_buffer_t;
}
extern "C" {
    pub fn hb_buffer_destroy(buffer: *mut hb_buffer_t);
}
extern "C" {
    pub fn hb_buffer_set_user_data(
        buffer: *mut hb_buffer_t,
        key: *mut hb_user_data_key_t,
        data: *mut ::std::os::raw::c_void,
        destroy: hb_destroy_func_t,
        replace: hb_bool_t,
    ) -> hb_bool_t;
}
extern "C" {
    pub fn hb_buffer_get_user_data(
        buffer: *mut hb_buffer_t,
        key: *mut hb_user_data_key_t,
    ) -> *mut ::std::os::raw::c_void;
}
pub const HB_BUFFER_CONTENT_TYPE_INVALID: hb_buffer_content_type_t = 0;
pub const HB_BUFFER_CONTENT_TYPE_UNICODE: hb_buffer_content_type_t = 1;
pub const HB_BUFFER_CONTENT_TYPE_GLYPHS: hb_buffer_content_type_t = 2;
#[doc = " hb_buffer_content_type_t:"]
#[doc = " @HB_BUFFER_CONTENT_TYPE_INVALID: Initial value for new buffer."]
#[doc = " @HB_BUFFER_CONTENT_TYPE_UNICODE: The buffer contains input characters (before shaping)."]
#[doc = " @HB_BUFFER_CONTENT_TYPE_GLYPHS: The buffer contains output glyphs (after shaping)."]
#[doc = ""]
#[doc = " The type of #hb_buffer_t contents."]
pub type hb_buffer_content_type_t = ::std::os::raw::c_uint;
extern "C" {
    pub fn hb_buffer_set_content_type(
        buffer: *mut hb_buffer_t,
        content_type: hb_buffer_content_type_t,
    );
}
extern "C" {
    pub fn hb_buffer_get_content_type(buffer: *mut hb_buffer_t) -> hb_buffer_content_type_t;
}
extern "C" {
    pub fn hb_buffer_set_unicode_funcs(
        buffer: *mut hb_buffer_t,
        unicode_funcs: *mut hb_unicode_funcs_t,
    );
}
extern "C" {
    pub fn hb_buffer_get_unicode_funcs(buffer: *mut hb_buffer_t) -> *mut hb_unicode_funcs_t;
}
extern "C" {
    pub fn hb_buffer_set_direction(buffer: *mut hb_buffer_t, direction: hb_direction_t);
}
extern "C" {
    pub fn hb_buffer_get_direction(buffer: *mut hb_buffer_t) -> hb_direction_t;
}
extern "C" {
    pub fn hb_buffer_set_script(buffer: *mut hb_buffer_t, script: hb_script_t);
}
extern "C" {
    pub fn hb_buffer_get_script(buffer: *mut hb_buffer_t) -> hb_script_t;
}
extern "C" {
    pub fn hb_buffer_set_language(buffer: *mut hb_buffer_t, language: hb_language_t);
}
extern "C" {
    pub fn hb_buffer_get_language(buffer: *mut hb_buffer_t) -> hb_language_t;
}
extern "C" {
    pub fn hb_buffer_set_segment_properties(
        buffer: *mut hb_buffer_t,
        props: *const hb_segment_properties_t,
    );
}
extern "C" {
    pub fn hb_buffer_get_segment_properties(
        buffer: *mut hb_buffer_t,
        props: *mut hb_segment_properties_t,
    );
}
extern "C" {
    pub fn hb_buffer_guess_segment_properties(buffer: *mut hb_buffer_t);
}
pub const HB_BUFFER_FLAG_DEFAULT: hb_buffer_flags_t = 0;
pub const HB_BUFFER_FLAG_BOT: hb_buffer_flags_t = 1;
pub const HB_BUFFER_FLAG_EOT: hb_buffer_flags_t = 2;
pub const HB_BUFFER_FLAG_PRESERVE_DEFAULT_IGNORABLES: hb_buffer_flags_t = 4;
pub const HB_BUFFER_FLAG_REMOVE_DEFAULT_IGNORABLES: hb_buffer_flags_t = 8;
pub const HB_BUFFER_FLAG_DO_NOT_INSERT_DOTTED_CIRCLE: hb_buffer_flags_t = 16;
pub const HB_BUFFER_FLAG_VERIFY: hb_buffer_flags_t = 32;
pub const HB_BUFFER_FLAG_PRODUCE_UNSAFE_TO_CONCAT: hb_buffer_flags_t = 64;
#[doc = " hb_buffer_flags_t:"]
#[doc = " @HB_BUFFER_FLAG_DEFAULT: the default buffer flag."]
#[doc = " @HB_BUFFER_FLAG_BOT: flag indicating that special handling of the beginning"]
#[doc = "                      of text paragraph can be applied to this buffer. Should usually"]
#[doc = "                      be set, unless you are passing to the buffer only part"]
#[doc = "                      of the text without the full context."]
#[doc = " @HB_BUFFER_FLAG_EOT: flag indicating that special handling of the end of text"]
#[doc = "                      paragraph can be applied to this buffer, similar to"]
#[doc = "                      @HB_BUFFER_FLAG_BOT."]
#[doc = " @HB_BUFFER_FLAG_PRESERVE_DEFAULT_IGNORABLES:"]
#[doc = "                      flag indication that character with Default_Ignorable"]
#[doc = "                      Unicode property should use the corresponding glyph"]
#[doc = "                      from the font, instead of hiding them (done by"]
#[doc = "                      replacing them with the space glyph and zeroing the"]
#[doc = "                      advance width.)  This flag takes precedence over"]
#[doc = "                      @HB_BUFFER_FLAG_REMOVE_DEFAULT_IGNORABLES."]
#[doc = " @HB_BUFFER_FLAG_REMOVE_DEFAULT_IGNORABLES:"]
#[doc = "                      flag indication that character with Default_Ignorable"]
#[doc = "                      Unicode property should be removed from glyph string"]
#[doc = "                      instead of hiding them (done by replacing them with the"]
#[doc = "                      space glyph and zeroing the advance width.)"]
#[doc = "                      @HB_BUFFER_FLAG_PRESERVE_DEFAULT_IGNORABLES takes"]
#[doc = "                      precedence over this flag. Since: 1.8.0"]
#[doc = " @HB_BUFFER_FLAG_DO_NOT_INSERT_DOTTED_CIRCLE:"]
#[doc = "                      flag indicating that a dotted circle should"]
#[doc = "                      not be inserted in the rendering of incorrect"]
#[doc = "                      character sequences (such at <0905 093E>). Since: 2.4.0"]
#[doc = " @HB_BUFFER_FLAG_VERIFY:"]
#[doc = "                      flag indicating that the hb_shape() call and its variants"]
#[doc = "                      should perform various verification processes on the results"]
#[doc = "                      of the shaping operation on the buffer.  If the verification"]
#[doc = "                      fails, then either a buffer message is sent, if a message"]
#[doc = "                      handler is installed on the buffer, or a message is written"]
#[doc = "                      to standard error.  In either case, the shaping result might"]
#[doc = "                      be modified to show the failed output. Since: 3.4.0"]
#[doc = " @HB_BUFFER_FLAG_PRODUCE_UNSAFE_TO_CONCAT:"]
#[doc = "                      flag indicating that the @HB_GLYPH_FLAG_UNSAFE_TO_CONCAT"]
#[doc = "                      glyph-flag should be produced by the shaper. By default"]
#[doc = "                      it will not be produced since it incurs a cost. Since: 4.0.0"]
#[doc = ""]
#[doc = " Flags for #hb_buffer_t."]
#[doc = ""]
#[doc = " Since: 0.9.20"]
pub type hb_buffer_flags_t = ::std::os::raw::c_uint;
extern "C" {
    pub fn hb_buffer_set_flags(buffer: *mut hb_buffer_t, flags: hb_buffer_flags_t);
}
extern "C" {
    pub fn hb_buffer_get_flags(buffer: *mut hb_buffer_t) -> hb_buffer_flags_t;
}
pub const HB_BUFFER_CLUSTER_LEVEL_MONOTONE_GRAPHEMES: hb_buffer_cluster_level_t = 0;
pub const HB_BUFFER_CLUSTER_LEVEL_MONOTONE_CHARACTERS: hb_buffer_cluster_level_t = 1;
pub const HB_BUFFER_CLUSTER_LEVEL_CHARACTERS: hb_buffer_cluster_level_t = 2;
pub const HB_BUFFER_CLUSTER_LEVEL_DEFAULT: hb_buffer_cluster_level_t = 0;
#[doc = " hb_buffer_cluster_level_t:"]
#[doc = " @HB_BUFFER_CLUSTER_LEVEL_MONOTONE_GRAPHEMES: Return cluster values grouped by graphemes into"]
#[doc = "   monotone order."]
#[doc = " @HB_BUFFER_CLUSTER_LEVEL_MONOTONE_CHARACTERS: Return cluster values grouped into monotone order."]
#[doc = " @HB_BUFFER_CLUSTER_LEVEL_CHARACTERS: Don't group cluster values."]
#[doc = " @HB_BUFFER_CLUSTER_LEVEL_DEFAULT: Default cluster level,"]
#[doc = "   equal to @HB_BUFFER_CLUSTER_LEVEL_MONOTONE_GRAPHEMES."]
#[doc = ""]
#[doc = " Data type for holding HarfBuzz's clustering behavior options. The cluster level"]
#[doc = " dictates one aspect of how HarfBuzz will treat non-base characters"]
#[doc = " during shaping."]
#[doc = ""]
#[doc = " In @HB_BUFFER_CLUSTER_LEVEL_MONOTONE_GRAPHEMES, non-base"]
#[doc = " characters are merged into the cluster of the base character that precedes them."]
#[doc = ""]
#[doc = " In @HB_BUFFER_CLUSTER_LEVEL_MONOTONE_CHARACTERS, non-base characters are initially"]
#[doc = " assigned their own cluster values, which are not merged into preceding base"]
#[doc = " clusters. This allows HarfBuzz to perform additional operations like reorder"]
#[doc = " sequences of adjacent marks."]
#[doc = ""]
#[doc = " @HB_BUFFER_CLUSTER_LEVEL_MONOTONE_GRAPHEMES is the default, because it maintains"]
#[doc = " backward compatibility with older versions of HarfBuzz. New client programs that"]
#[doc = " do not need to maintain such backward compatibility are recommended to use"]
#[doc = " @HB_BUFFER_CLUSTER_LEVEL_MONOTONE_CHARACTERS instead of the default."]
#[doc = ""]
#[doc = " Since: 0.9.42"]
pub type hb_buffer_cluster_level_t = ::std::os::raw::c_uint;
extern "C" {
    pub fn hb_buffer_set_cluster_level(
        buffer: *mut hb_buffer_t,
        cluster_level: hb_buffer_cluster_level_t,
    );
}
extern "C" {
    pub fn hb_buffer_get_cluster_level(buffer: *mut hb_buffer_t) -> hb_buffer_cluster_level_t;
}
extern "C" {
    pub fn hb_buffer_set_replacement_codepoint(
        buffer: *mut hb_buffer_t,
        replacement: hb_codepoint_t,
    );
}
extern "C" {
    pub fn hb_buffer_get_replacement_codepoint(buffer: *mut hb_buffer_t) -> hb_codepoint_t;
}
extern "C" {
    pub fn hb_buffer_set_invisible_glyph(buffer: *mut hb_buffer_t, invisible: hb_codepoint_t);
}
extern "C" {
    pub fn hb_buffer_get_invisible_glyph(buffer: *mut hb_buffer_t) -> hb_codepoint_t;
}
extern "C" {
    pub fn hb_buffer_set_not_found_glyph(buffer: *mut hb_buffer_t, not_found: hb_codepoint_t);
}
extern "C" {
    pub fn hb_buffer_get_not_found_glyph(buffer: *mut hb_buffer_t) -> hb_codepoint_t;
}
extern "C" {
    pub fn hb_buffer_clear_contents(buffer: *mut hb_buffer_t);
}
extern "C" {
    pub fn hb_buffer_pre_allocate(
        buffer: *mut hb_buffer_t,
        size: ::std::os::raw::c_uint,
    ) -> hb_bool_t;
}
extern "C" {
    pub fn hb_buffer_allocation_successful(buffer: *mut hb_buffer_t) -> hb_bool_t;
}
extern "C" {
    pub fn hb_buffer_reverse(buffer: *mut hb_buffer_t);
}
extern "C" {
    pub fn hb_buffer_reverse_range(
        buffer: *mut hb_buffer_t,
        start: ::std::os::raw::c_uint,
        end: ::std::os::raw::c_uint,
    );
}
extern "C" {
    pub fn hb_buffer_reverse_clusters(buffer: *mut hb_buffer_t);
}
extern "C" {
    pub fn hb_buffer_add(
        buffer: *mut hb_buffer_t,
        codepoint: hb_codepoint_t,
        cluster: ::std::os::raw::c_uint,
    );
}
extern "C" {
    pub fn hb_buffer_add_utf8(
        buffer: *mut hb_buffer_t,
        text: *const ::std::os::raw::c_char,
        text_length: ::std::os::raw::c_int,
        item_offset: ::std::os::raw::c_uint,
        item_length: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn hb_buffer_add_utf16(
        buffer: *mut hb_buffer_t,
        text: *const u16,
        text_length: ::std::os::raw::c_int,
        item_offset: ::std::os::raw::c_uint,
        item_length: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn hb_buffer_add_utf32(
        buffer: *mut hb_buffer_t,
        text: *const u32,
        text_length: ::std::os::raw::c_int,
        item_offset: ::std::os::raw::c_uint,
        item_length: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn hb_buffer_add_latin1(
        buffer: *mut hb_buffer_t,
        text: *const u8,
        text_length: ::std::os::raw::c_int,
        item_offset: ::std::os::raw::c_uint,
        item_length: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn hb_buffer_add_codepoints(
        buffer: *mut hb_buffer_t,
        text: *const hb_codepoint_t,
        text_length: ::std::os::raw::c_int,
        item_offset: ::std::os::raw::c_uint,
        item_length: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn hb_buffer_append(
        buffer: *mut hb_buffer_t,
        source: *const hb_buffer_t,
        start: ::std::os::raw::c_uint,
        end: ::std::os::raw::c_uint,
    );
}
extern "C" {
    pub fn hb_buffer_set_length(
        buffer: *mut hb_buffer_t,
        length: ::std::os::raw::c_uint,
    ) -> hb_bool_t;
}
extern "C" {
    pub fn hb_buffer_get_length(buffer: *mut hb_buffer_t) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn hb_buffer_get_glyph_infos(
        buffer: *mut hb_buffer_t,
        length: *mut ::std::os::raw::c_uint,
    ) -> *mut hb_glyph_info_t;
}
extern "C" {
    pub fn hb_buffer_get_glyph_positions(
        buffer: *mut hb_buffer_t,
        length: *mut ::std::os::raw::c_uint,
    ) -> *mut hb_glyph_position_t;
}
extern "C" {
    pub fn hb_buffer_has_positions(buffer: *mut hb_buffer_t) -> hb_bool_t;
}
extern "C" {
    pub fn hb_buffer_normalize_glyphs(buffer: *mut hb_buffer_t);
}
pub const HB_BUFFER_SERIALIZE_FLAG_DEFAULT: hb_buffer_serialize_flags_t = 0;
pub const HB_BUFFER_SERIALIZE_FLAG_NO_CLUSTERS: hb_buffer_serialize_flags_t = 1;
pub const HB_BUFFER_SERIALIZE_FLAG_NO_POSITIONS: hb_buffer_serialize_flags_t = 2;
pub const HB_BUFFER_SERIALIZE_FLAG_NO_GLYPH_NAMES: hb_buffer_serialize_flags_t = 4;
pub const HB_BUFFER_SERIALIZE_FLAG_GLYPH_EXTENTS: hb_buffer_serialize_flags_t = 8;
pub const HB_BUFFER_SERIALIZE_FLAG_GLYPH_FLAGS: hb_buffer_serialize_flags_t = 16;
pub const HB_BUFFER_SERIALIZE_FLAG_NO_ADVANCES: hb_buffer_serialize_flags_t = 32;
#[doc = " hb_buffer_serialize_flags_t:"]
#[doc = " @HB_BUFFER_SERIALIZE_FLAG_DEFAULT: serialize glyph names, clusters and positions."]
#[doc = " @HB_BUFFER_SERIALIZE_FLAG_NO_CLUSTERS: do not serialize glyph cluster."]
#[doc = " @HB_BUFFER_SERIALIZE_FLAG_NO_POSITIONS: do not serialize glyph position information."]
#[doc = " @HB_BUFFER_SERIALIZE_FLAG_NO_GLYPH_NAMES: do no serialize glyph name."]
#[doc = " @HB_BUFFER_SERIALIZE_FLAG_GLYPH_EXTENTS: serialize glyph extents."]
#[doc = " @HB_BUFFER_SERIALIZE_FLAG_GLYPH_FLAGS: serialize glyph flags. Since: 1.5.0"]
#[doc = " @HB_BUFFER_SERIALIZE_FLAG_NO_ADVANCES: do not serialize glyph advances,"]
#[doc = "  glyph offsets will reflect absolute glyph positions. Since: 1.8.0"]
#[doc = ""]
#[doc = " Flags that control what glyph information are serialized in hb_buffer_serialize_glyphs()."]
#[doc = ""]
#[doc = " Since: 0.9.20"]
pub type hb_buffer_serialize_flags_t = ::std::os::raw::c_uint;
pub const HB_BUFFER_SERIALIZE_FORMAT_TEXT: hb_buffer_serialize_format_t = 1413830740;
pub const HB_BUFFER_SERIALIZE_FORMAT_JSON: hb_buffer_serialize_format_t = 1246973774;
pub const HB_BUFFER_SERIALIZE_FORMAT_INVALID: hb_buffer_serialize_format_t = 0;
#[doc = " hb_buffer_serialize_format_t:"]
#[doc = " @HB_BUFFER_SERIALIZE_FORMAT_TEXT: a human-readable, plain text format."]
#[doc = " @HB_BUFFER_SERIALIZE_FORMAT_JSON: a machine-readable JSON format."]
#[doc = " @HB_BUFFER_SERIALIZE_FORMAT_INVALID: invalid format."]
#[doc = ""]
#[doc = " The buffer serialization and de-serialization format used in"]
#[doc = " hb_buffer_serialize_glyphs() and hb_buffer_deserialize_glyphs()."]
#[doc = ""]
#[doc = " Since: 0.9.2"]
pub type hb_buffer_serialize_format_t = ::std::os::raw::c_uint;
extern "C" {
    pub fn hb_buffer_serialize_format_from_string(
        str_: *const ::std::os::raw::c_char,
        len: ::std::os::raw::c_int,
    ) -> hb_buffer_serialize_format_t;
}
extern "C" {
    pub fn hb_buffer_serialize_format_to_string(
        format: hb_buffer_serialize_format_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn hb_buffer_serialize_list_formats() -> *mut *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn hb_buffer_serialize_glyphs(
        buffer: *mut hb_buffer_t,
        start: ::std::os::raw::c_uint,
        end: ::std::os::raw::c_uint,
        buf: *mut ::std::os::raw::c_char,
        buf_size: ::std::os::raw::c_uint,
        buf_consumed: *mut ::std::os::raw::c_uint,
        font: *mut hb_font_t,
        format: hb_buffer_serialize_format_t,
        flags: hb_buffer_serialize_flags_t,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn hb_buffer_serialize_unicode(
        buffer: *mut hb_buffer_t,
        start: ::std::os::raw::c_uint,
        end: ::std::os::raw::c_uint,
        buf: *mut ::std::os::raw::c_char,
        buf_size: ::std::os::raw::c_uint,
        buf_consumed: *mut ::std::os::raw::c_uint,
        format: hb_buffer_serialize_format_t,
        flags: hb_buffer_serialize_flags_t,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn hb_buffer_serialize(
        buffer: *mut hb_buffer_t,
        start: ::std::os::raw::c_uint,
        end: ::std::os::raw::c_uint,
        buf: *mut ::std::os::raw::c_char,
        buf_size: ::std::os::raw::c_uint,
        buf_consumed: *mut ::std::os::raw::c_uint,
        font: *mut hb_font_t,
        format: hb_buffer_serialize_format_t,
        flags: hb_buffer_serialize_flags_t,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn hb_buffer_deserialize_glyphs(
        buffer: *mut hb_buffer_t,
        buf: *const ::std::os::raw::c_char,
        buf_len: ::std::os::raw::c_int,
        end_ptr: *mut *const ::std::os::raw::c_char,
        font: *mut hb_font_t,
        format: hb_buffer_serialize_format_t,
    ) -> hb_bool_t;
}
extern "C" {
    pub fn hb_buffer_deserialize_unicode(
        buffer: *mut hb_buffer_t,
        buf: *const ::std::os::raw::c_char,
        buf_len: ::std::os::raw::c_int,
        end_ptr: *mut *const ::std::os::raw::c_char,
        format: hb_buffer_serialize_format_t,
    ) -> hb_bool_t;
}
pub const HB_BUFFER_DIFF_FLAG_EQUAL: hb_buffer_diff_flags_t = 0;
pub const HB_BUFFER_DIFF_FLAG_CONTENT_TYPE_MISMATCH: hb_buffer_diff_flags_t = 1;
pub const HB_BUFFER_DIFF_FLAG_LENGTH_MISMATCH: hb_buffer_diff_flags_t = 2;
pub const HB_BUFFER_DIFF_FLAG_NOTDEF_PRESENT: hb_buffer_diff_flags_t = 4;
pub const HB_BUFFER_DIFF_FLAG_DOTTED_CIRCLE_PRESENT: hb_buffer_diff_flags_t = 8;
pub const HB_BUFFER_DIFF_FLAG_CODEPOINT_MISMATCH: hb_buffer_diff_flags_t = 16;
pub const HB_BUFFER_DIFF_FLAG_CLUSTER_MISMATCH: hb_buffer_diff_flags_t = 32;
pub const HB_BUFFER_DIFF_FLAG_GLYPH_FLAGS_MISMATCH: hb_buffer_diff_flags_t = 64;
pub const HB_BUFFER_DIFF_FLAG_POSITION_MISMATCH: hb_buffer_diff_flags_t = 128;
#[doc = " hb_buffer_diff_flags_t:"]
#[doc = " @HB_BUFFER_DIFF_FLAG_EQUAL: equal buffers."]
#[doc = " @HB_BUFFER_DIFF_FLAG_CONTENT_TYPE_MISMATCH: buffers with different"]
#[doc = "     #hb_buffer_content_type_t."]
#[doc = " @HB_BUFFER_DIFF_FLAG_LENGTH_MISMATCH: buffers with differing length."]
#[doc = " @HB_BUFFER_DIFF_FLAG_NOTDEF_PRESENT: `.notdef` glyph is present in the"]
#[doc = "     reference buffer."]
#[doc = " @HB_BUFFER_DIFF_FLAG_DOTTED_CIRCLE_PRESENT: dotted circle glyph is present"]
#[doc = "     in the reference buffer."]
#[doc = " @HB_BUFFER_DIFF_FLAG_CODEPOINT_MISMATCH: difference in #hb_glyph_info_t.codepoint"]
#[doc = " @HB_BUFFER_DIFF_FLAG_CLUSTER_MISMATCH: difference in #hb_glyph_info_t.cluster"]
#[doc = " @HB_BUFFER_DIFF_FLAG_GLYPH_FLAGS_MISMATCH: difference in #hb_glyph_flags_t."]
#[doc = " @HB_BUFFER_DIFF_FLAG_POSITION_MISMATCH: difference in #hb_glyph_position_t."]
#[doc = ""]
#[doc = " Flags from comparing two #hb_buffer_t's."]
#[doc = ""]
#[doc = " Buffer with different #hb_buffer_content_type_t cannot be meaningfully"]
#[doc = " compared in any further detail."]
#[doc = ""]
#[doc = " For buffers with differing length, the per-glyph comparison is not"]
#[doc = " attempted, though we do still scan reference buffer for dotted circle and"]
#[doc = " `.notdef` glyphs."]
#[doc = ""]
#[doc = " If the buffers have the same length, we compare them glyph-by-glyph and"]
#[doc = " report which aspect(s) of the glyph info/position are different."]
#[doc = ""]
#[doc = " Since: 1.5.0"]
pub type hb_buffer_diff_flags_t = ::std::os::raw::c_uint;
extern "C" {
    pub fn hb_buffer_diff(
        buffer: *mut hb_buffer_t,
        reference: *mut hb_buffer_t,
        dottedcircle_glyph: hb_codepoint_t,
        position_fuzz: ::std::os::raw::c_uint,
    ) -> hb_buffer_diff_flags_t;
}
#[doc = " hb_buffer_message_func_t:"]
#[doc = " @buffer: An #hb_buffer_t to work upon"]
#[doc = " @font: The #hb_font_t the @buffer is shaped with"]
#[doc = " @message: %NULL-terminated message passed to the function"]
#[doc = " @user_data: User data pointer passed by the caller"]
#[doc = ""]
#[doc = " A callback method for #hb_buffer_t. The method gets called with the"]
#[doc = " #hb_buffer_t it was set on, the #hb_font_t the buffer is shaped with and a"]
#[doc = " message describing what step of the shaping process will be performed."]
#[doc = " Returning %false from this method will skip this shaping step and move to"]
#[doc = " the next one."]
#[doc = ""]
#[doc = " Return value: %true to perform the shaping step, %false to skip it."]
#[doc = ""]
#[doc = " Since: 1.1.3"]
pub type hb_buffer_message_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        buffer: *mut hb_buffer_t,
        font: *mut hb_font_t,
        message: *const ::std::os::raw::c_char,
        user_data: *mut ::std::os::raw::c_void,
    ) -> hb_bool_t,
>;
extern "C" {
    pub fn hb_buffer_set_message_func(
        buffer: *mut hb_buffer_t,
        func: hb_buffer_message_func_t,
        user_data: *mut ::std::os::raw::c_void,
        destroy: hb_destroy_func_t,
    );
}
#[doc = " hb_font_get_glyph_func_t:"]
#[doc = " @font: #hb_font_t to work upon"]
#[doc = " @font_data: @font user data pointer"]
#[doc = " @unicode: The Unicode code point to query"]
#[doc = " @variation_selector: The  variation-selector code point to query"]
#[doc = " @glyph: (out): The glyph ID retrieved"]
#[doc = " @user_data: User data pointer passed by the caller"]
#[doc = ""]
#[doc = " A virtual method for the #hb_font_funcs_t of an #hb_font_t object."]
#[doc = ""]
#[doc = " This method should retrieve the glyph ID for a specified Unicode code point"]
#[doc = " font, with an optional variation selector."]
#[doc = ""]
#[doc = " Return value: %true if data found, %false otherwise"]
#[doc = " Deprecated: 1.2.3"]
#[doc = ""]
pub type hb_font_get_glyph_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        font: *mut hb_font_t,
        font_data: *mut ::std::os::raw::c_void,
        unicode: hb_codepoint_t,
        variation_selector: hb_codepoint_t,
        glyph: *mut hb_codepoint_t,
        user_data: *mut ::std::os::raw::c_void,
    ) -> hb_bool_t,
>;
extern "C" {
    pub fn hb_font_funcs_set_glyph_func(
        ffuncs: *mut hb_font_funcs_t,
        func: hb_font_get_glyph_func_t,
        user_data: *mut ::std::os::raw::c_void,
        destroy: hb_destroy_func_t,
    );
}
#[doc = " hb_unicode_eastasian_width_func_t:"]
#[doc = " @ufuncs: A Unicode-functions structure"]
#[doc = " @unicode: The code point to query"]
#[doc = " @user_data: User data pointer passed by the caller"]
#[doc = ""]
#[doc = " A virtual method for the #hb_unicode_funcs_t structure."]
#[doc = ""]
#[doc = " Deprecated: 2.0.0"]
pub type hb_unicode_eastasian_width_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        ufuncs: *mut hb_unicode_funcs_t,
        unicode: hb_codepoint_t,
        user_data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_uint,
>;
extern "C" {
    #[doc = " hb_unicode_funcs_set_eastasian_width_func:"]
    #[doc = " @ufuncs: a Unicode-function structure"]
    #[doc = " @func: (closure user_data) (destroy destroy) (scope notified): The callback function to assign"]
    #[doc = " @user_data: Data to pass to @func"]
    #[doc = " @destroy: (nullable): The function to call when @user_data is not needed anymore"]
    #[doc = ""]
    #[doc = " Sets the implementation function for #hb_unicode_eastasian_width_func_t."]
    #[doc = ""]
    #[doc = " Since: 0.9.2"]
    #[doc = " Deprecated: 2.0.0"]
    pub fn hb_unicode_funcs_set_eastasian_width_func(
        ufuncs: *mut hb_unicode_funcs_t,
        func: hb_unicode_eastasian_width_func_t,
        user_data: *mut ::std::os::raw::c_void,
        destroy: hb_destroy_func_t,
    );
}
extern "C" {
    #[doc = " hb_unicode_eastasian_width:"]
    #[doc = " @ufuncs: a Unicode-function structure"]
    #[doc = " @unicode: The code point to query"]
    #[doc = ""]
    #[doc = " Don't use. Not used by HarfBuzz."]
    #[doc = ""]
    #[doc = " Since: 0.9.2"]
    #[doc = " Deprecated: 2.0.0"]
    pub fn hb_unicode_eastasian_width(
        ufuncs: *mut hb_unicode_funcs_t,
        unicode: hb_codepoint_t,
    ) -> ::std::os::raw::c_uint;
}
#[doc = " hb_unicode_decompose_compatibility_func_t:"]
#[doc = " @ufuncs: a Unicode function structure"]
#[doc = " @u: codepoint to decompose"]
#[doc = " @decomposed: address of codepoint array (of length #HB_UNICODE_MAX_DECOMPOSITION_LEN) to write decomposition into"]
#[doc = " @user_data: user data pointer as passed to hb_unicode_funcs_set_decompose_compatibility_func()"]
#[doc = ""]
#[doc = " Fully decompose @u to its Unicode compatibility decomposition. The codepoints of the decomposition will be written to @decomposed."]
#[doc = " The complete length of the decomposition will be returned."]
#[doc = ""]
#[doc = " If @u has no compatibility decomposition, zero should be returned."]
#[doc = ""]
#[doc = " The Unicode standard guarantees that a buffer of length #HB_UNICODE_MAX_DECOMPOSITION_LEN codepoints will always be sufficient for any"]
#[doc = " compatibility decomposition plus an terminating value of 0.  Consequently, @decompose must be allocated by the caller to be at least this length.  Implementations"]
#[doc = " of this function type must ensure that they do not write past the provided array."]
#[doc = ""]
#[doc = " Return value: number of codepoints in the full compatibility decomposition of @u, or 0 if no decomposition available."]
#[doc = ""]
#[doc = " Deprecated: 2.0.0"]
pub type hb_unicode_decompose_compatibility_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        ufuncs: *mut hb_unicode_funcs_t,
        u: hb_codepoint_t,
        decomposed: *mut hb_codepoint_t,
        user_data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_uint,
>;
extern "C" {
    #[doc = " hb_unicode_funcs_set_decompose_compatibility_func:"]
    #[doc = " @ufuncs: A Unicode-functions structure"]
    #[doc = " @func: (closure user_data) (destroy destroy) (scope notified): The callback function to assign"]
    #[doc = " @user_data: Data to pass to @func"]
    #[doc = " @destroy: (nullable): The function to call when @user_data is not needed anymore"]
    #[doc = ""]
    #[doc = " Sets the implementation function for #hb_unicode_decompose_compatibility_func_t."]
    #[doc = ""]
    #[doc = ""]
    #[doc = ""]
    #[doc = " Since: 0.9.2"]
    #[doc = " Deprecated: 2.0.0"]
    pub fn hb_unicode_funcs_set_decompose_compatibility_func(
        ufuncs: *mut hb_unicode_funcs_t,
        func: hb_unicode_decompose_compatibility_func_t,
        user_data: *mut ::std::os::raw::c_void,
        destroy: hb_destroy_func_t,
    );
}
extern "C" {
    pub fn hb_unicode_decompose_compatibility(
        ufuncs: *mut hb_unicode_funcs_t,
        u: hb_codepoint_t,
        decomposed: *mut hb_codepoint_t,
    ) -> ::std::os::raw::c_uint;
}
#[doc = " hb_font_get_glyph_v_kerning_func_t:"]
#[doc = ""]
#[doc = " A virtual method for the #hb_font_funcs_t of an #hb_font_t object."]
#[doc = ""]
#[doc = " This method should retrieve the kerning-adjustment value for a glyph-pair in"]
#[doc = " the specified font, for vertical text segments."]
#[doc = ""]
pub type hb_font_get_glyph_v_kerning_func_t = hb_font_get_glyph_kerning_func_t;
extern "C" {
    #[doc = " hb_font_funcs_set_glyph_v_kerning_func:"]
    #[doc = " @ffuncs: A font-function structure"]
    #[doc = " @func: (closure user_data) (destroy destroy) (scope notified): The callback function to assign"]
    #[doc = " @user_data: Data to pass to @func"]
    #[doc = " @destroy: (nullable): The function to call when @user_data is not needed anymore"]
    #[doc = ""]
    #[doc = " Sets the implementation function for #hb_font_get_glyph_v_kerning_func_t."]
    #[doc = ""]
    #[doc = " Since: 0.9.2"]
    #[doc = " Deprecated: 2.0.0"]
    pub fn hb_font_funcs_set_glyph_v_kerning_func(
        ffuncs: *mut hb_font_funcs_t,
        func: hb_font_get_glyph_v_kerning_func_t,
        user_data: *mut ::std::os::raw::c_void,
        destroy: hb_destroy_func_t,
    );
}
extern "C" {
    pub fn hb_font_get_glyph_v_kerning(
        font: *mut hb_font_t,
        top_glyph: hb_codepoint_t,
        bottom_glyph: hb_codepoint_t,
    ) -> hb_position_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hb_map_t {
    _unused: [u8; 0],
}
extern "C" {
    pub fn hb_map_create() -> *mut hb_map_t;
}
extern "C" {
    pub fn hb_map_get_empty() -> *mut hb_map_t;
}
extern "C" {
    pub fn hb_map_reference(map: *mut hb_map_t) -> *mut hb_map_t;
}
extern "C" {
    pub fn hb_map_destroy(map: *mut hb_map_t);
}
extern "C" {
    pub fn hb_map_set_user_data(
        map: *mut hb_map_t,
        key: *mut hb_user_data_key_t,
        data: *mut ::std::os::raw::c_void,
        destroy: hb_destroy_func_t,
        replace: hb_bool_t,
    ) -> hb_bool_t;
}
extern "C" {
    pub fn hb_map_get_user_data(
        map: *mut hb_map_t,
        key: *mut hb_user_data_key_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn hb_map_allocation_successful(map: *const hb_map_t) -> hb_bool_t;
}
extern "C" {
    pub fn hb_map_clear(map: *mut hb_map_t);
}
extern "C" {
    pub fn hb_map_is_empty(map: *const hb_map_t) -> hb_bool_t;
}
extern "C" {
    pub fn hb_map_get_population(map: *const hb_map_t) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn hb_map_is_equal(map: *const hb_map_t, other: *const hb_map_t) -> hb_bool_t;
}
extern "C" {
    pub fn hb_map_set(map: *mut hb_map_t, key: hb_codepoint_t, value: hb_codepoint_t);
}
extern "C" {
    pub fn hb_map_get(map: *const hb_map_t, key: hb_codepoint_t) -> hb_codepoint_t;
}
extern "C" {
    pub fn hb_map_del(map: *mut hb_map_t, key: hb_codepoint_t);
}
extern "C" {
    pub fn hb_map_has(map: *const hb_map_t, key: hb_codepoint_t) -> hb_bool_t;
}
extern "C" {
    pub fn hb_shape(
        font: *mut hb_font_t,
        buffer: *mut hb_buffer_t,
        features: *const hb_feature_t,
        num_features: ::std::os::raw::c_uint,
    );
}
extern "C" {
    pub fn hb_shape_full(
        font: *mut hb_font_t,
        buffer: *mut hb_buffer_t,
        features: *const hb_feature_t,
        num_features: ::std::os::raw::c_uint,
        shaper_list: *const *const ::std::os::raw::c_char,
    ) -> hb_bool_t;
}
extern "C" {
    pub fn hb_shape_list_shapers() -> *mut *const ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hb_shape_plan_t {
    _unused: [u8; 0],
}
extern "C" {
    pub fn hb_shape_plan_create(
        face: *mut hb_face_t,
        props: *const hb_segment_properties_t,
        user_features: *const hb_feature_t,
        num_user_features: ::std::os::raw::c_uint,
        shaper_list: *const *const ::std::os::raw::c_char,
    ) -> *mut hb_shape_plan_t;
}
extern "C" {
    pub fn hb_shape_plan_create_cached(
        face: *mut hb_face_t,
        props: *const hb_segment_properties_t,
        user_features: *const hb_feature_t,
        num_user_features: ::std::os::raw::c_uint,
        shaper_list: *const *const ::std::os::raw::c_char,
    ) -> *mut hb_shape_plan_t;
}
extern "C" {
    pub fn hb_shape_plan_create2(
        face: *mut hb_face_t,
        props: *const hb_segment_properties_t,
        user_features: *const hb_feature_t,
        num_user_features: ::std::os::raw::c_uint,
        coords: *const ::std::os::raw::c_int,
        num_coords: ::std::os::raw::c_uint,
        shaper_list: *const *const ::std::os::raw::c_char,
    ) -> *mut hb_shape_plan_t;
}
extern "C" {
    pub fn hb_shape_plan_create_cached2(
        face: *mut hb_face_t,
        props: *const hb_segment_properties_t,
        user_features: *const hb_feature_t,
        num_user_features: ::std::os::raw::c_uint,
        coords: *const ::std::os::raw::c_int,
        num_coords: ::std::os::raw::c_uint,
        shaper_list: *const *const ::std::os::raw::c_char,
    ) -> *mut hb_shape_plan_t;
}
extern "C" {
    pub fn hb_shape_plan_get_empty() -> *mut hb_shape_plan_t;
}
extern "C" {
    pub fn hb_shape_plan_reference(shape_plan: *mut hb_shape_plan_t) -> *mut hb_shape_plan_t;
}
extern "C" {
    pub fn hb_shape_plan_destroy(shape_plan: *mut hb_shape_plan_t);
}
extern "C" {
    pub fn hb_shape_plan_set_user_data(
        shape_plan: *mut hb_shape_plan_t,
        key: *mut hb_user_data_key_t,
        data: *mut ::std::os::raw::c_void,
        destroy: hb_destroy_func_t,
        replace: hb_bool_t,
    ) -> hb_bool_t;
}
extern "C" {
    pub fn hb_shape_plan_get_user_data(
        shape_plan: *mut hb_shape_plan_t,
        key: *mut hb_user_data_key_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn hb_shape_plan_execute(
        shape_plan: *mut hb_shape_plan_t,
        font: *mut hb_font_t,
        buffer: *mut hb_buffer_t,
        features: *const hb_feature_t,
        num_features: ::std::os::raw::c_uint,
    ) -> hb_bool_t;
}
extern "C" {
    pub fn hb_shape_plan_get_shaper(
        shape_plan: *mut hb_shape_plan_t,
    ) -> *const ::std::os::raw::c_char;
}
pub const HB_STYLE_TAG_ITALIC: hb_style_tag_t = 1769234796;
pub const HB_STYLE_TAG_OPTICAL_SIZE: hb_style_tag_t = 1869640570;
pub const HB_STYLE_TAG_SLANT_ANGLE: hb_style_tag_t = 1936486004;
pub const HB_STYLE_TAG_SLANT_RATIO: hb_style_tag_t = 1399615092;
pub const HB_STYLE_TAG_WIDTH: hb_style_tag_t = 2003072104;
pub const HB_STYLE_TAG_WEIGHT: hb_style_tag_t = 2003265652;
pub const _HB_STYLE_TAG_MAX_VALUE: hb_style_tag_t = 2147483647;
#[doc = " hb_style_tag_t:"]
#[doc = " @HB_STYLE_TAG_ITALIC: Used to vary between non-italic and italic."]
#[doc = " A value of 0 can be interpreted as \"Roman\" (non-italic); a value of 1 can"]
#[doc = " be interpreted as (fully) italic."]
#[doc = " @HB_STYLE_TAG_OPTICAL_SIZE: Used to vary design to suit different text sizes."]
#[doc = " Non-zero. Values can be interpreted as text size, in points."]
#[doc = " @HB_STYLE_TAG_SLANT_ANGLE: Used to vary between upright and slanted text. Values"]
#[doc = " must be greater than -90 and less than +90. Values can be interpreted as"]
#[doc = " the angle, in counter-clockwise degrees, of oblique slant from whatever the"]
#[doc = " designer considers to be upright for that font design. Typical right-leaning"]
#[doc = " Italic fonts have a negative slant angle (typically around -12)"]
#[doc = " @HB_STYLE_TAG_SLANT_RATIO: same as @HB_STYLE_TAG_SLANT_ANGLE expression as ratio."]
#[doc = " Typical right-leaning Italic fonts have a positive slant ratio (typically around 0.2)"]
#[doc = " @HB_STYLE_TAG_WIDTH: Used to vary width of text from narrower to wider."]
#[doc = " Non-zero. Values can be interpreted as a percentage of whatever the font"]
#[doc = " designer considers “normal width” for that font design."]
#[doc = " @HB_STYLE_TAG_WEIGHT: Used to vary stroke thicknesses or other design details"]
#[doc = " to give variation from lighter to blacker. Values can be interpreted in direct"]
#[doc = " comparison to values for usWeightClass in the OS/2 table,"]
#[doc = " or the CSS font-weight property."]
#[doc = ""]
#[doc = " Defined by [OpenType Design-Variation Axis Tag Registry](https://docs.microsoft.com/en-us/typography/opentype/spec/dvaraxisreg)."]
#[doc = ""]
#[doc = " Since: 3.0.0"]
pub type hb_style_tag_t = ::std::os::raw::c_uint;
extern "C" {
    pub fn hb_style_get_value(font: *mut hb_font_t, style_tag: hb_style_tag_t) -> ::std::os::raw::c_float;
}
extern "C" {
    pub fn hb_version(
        major: *mut ::std::os::raw::c_uint,
        minor: *mut ::std::os::raw::c_uint,
        micro: *mut ::std::os::raw::c_uint,
    );
}
extern "C" {
    pub fn hb_version_string() -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn hb_version_atleast(
        major: ::std::os::raw::c_uint,
        minor: ::std::os::raw::c_uint,
        micro: ::std::os::raw::c_uint,
    ) -> hb_bool_t;
}
pub type hb_ot_name_id_t = ::std::os::raw::c_uint;
#[doc = " hb_ot_name_entry_t:"]
#[doc = " @name_id: name ID"]
#[doc = " @language: language"]
#[doc = ""]
#[doc = " Structure representing a name ID in a particular language."]
#[doc = ""]
#[doc = " Since: 2.1.0"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct hb_ot_name_entry_t {
    pub name_id: hb_ot_name_id_t,
    pub var: hb_var_int_t,
    pub language: hb_language_t,
}
#[test]
fn bindgen_test_layout_hb_ot_name_entry_t() {
    assert_eq!(
        ::std::mem::size_of::<hb_ot_name_entry_t>(),
        16usize,
        concat!("Size of: ", stringify!(hb_ot_name_entry_t))
    );
    assert_eq!(
        ::std::mem::align_of::<hb_ot_name_entry_t>(),
        8usize,
        concat!("Alignment of ", stringify!(hb_ot_name_entry_t))
    );
    fn test_field_name_id() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<hb_ot_name_entry_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).name_id) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(hb_ot_name_entry_t),
                "::",
                stringify!(name_id)
            )
        );
    }
    test_field_name_id();
    fn test_field_var() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<hb_ot_name_entry_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).var) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(hb_ot_name_entry_t),
                "::",
                stringify!(var)
            )
        );
    }
    test_field_var();
    fn test_field_language() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<hb_ot_name_entry_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).language) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(hb_ot_name_entry_t),
                "::",
                stringify!(language)
            )
        );
    }
    test_field_language();
}
extern "C" {
    pub fn hb_ot_name_list_names(
        face: *mut hb_face_t,
        num_entries: *mut ::std::os::raw::c_uint,
    ) -> *const hb_ot_name_entry_t;
}
extern "C" {
    pub fn hb_ot_name_get_utf8(
        face: *mut hb_face_t,
        name_id: hb_ot_name_id_t,
        language: hb_language_t,
        text_size: *mut ::std::os::raw::c_uint,
        text: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn hb_ot_name_get_utf16(
        face: *mut hb_face_t,
        name_id: hb_ot_name_id_t,
        language: hb_language_t,
        text_size: *mut ::std::os::raw::c_uint,
        text: *mut u16,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn hb_ot_name_get_utf32(
        face: *mut hb_face_t,
        name_id: hb_ot_name_id_t,
        language: hb_language_t,
        text_size: *mut ::std::os::raw::c_uint,
        text: *mut u32,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn hb_ot_color_has_palettes(face: *mut hb_face_t) -> hb_bool_t;
}
extern "C" {
    pub fn hb_ot_color_palette_get_count(face: *mut hb_face_t) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn hb_ot_color_palette_get_name_id(
        face: *mut hb_face_t,
        palette_index: ::std::os::raw::c_uint,
    ) -> hb_ot_name_id_t;
}
extern "C" {
    pub fn hb_ot_color_palette_color_get_name_id(
        face: *mut hb_face_t,
        color_index: ::std::os::raw::c_uint,
    ) -> hb_ot_name_id_t;
}
pub const HB_OT_COLOR_PALETTE_FLAG_DEFAULT: hb_ot_color_palette_flags_t = 0;
pub const HB_OT_COLOR_PALETTE_FLAG_USABLE_WITH_LIGHT_BACKGROUND: hb_ot_color_palette_flags_t = 1;
pub const HB_OT_COLOR_PALETTE_FLAG_USABLE_WITH_DARK_BACKGROUND: hb_ot_color_palette_flags_t = 2;
#[doc = " hb_ot_color_palette_flags_t:"]
#[doc = " @HB_OT_COLOR_PALETTE_FLAG_DEFAULT: Default indicating that there is nothing special"]
#[doc = "   to note about a color palette."]
#[doc = " @HB_OT_COLOR_PALETTE_FLAG_USABLE_WITH_LIGHT_BACKGROUND: Flag indicating that the color"]
#[doc = "   palette is appropriate to use when displaying the font on a light background such as white."]
#[doc = " @HB_OT_COLOR_PALETTE_FLAG_USABLE_WITH_DARK_BACKGROUND: Flag indicating that the color"]
#[doc = "   palette is appropriate to use when displaying the font on a dark background such as black."]
#[doc = ""]
#[doc = " Flags that describe the properties of color palette."]
#[doc = ""]
#[doc = " Since: 2.1.0"]
pub type hb_ot_color_palette_flags_t = ::std::os::raw::c_uint;
extern "C" {
    pub fn hb_ot_color_palette_get_flags(
        face: *mut hb_face_t,
        palette_index: ::std::os::raw::c_uint,
    ) -> hb_ot_color_palette_flags_t;
}
extern "C" {
    pub fn hb_ot_color_palette_get_colors(
        face: *mut hb_face_t,
        palette_index: ::std::os::raw::c_uint,
        start_offset: ::std::os::raw::c_uint,
        color_count: *mut ::std::os::raw::c_uint,
        colors: *mut hb_color_t,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn hb_ot_color_has_layers(face: *mut hb_face_t) -> hb_bool_t;
}
#[doc = " hb_ot_color_layer_t:"]
#[doc = " @glyph: the glyph ID of the layer"]
#[doc = " @color_index: the palette color index of the layer"]
#[doc = ""]
#[doc = " Pairs of glyph and color index."]
#[doc = ""]
#[doc = " Since: 2.1.0"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hb_ot_color_layer_t {
    pub glyph: hb_codepoint_t,
    pub color_index: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_hb_ot_color_layer_t() {
    assert_eq!(
        ::std::mem::size_of::<hb_ot_color_layer_t>(),
        8usize,
        concat!("Size of: ", stringify!(hb_ot_color_layer_t))
    );
    assert_eq!(
        ::std::mem::align_of::<hb_ot_color_layer_t>(),
        4usize,
        concat!("Alignment of ", stringify!(hb_ot_color_layer_t))
    );
    fn test_field_glyph() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<hb_ot_color_layer_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).glyph) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(hb_ot_color_layer_t),
                "::",
                stringify!(glyph)
            )
        );
    }
    test_field_glyph();
    fn test_field_color_index() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<hb_ot_color_layer_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).color_index) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(hb_ot_color_layer_t),
                "::",
                stringify!(color_index)
            )
        );
    }
    test_field_color_index();
}
extern "C" {
    pub fn hb_ot_color_glyph_get_layers(
        face: *mut hb_face_t,
        glyph: hb_codepoint_t,
        start_offset: ::std::os::raw::c_uint,
        layer_count: *mut ::std::os::raw::c_uint,
        layers: *mut hb_ot_color_layer_t,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn hb_ot_color_has_svg(face: *mut hb_face_t) -> hb_bool_t;
}
extern "C" {
    pub fn hb_ot_color_glyph_reference_svg(
        face: *mut hb_face_t,
        glyph: hb_codepoint_t,
    ) -> *mut hb_blob_t;
}
extern "C" {
    pub fn hb_ot_color_has_png(face: *mut hb_face_t) -> hb_bool_t;
}
extern "C" {
    pub fn hb_ot_color_glyph_reference_png(
        font: *mut hb_font_t,
        glyph: hb_codepoint_t,
    ) -> *mut hb_blob_t;
}
extern "C" {
    pub fn hb_ot_layout_table_choose_script(
        face: *mut hb_face_t,
        table_tag: hb_tag_t,
        script_tags: *const hb_tag_t,
        script_index: *mut ::std::os::raw::c_uint,
        chosen_script: *mut hb_tag_t,
    ) -> hb_bool_t;
}
extern "C" {
    pub fn hb_ot_layout_script_find_language(
        face: *mut hb_face_t,
        table_tag: hb_tag_t,
        script_index: ::std::os::raw::c_uint,
        language_tag: hb_tag_t,
        language_index: *mut ::std::os::raw::c_uint,
    ) -> hb_bool_t;
}
extern "C" {
    pub fn hb_ot_tags_from_script(
        script: hb_script_t,
        script_tag_1: *mut hb_tag_t,
        script_tag_2: *mut hb_tag_t,
    );
}
extern "C" {
    pub fn hb_ot_tag_from_language(language: hb_language_t) -> hb_tag_t;
}
#[doc = " hb_ot_var_axis_t:"]
#[doc = " @tag: axis tag"]
#[doc = " @name_id: axis name identifier"]
#[doc = " @min_value: minimum value of the axis"]
#[doc = " @default_value: default value of the axis"]
#[doc = " @max_value: maximum value of the axis"]
#[doc = ""]
#[doc = " Use #hb_ot_var_axis_info_t instead."]
#[doc = ""]
#[doc = " Since: 1.4.2"]
#[doc = " Deprecated: 2.2.0"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hb_ot_var_axis_t {
    pub tag: hb_tag_t,
    pub name_id: hb_ot_name_id_t,
    pub min_value: ::std::os::raw::c_float,
    pub default_value: ::std::os::raw::c_float,
    pub max_value: ::std::os::raw::c_float,
}
#[test]
fn bindgen_test_layout_hb_ot_var_axis_t() {
    assert_eq!(
        ::std::mem::size_of::<hb_ot_var_axis_t>(),
        20usize,
        concat!("Size of: ", stringify!(hb_ot_var_axis_t))
    );
    assert_eq!(
        ::std::mem::align_of::<hb_ot_var_axis_t>(),
        4usize,
        concat!("Alignment of ", stringify!(hb_ot_var_axis_t))
    );
    fn test_field_tag() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<hb_ot_var_axis_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tag) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(hb_ot_var_axis_t),
                "::",
                stringify!(tag)
            )
        );
    }
    test_field_tag();
    fn test_field_name_id() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<hb_ot_var_axis_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).name_id) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(hb_ot_var_axis_t),
                "::",
                stringify!(name_id)
            )
        );
    }
    test_field_name_id();
    fn test_field_min_value() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<hb_ot_var_axis_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).min_value) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(hb_ot_var_axis_t),
                "::",
                stringify!(min_value)
            )
        );
    }
    test_field_min_value();
    fn test_field_default_value() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<hb_ot_var_axis_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).default_value) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(hb_ot_var_axis_t),
                "::",
                stringify!(default_value)
            )
        );
    }
    test_field_default_value();
    fn test_field_max_value() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<hb_ot_var_axis_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).max_value) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(hb_ot_var_axis_t),
                "::",
                stringify!(max_value)
            )
        );
    }
    test_field_max_value();
}
extern "C" {
    pub fn hb_ot_var_get_axes(
        face: *mut hb_face_t,
        start_offset: ::std::os::raw::c_uint,
        axes_count: *mut ::std::os::raw::c_uint,
        axes_array: *mut hb_ot_var_axis_t,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn hb_ot_var_find_axis(
        face: *mut hb_face_t,
        axis_tag: hb_tag_t,
        axis_index: *mut ::std::os::raw::c_uint,
        axis_info: *mut hb_ot_var_axis_t,
    ) -> hb_bool_t;
}
extern "C" {
    pub fn hb_ot_font_set_funcs(font: *mut hb_font_t);
}
extern "C" {
    pub fn hb_ot_tags_from_script_and_language(
        script: hb_script_t,
        language: hb_language_t,
        script_count: *mut ::std::os::raw::c_uint,
        script_tags: *mut hb_tag_t,
        language_count: *mut ::std::os::raw::c_uint,
        language_tags: *mut hb_tag_t,
    );
}
extern "C" {
    pub fn hb_ot_tag_to_script(tag: hb_tag_t) -> hb_script_t;
}
extern "C" {
    pub fn hb_ot_tag_to_language(tag: hb_tag_t) -> hb_language_t;
}
extern "C" {
    pub fn hb_ot_tags_to_script_and_language(
        script_tag: hb_tag_t,
        language_tag: hb_tag_t,
        script: *mut hb_script_t,
        language: *mut hb_language_t,
    );
}
extern "C" {
    pub fn hb_ot_layout_has_glyph_classes(face: *mut hb_face_t) -> hb_bool_t;
}
pub const HB_OT_LAYOUT_GLYPH_CLASS_UNCLASSIFIED: hb_ot_layout_glyph_class_t = 0;
pub const HB_OT_LAYOUT_GLYPH_CLASS_BASE_GLYPH: hb_ot_layout_glyph_class_t = 1;
pub const HB_OT_LAYOUT_GLYPH_CLASS_LIGATURE: hb_ot_layout_glyph_class_t = 2;
pub const HB_OT_LAYOUT_GLYPH_CLASS_MARK: hb_ot_layout_glyph_class_t = 3;
pub const HB_OT_LAYOUT_GLYPH_CLASS_COMPONENT: hb_ot_layout_glyph_class_t = 4;
#[doc = " hb_ot_layout_glyph_class_t:"]
#[doc = " @HB_OT_LAYOUT_GLYPH_CLASS_UNCLASSIFIED: Glyphs not matching the other classifications"]
#[doc = " @HB_OT_LAYOUT_GLYPH_CLASS_BASE_GLYPH: Spacing, single characters, capable of accepting marks"]
#[doc = " @HB_OT_LAYOUT_GLYPH_CLASS_LIGATURE: Glyphs that represent ligation of multiple characters"]
#[doc = " @HB_OT_LAYOUT_GLYPH_CLASS_MARK: Non-spacing, combining glyphs that represent marks"]
#[doc = " @HB_OT_LAYOUT_GLYPH_CLASS_COMPONENT: Spacing glyphs that represent part of a single character"]
#[doc = ""]
#[doc = " The GDEF classes defined for glyphs."]
#[doc = ""]
pub type hb_ot_layout_glyph_class_t = ::std::os::raw::c_uint;
extern "C" {
    pub fn hb_ot_layout_get_glyph_class(
        face: *mut hb_face_t,
        glyph: hb_codepoint_t,
    ) -> hb_ot_layout_glyph_class_t;
}
extern "C" {
    pub fn hb_ot_layout_get_glyphs_in_class(
        face: *mut hb_face_t,
        klass: hb_ot_layout_glyph_class_t,
        glyphs: *mut hb_set_t,
    );
}
extern "C" {
    pub fn hb_ot_layout_get_attach_points(
        face: *mut hb_face_t,
        glyph: hb_codepoint_t,
        start_offset: ::std::os::raw::c_uint,
        point_count: *mut ::std::os::raw::c_uint,
        point_array: *mut ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn hb_ot_layout_get_ligature_carets(
        font: *mut hb_font_t,
        direction: hb_direction_t,
        glyph: hb_codepoint_t,
        start_offset: ::std::os::raw::c_uint,
        caret_count: *mut ::std::os::raw::c_uint,
        caret_array: *mut hb_position_t,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn hb_ot_layout_table_get_script_tags(
        face: *mut hb_face_t,
        table_tag: hb_tag_t,
        start_offset: ::std::os::raw::c_uint,
        script_count: *mut ::std::os::raw::c_uint,
        script_tags: *mut hb_tag_t,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn hb_ot_layout_table_find_script(
        face: *mut hb_face_t,
        table_tag: hb_tag_t,
        script_tag: hb_tag_t,
        script_index: *mut ::std::os::raw::c_uint,
    ) -> hb_bool_t;
}
extern "C" {
    pub fn hb_ot_layout_table_select_script(
        face: *mut hb_face_t,
        table_tag: hb_tag_t,
        script_count: ::std::os::raw::c_uint,
        script_tags: *const hb_tag_t,
        script_index: *mut ::std::os::raw::c_uint,
        chosen_script: *mut hb_tag_t,
    ) -> hb_bool_t;
}
extern "C" {
    pub fn hb_ot_layout_table_get_feature_tags(
        face: *mut hb_face_t,
        table_tag: hb_tag_t,
        start_offset: ::std::os::raw::c_uint,
        feature_count: *mut ::std::os::raw::c_uint,
        feature_tags: *mut hb_tag_t,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn hb_ot_layout_script_get_language_tags(
        face: *mut hb_face_t,
        table_tag: hb_tag_t,
        script_index: ::std::os::raw::c_uint,
        start_offset: ::std::os::raw::c_uint,
        language_count: *mut ::std::os::raw::c_uint,
        language_tags: *mut hb_tag_t,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn hb_ot_layout_script_select_language(
        face: *mut hb_face_t,
        table_tag: hb_tag_t,
        script_index: ::std::os::raw::c_uint,
        language_count: ::std::os::raw::c_uint,
        language_tags: *const hb_tag_t,
        language_index: *mut ::std::os::raw::c_uint,
    ) -> hb_bool_t;
}
extern "C" {
    pub fn hb_ot_layout_language_get_required_feature_index(
        face: *mut hb_face_t,
        table_tag: hb_tag_t,
        script_index: ::std::os::raw::c_uint,
        language_index: ::std::os::raw::c_uint,
        feature_index: *mut ::std::os::raw::c_uint,
    ) -> hb_bool_t;
}
extern "C" {
    pub fn hb_ot_layout_language_get_required_feature(
        face: *mut hb_face_t,
        table_tag: hb_tag_t,
        script_index: ::std::os::raw::c_uint,
        language_index: ::std::os::raw::c_uint,
        feature_index: *mut ::std::os::raw::c_uint,
        feature_tag: *mut hb_tag_t,
    ) -> hb_bool_t;
}
extern "C" {
    pub fn hb_ot_layout_language_get_feature_indexes(
        face: *mut hb_face_t,
        table_tag: hb_tag_t,
        script_index: ::std::os::raw::c_uint,
        language_index: ::std::os::raw::c_uint,
        start_offset: ::std::os::raw::c_uint,
        feature_count: *mut ::std::os::raw::c_uint,
        feature_indexes: *mut ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn hb_ot_layout_language_get_feature_tags(
        face: *mut hb_face_t,
        table_tag: hb_tag_t,
        script_index: ::std::os::raw::c_uint,
        language_index: ::std::os::raw::c_uint,
        start_offset: ::std::os::raw::c_uint,
        feature_count: *mut ::std::os::raw::c_uint,
        feature_tags: *mut hb_tag_t,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn hb_ot_layout_language_find_feature(
        face: *mut hb_face_t,
        table_tag: hb_tag_t,
        script_index: ::std::os::raw::c_uint,
        language_index: ::std::os::raw::c_uint,
        feature_tag: hb_tag_t,
        feature_index: *mut ::std::os::raw::c_uint,
    ) -> hb_bool_t;
}
extern "C" {
    pub fn hb_ot_layout_feature_get_lookups(
        face: *mut hb_face_t,
        table_tag: hb_tag_t,
        feature_index: ::std::os::raw::c_uint,
        start_offset: ::std::os::raw::c_uint,
        lookup_count: *mut ::std::os::raw::c_uint,
        lookup_indexes: *mut ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn hb_ot_layout_table_get_lookup_count(
        face: *mut hb_face_t,
        table_tag: hb_tag_t,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn hb_ot_layout_collect_features(
        face: *mut hb_face_t,
        table_tag: hb_tag_t,
        scripts: *const hb_tag_t,
        languages: *const hb_tag_t,
        features: *const hb_tag_t,
        feature_indexes: *mut hb_set_t,
    );
}
extern "C" {
    pub fn hb_ot_layout_collect_lookups(
        face: *mut hb_face_t,
        table_tag: hb_tag_t,
        scripts: *const hb_tag_t,
        languages: *const hb_tag_t,
        features: *const hb_tag_t,
        lookup_indexes: *mut hb_set_t,
    );
}
extern "C" {
    pub fn hb_ot_layout_lookup_collect_glyphs(
        face: *mut hb_face_t,
        table_tag: hb_tag_t,
        lookup_index: ::std::os::raw::c_uint,
        glyphs_before: *mut hb_set_t,
        glyphs_input: *mut hb_set_t,
        glyphs_after: *mut hb_set_t,
        glyphs_output: *mut hb_set_t,
    );
}
extern "C" {
    pub fn hb_ot_layout_table_find_feature_variations(
        face: *mut hb_face_t,
        table_tag: hb_tag_t,
        coords: *const ::std::os::raw::c_int,
        num_coords: ::std::os::raw::c_uint,
        variations_index: *mut ::std::os::raw::c_uint,
    ) -> hb_bool_t;
}
extern "C" {
    pub fn hb_ot_layout_feature_with_variations_get_lookups(
        face: *mut hb_face_t,
        table_tag: hb_tag_t,
        feature_index: ::std::os::raw::c_uint,
        variations_index: ::std::os::raw::c_uint,
        start_offset: ::std::os::raw::c_uint,
        lookup_count: *mut ::std::os::raw::c_uint,
        lookup_indexes: *mut ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn hb_ot_layout_has_substitution(face: *mut hb_face_t) -> hb_bool_t;
}
extern "C" {
    pub fn hb_ot_layout_lookup_get_glyph_alternates(
        face: *mut hb_face_t,
        lookup_index: ::std::os::raw::c_uint,
        glyph: hb_codepoint_t,
        start_offset: ::std::os::raw::c_uint,
        alternate_count: *mut ::std::os::raw::c_uint,
        alternate_glyphs: *mut hb_codepoint_t,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn hb_ot_layout_lookup_would_substitute(
        face: *mut hb_face_t,
        lookup_index: ::std::os::raw::c_uint,
        glyphs: *const hb_codepoint_t,
        glyphs_length: ::std::os::raw::c_uint,
        zero_context: hb_bool_t,
    ) -> hb_bool_t;
}
extern "C" {
    pub fn hb_ot_layout_lookup_substitute_closure(
        face: *mut hb_face_t,
        lookup_index: ::std::os::raw::c_uint,
        glyphs: *mut hb_set_t,
    );
}
extern "C" {
    pub fn hb_ot_layout_lookups_substitute_closure(
        face: *mut hb_face_t,
        lookups: *const hb_set_t,
        glyphs: *mut hb_set_t,
    );
}
extern "C" {
    pub fn hb_ot_layout_has_positioning(face: *mut hb_face_t) -> hb_bool_t;
}
extern "C" {
    pub fn hb_ot_layout_get_size_params(
        face: *mut hb_face_t,
        design_size: *mut ::std::os::raw::c_uint,
        subfamily_id: *mut ::std::os::raw::c_uint,
        subfamily_name_id: *mut hb_ot_name_id_t,
        range_start: *mut ::std::os::raw::c_uint,
        range_end: *mut ::std::os::raw::c_uint,
    ) -> hb_bool_t;
}
extern "C" {
    pub fn hb_ot_layout_feature_get_name_ids(
        face: *mut hb_face_t,
        table_tag: hb_tag_t,
        feature_index: ::std::os::raw::c_uint,
        label_id: *mut hb_ot_name_id_t,
        tooltip_id: *mut hb_ot_name_id_t,
        sample_id: *mut hb_ot_name_id_t,
        num_named_parameters: *mut ::std::os::raw::c_uint,
        first_param_id: *mut hb_ot_name_id_t,
    ) -> hb_bool_t;
}
extern "C" {
    pub fn hb_ot_layout_feature_get_characters(
        face: *mut hb_face_t,
        table_tag: hb_tag_t,
        feature_index: ::std::os::raw::c_uint,
        start_offset: ::std::os::raw::c_uint,
        char_count: *mut ::std::os::raw::c_uint,
        characters: *mut hb_codepoint_t,
    ) -> ::std::os::raw::c_uint;
}
pub const HB_OT_LAYOUT_BASELINE_TAG_ROMAN: hb_ot_layout_baseline_tag_t = 1919905134;
pub const HB_OT_LAYOUT_BASELINE_TAG_HANGING: hb_ot_layout_baseline_tag_t = 1751215719;
pub const HB_OT_LAYOUT_BASELINE_TAG_IDEO_FACE_BOTTOM_OR_LEFT: hb_ot_layout_baseline_tag_t =
    1768121954;
pub const HB_OT_LAYOUT_BASELINE_TAG_IDEO_FACE_TOP_OR_RIGHT: hb_ot_layout_baseline_tag_t =
    1768121972;
pub const HB_OT_LAYOUT_BASELINE_TAG_IDEO_FACE_CENTRAL: hb_ot_layout_baseline_tag_t = 1231251043;
pub const HB_OT_LAYOUT_BASELINE_TAG_IDEO_EMBOX_BOTTOM_OR_LEFT: hb_ot_layout_baseline_tag_t =
    1768187247;
pub const HB_OT_LAYOUT_BASELINE_TAG_IDEO_EMBOX_TOP_OR_RIGHT: hb_ot_layout_baseline_tag_t =
    1768191088;
pub const HB_OT_LAYOUT_BASELINE_TAG_IDEO_EMBOX_CENTRAL: hb_ot_layout_baseline_tag_t = 1231315813;
pub const HB_OT_LAYOUT_BASELINE_TAG_MATH: hb_ot_layout_baseline_tag_t = 1835103336;
pub const _HB_OT_LAYOUT_BASELINE_TAG_MAX_VALUE: hb_ot_layout_baseline_tag_t = 2147483647;
#[doc = " hb_ot_layout_baseline_tag_t:"]
#[doc = " @HB_OT_LAYOUT_BASELINE_TAG_ROMAN: The baseline used by alphabetic scripts such as Latin, Cyrillic and Greek."]
#[doc = " In vertical writing mode, the alphabetic baseline for characters rotated 90 degrees clockwise."]
#[doc = " (This would not apply to alphabetic characters that remain upright in vertical writing mode, since these"]
#[doc = " characters are not rotated.)"]
#[doc = " @HB_OT_LAYOUT_BASELINE_TAG_HANGING: The hanging baseline. In horizontal direction, this is the horizontal"]
#[doc = " line from which syllables seem, to hang in Tibetan and other similar scripts. In vertical writing mode,"]
#[doc = " for Tibetan (or some other similar script) characters rotated 90 degrees clockwise."]
#[doc = " @HB_OT_LAYOUT_BASELINE_TAG_IDEO_FACE_BOTTOM_OR_LEFT: Ideographic character face bottom or left edge,"]
#[doc = " if the direction is horizontal or vertical, respectively."]
#[doc = " @HB_OT_LAYOUT_BASELINE_TAG_IDEO_FACE_TOP_OR_RIGHT: Ideographic character face top or right edge,"]
#[doc = " if the direction is horizontal or vertical, respectively."]
#[doc = " @HB_OT_LAYOUT_BASELINE_TAG_IDEO_FACE_CENTRAL: The center of the ideographic character face. Since: 4.0.0"]
#[doc = " @HB_OT_LAYOUT_BASELINE_TAG_IDEO_EMBOX_BOTTOM_OR_LEFT: Ideographic em-box bottom or left edge,"]
#[doc = " if the direction is horizontal or vertical, respectively."]
#[doc = " @HB_OT_LAYOUT_BASELINE_TAG_IDEO_EMBOX_TOP_OR_RIGHT: Ideographic em-box top or right edge baseline,"]
#[doc = " @HB_OT_LAYOUT_BASELINE_TAG_IDEO_EMBOX_CENTRAL: The center of the ideographic em-box. Since: 4.0.0"]
#[doc = " if the direction is horizontal or vertical, respectively."]
#[doc = " @HB_OT_LAYOUT_BASELINE_TAG_MATH: The baseline about which mathematical characters are centered."]
#[doc = " In vertical writing mode when mathematical characters rotated 90 degrees clockwise, are centered."]
#[doc = ""]
#[doc = " Baseline tags from [Baseline Tags](https://docs.microsoft.com/en-us/typography/opentype/spec/baselinetags) registry."]
#[doc = ""]
#[doc = " Since: 2.6.0"]
pub type hb_ot_layout_baseline_tag_t = ::std::os::raw::c_uint;
extern "C" {
    pub fn hb_ot_layout_get_horizontal_baseline_tag_for_script(
        script: hb_script_t,
    ) -> hb_ot_layout_baseline_tag_t;
}
extern "C" {
    pub fn hb_ot_layout_get_baseline(
        font: *mut hb_font_t,
        baseline_tag: hb_ot_layout_baseline_tag_t,
        direction: hb_direction_t,
        script_tag: hb_tag_t,
        language_tag: hb_tag_t,
        coord: *mut hb_position_t,
    ) -> hb_bool_t;
}
extern "C" {
    pub fn hb_ot_layout_get_baseline_with_fallback(
        font: *mut hb_font_t,
        baseline_tag: hb_ot_layout_baseline_tag_t,
        direction: hb_direction_t,
        script_tag: hb_tag_t,
        language_tag: hb_tag_t,
        coord: *mut hb_position_t,
    );
}
pub const HB_OT_MATH_CONSTANT_SCRIPT_PERCENT_SCALE_DOWN: hb_ot_math_constant_t = 0;
pub const HB_OT_MATH_CONSTANT_SCRIPT_SCRIPT_PERCENT_SCALE_DOWN: hb_ot_math_constant_t = 1;
pub const HB_OT_MATH_CONSTANT_DELIMITED_SUB_FORMULA_MIN_HEIGHT: hb_ot_math_constant_t = 2;
pub const HB_OT_MATH_CONSTANT_DISPLAY_OPERATOR_MIN_HEIGHT: hb_ot_math_constant_t = 3;
pub const HB_OT_MATH_CONSTANT_MATH_LEADING: hb_ot_math_constant_t = 4;
pub const HB_OT_MATH_CONSTANT_AXIS_HEIGHT: hb_ot_math_constant_t = 5;
pub const HB_OT_MATH_CONSTANT_ACCENT_BASE_HEIGHT: hb_ot_math_constant_t = 6;
pub const HB_OT_MATH_CONSTANT_FLATTENED_ACCENT_BASE_HEIGHT: hb_ot_math_constant_t = 7;
pub const HB_OT_MATH_CONSTANT_SUBSCRIPT_SHIFT_DOWN: hb_ot_math_constant_t = 8;
pub const HB_OT_MATH_CONSTANT_SUBSCRIPT_TOP_MAX: hb_ot_math_constant_t = 9;
pub const HB_OT_MATH_CONSTANT_SUBSCRIPT_BASELINE_DROP_MIN: hb_ot_math_constant_t = 10;
pub const HB_OT_MATH_CONSTANT_SUPERSCRIPT_SHIFT_UP: hb_ot_math_constant_t = 11;
pub const HB_OT_MATH_CONSTANT_SUPERSCRIPT_SHIFT_UP_CRAMPED: hb_ot_math_constant_t = 12;
pub const HB_OT_MATH_CONSTANT_SUPERSCRIPT_BOTTOM_MIN: hb_ot_math_constant_t = 13;
pub const HB_OT_MATH_CONSTANT_SUPERSCRIPT_BASELINE_DROP_MAX: hb_ot_math_constant_t = 14;
pub const HB_OT_MATH_CONSTANT_SUB_SUPERSCRIPT_GAP_MIN: hb_ot_math_constant_t = 15;
pub const HB_OT_MATH_CONSTANT_SUPERSCRIPT_BOTTOM_MAX_WITH_SUBSCRIPT: hb_ot_math_constant_t = 16;
pub const HB_OT_MATH_CONSTANT_SPACE_AFTER_SCRIPT: hb_ot_math_constant_t = 17;
pub const HB_OT_MATH_CONSTANT_UPPER_LIMIT_GAP_MIN: hb_ot_math_constant_t = 18;
pub const HB_OT_MATH_CONSTANT_UPPER_LIMIT_BASELINE_RISE_MIN: hb_ot_math_constant_t = 19;
pub const HB_OT_MATH_CONSTANT_LOWER_LIMIT_GAP_MIN: hb_ot_math_constant_t = 20;
pub const HB_OT_MATH_CONSTANT_LOWER_LIMIT_BASELINE_DROP_MIN: hb_ot_math_constant_t = 21;
pub const HB_OT_MATH_CONSTANT_STACK_TOP_SHIFT_UP: hb_ot_math_constant_t = 22;
pub const HB_OT_MATH_CONSTANT_STACK_TOP_DISPLAY_STYLE_SHIFT_UP: hb_ot_math_constant_t = 23;
pub const HB_OT_MATH_CONSTANT_STACK_BOTTOM_SHIFT_DOWN: hb_ot_math_constant_t = 24;
pub const HB_OT_MATH_CONSTANT_STACK_BOTTOM_DISPLAY_STYLE_SHIFT_DOWN: hb_ot_math_constant_t = 25;
pub const HB_OT_MATH_CONSTANT_STACK_GAP_MIN: hb_ot_math_constant_t = 26;
pub const HB_OT_MATH_CONSTANT_STACK_DISPLAY_STYLE_GAP_MIN: hb_ot_math_constant_t = 27;
pub const HB_OT_MATH_CONSTANT_STRETCH_STACK_TOP_SHIFT_UP: hb_ot_math_constant_t = 28;
pub const HB_OT_MATH_CONSTANT_STRETCH_STACK_BOTTOM_SHIFT_DOWN: hb_ot_math_constant_t = 29;
pub const HB_OT_MATH_CONSTANT_STRETCH_STACK_GAP_ABOVE_MIN: hb_ot_math_constant_t = 30;
pub const HB_OT_MATH_CONSTANT_STRETCH_STACK_GAP_BELOW_MIN: hb_ot_math_constant_t = 31;
pub const HB_OT_MATH_CONSTANT_FRACTION_NUMERATOR_SHIFT_UP: hb_ot_math_constant_t = 32;
pub const HB_OT_MATH_CONSTANT_FRACTION_NUMERATOR_DISPLAY_STYLE_SHIFT_UP: hb_ot_math_constant_t = 33;
pub const HB_OT_MATH_CONSTANT_FRACTION_DENOMINATOR_SHIFT_DOWN: hb_ot_math_constant_t = 34;
pub const HB_OT_MATH_CONSTANT_FRACTION_DENOMINATOR_DISPLAY_STYLE_SHIFT_DOWN: hb_ot_math_constant_t =
    35;
pub const HB_OT_MATH_CONSTANT_FRACTION_NUMERATOR_GAP_MIN: hb_ot_math_constant_t = 36;
pub const HB_OT_MATH_CONSTANT_FRACTION_NUM_DISPLAY_STYLE_GAP_MIN: hb_ot_math_constant_t = 37;
pub const HB_OT_MATH_CONSTANT_FRACTION_RULE_THICKNESS: hb_ot_math_constant_t = 38;
pub const HB_OT_MATH_CONSTANT_FRACTION_DENOMINATOR_GAP_MIN: hb_ot_math_constant_t = 39;
pub const HB_OT_MATH_CONSTANT_FRACTION_DENOM_DISPLAY_STYLE_GAP_MIN: hb_ot_math_constant_t = 40;
pub const HB_OT_MATH_CONSTANT_SKEWED_FRACTION_HORIZONTAL_GAP: hb_ot_math_constant_t = 41;
pub const HB_OT_MATH_CONSTANT_SKEWED_FRACTION_VERTICAL_GAP: hb_ot_math_constant_t = 42;
pub const HB_OT_MATH_CONSTANT_OVERBAR_VERTICAL_GAP: hb_ot_math_constant_t = 43;
pub const HB_OT_MATH_CONSTANT_OVERBAR_RULE_THICKNESS: hb_ot_math_constant_t = 44;
pub const HB_OT_MATH_CONSTANT_OVERBAR_EXTRA_ASCENDER: hb_ot_math_constant_t = 45;
pub const HB_OT_MATH_CONSTANT_UNDERBAR_VERTICAL_GAP: hb_ot_math_constant_t = 46;
pub const HB_OT_MATH_CONSTANT_UNDERBAR_RULE_THICKNESS: hb_ot_math_constant_t = 47;
pub const HB_OT_MATH_CONSTANT_UNDERBAR_EXTRA_DESCENDER: hb_ot_math_constant_t = 48;
pub const HB_OT_MATH_CONSTANT_RADICAL_VERTICAL_GAP: hb_ot_math_constant_t = 49;
pub const HB_OT_MATH_CONSTANT_RADICAL_DISPLAY_STYLE_VERTICAL_GAP: hb_ot_math_constant_t = 50;
pub const HB_OT_MATH_CONSTANT_RADICAL_RULE_THICKNESS: hb_ot_math_constant_t = 51;
pub const HB_OT_MATH_CONSTANT_RADICAL_EXTRA_ASCENDER: hb_ot_math_constant_t = 52;
pub const HB_OT_MATH_CONSTANT_RADICAL_KERN_BEFORE_DEGREE: hb_ot_math_constant_t = 53;
pub const HB_OT_MATH_CONSTANT_RADICAL_KERN_AFTER_DEGREE: hb_ot_math_constant_t = 54;
pub const HB_OT_MATH_CONSTANT_RADICAL_DEGREE_BOTTOM_RAISE_PERCENT: hb_ot_math_constant_t = 55;
#[doc = " hb_ot_math_constant_t:"]
#[doc = " @HB_OT_MATH_CONSTANT_SCRIPT_PERCENT_SCALE_DOWN: scriptPercentScaleDown"]
#[doc = " @HB_OT_MATH_CONSTANT_SCRIPT_SCRIPT_PERCENT_SCALE_DOWN: scriptScriptPercentScaleDown"]
#[doc = " @HB_OT_MATH_CONSTANT_DELIMITED_SUB_FORMULA_MIN_HEIGHT: delimitedSubFormulaMinHeight"]
#[doc = " @HB_OT_MATH_CONSTANT_DISPLAY_OPERATOR_MIN_HEIGHT: displayOperatorMinHeight"]
#[doc = " @HB_OT_MATH_CONSTANT_MATH_LEADING: mathLeading"]
#[doc = " @HB_OT_MATH_CONSTANT_AXIS_HEIGHT: axisHeight"]
#[doc = " @HB_OT_MATH_CONSTANT_ACCENT_BASE_HEIGHT: accentBaseHeight"]
#[doc = " @HB_OT_MATH_CONSTANT_FLATTENED_ACCENT_BASE_HEIGHT: flattenedAccentBaseHeight"]
#[doc = " @HB_OT_MATH_CONSTANT_SUBSCRIPT_SHIFT_DOWN: subscriptShiftDown"]
#[doc = " @HB_OT_MATH_CONSTANT_SUBSCRIPT_TOP_MAX: subscriptTopMax"]
#[doc = " @HB_OT_MATH_CONSTANT_SUBSCRIPT_BASELINE_DROP_MIN: subscriptBaselineDropMin"]
#[doc = " @HB_OT_MATH_CONSTANT_SUPERSCRIPT_SHIFT_UP: superscriptShiftUp"]
#[doc = " @HB_OT_MATH_CONSTANT_SUPERSCRIPT_SHIFT_UP_CRAMPED: superscriptShiftUpCramped"]
#[doc = " @HB_OT_MATH_CONSTANT_SUPERSCRIPT_BOTTOM_MIN: superscriptBottomMin"]
#[doc = " @HB_OT_MATH_CONSTANT_SUPERSCRIPT_BASELINE_DROP_MAX: superscriptBaselineDropMax"]
#[doc = " @HB_OT_MATH_CONSTANT_SUB_SUPERSCRIPT_GAP_MIN: subSuperscriptGapMin"]
#[doc = " @HB_OT_MATH_CONSTANT_SUPERSCRIPT_BOTTOM_MAX_WITH_SUBSCRIPT: superscriptBottomMaxWithSubscript"]
#[doc = " @HB_OT_MATH_CONSTANT_SPACE_AFTER_SCRIPT: spaceAfterScript"]
#[doc = " @HB_OT_MATH_CONSTANT_UPPER_LIMIT_GAP_MIN: upperLimitGapMin"]
#[doc = " @HB_OT_MATH_CONSTANT_UPPER_LIMIT_BASELINE_RISE_MIN: upperLimitBaselineRiseMin"]
#[doc = " @HB_OT_MATH_CONSTANT_LOWER_LIMIT_GAP_MIN: lowerLimitGapMin"]
#[doc = " @HB_OT_MATH_CONSTANT_LOWER_LIMIT_BASELINE_DROP_MIN: lowerLimitBaselineDropMin"]
#[doc = " @HB_OT_MATH_CONSTANT_STACK_TOP_SHIFT_UP: stackTopShiftUp"]
#[doc = " @HB_OT_MATH_CONSTANT_STACK_TOP_DISPLAY_STYLE_SHIFT_UP: stackTopDisplayStyleShiftUp"]
#[doc = " @HB_OT_MATH_CONSTANT_STACK_BOTTOM_SHIFT_DOWN: stackBottomShiftDown"]
#[doc = " @HB_OT_MATH_CONSTANT_STACK_BOTTOM_DISPLAY_STYLE_SHIFT_DOWN: stackBottomDisplayStyleShiftDown"]
#[doc = " @HB_OT_MATH_CONSTANT_STACK_GAP_MIN: stackGapMin"]
#[doc = " @HB_OT_MATH_CONSTANT_STACK_DISPLAY_STYLE_GAP_MIN: stackDisplayStyleGapMin"]
#[doc = " @HB_OT_MATH_CONSTANT_STRETCH_STACK_TOP_SHIFT_UP: stretchStackTopShiftUp"]
#[doc = " @HB_OT_MATH_CONSTANT_STRETCH_STACK_BOTTOM_SHIFT_DOWN: stretchStackBottomShiftDown"]
#[doc = " @HB_OT_MATH_CONSTANT_STRETCH_STACK_GAP_ABOVE_MIN: stretchStackGapAboveMin"]
#[doc = " @HB_OT_MATH_CONSTANT_STRETCH_STACK_GAP_BELOW_MIN: stretchStackGapBelowMin"]
#[doc = " @HB_OT_MATH_CONSTANT_FRACTION_NUMERATOR_SHIFT_UP: fractionNumeratorShiftUp"]
#[doc = " @HB_OT_MATH_CONSTANT_FRACTION_NUMERATOR_DISPLAY_STYLE_SHIFT_UP: fractionNumeratorDisplayStyleShiftUp"]
#[doc = " @HB_OT_MATH_CONSTANT_FRACTION_DENOMINATOR_SHIFT_DOWN: fractionDenominatorShiftDown"]
#[doc = " @HB_OT_MATH_CONSTANT_FRACTION_DENOMINATOR_DISPLAY_STYLE_SHIFT_DOWN: fractionDenominatorDisplayStyleShiftDown"]
#[doc = " @HB_OT_MATH_CONSTANT_FRACTION_NUMERATOR_GAP_MIN: fractionNumeratorGapMin"]
#[doc = " @HB_OT_MATH_CONSTANT_FRACTION_NUM_DISPLAY_STYLE_GAP_MIN: fractionNumDisplayStyleGapMin"]
#[doc = " @HB_OT_MATH_CONSTANT_FRACTION_RULE_THICKNESS: fractionRuleThickness"]
#[doc = " @HB_OT_MATH_CONSTANT_FRACTION_DENOMINATOR_GAP_MIN: fractionDenominatorGapMin"]
#[doc = " @HB_OT_MATH_CONSTANT_FRACTION_DENOM_DISPLAY_STYLE_GAP_MIN: fractionDenomDisplayStyleGapMin"]
#[doc = " @HB_OT_MATH_CONSTANT_SKEWED_FRACTION_HORIZONTAL_GAP: skewedFractionHorizontalGap"]
#[doc = " @HB_OT_MATH_CONSTANT_SKEWED_FRACTION_VERTICAL_GAP: skewedFractionVerticalGap"]
#[doc = " @HB_OT_MATH_CONSTANT_OVERBAR_VERTICAL_GAP: overbarVerticalGap"]
#[doc = " @HB_OT_MATH_CONSTANT_OVERBAR_RULE_THICKNESS: overbarRuleThickness"]
#[doc = " @HB_OT_MATH_CONSTANT_OVERBAR_EXTRA_ASCENDER: overbarExtraAscender"]
#[doc = " @HB_OT_MATH_CONSTANT_UNDERBAR_VERTICAL_GAP: underbarVerticalGap"]
#[doc = " @HB_OT_MATH_CONSTANT_UNDERBAR_RULE_THICKNESS: underbarRuleThickness"]
#[doc = " @HB_OT_MATH_CONSTANT_UNDERBAR_EXTRA_DESCENDER: underbarExtraDescender"]
#[doc = " @HB_OT_MATH_CONSTANT_RADICAL_VERTICAL_GAP: radicalVerticalGap"]
#[doc = " @HB_OT_MATH_CONSTANT_RADICAL_DISPLAY_STYLE_VERTICAL_GAP: radicalDisplayStyleVerticalGap"]
#[doc = " @HB_OT_MATH_CONSTANT_RADICAL_RULE_THICKNESS: radicalRuleThickness"]
#[doc = " @HB_OT_MATH_CONSTANT_RADICAL_EXTRA_ASCENDER: radicalExtraAscender"]
#[doc = " @HB_OT_MATH_CONSTANT_RADICAL_KERN_BEFORE_DEGREE: radicalKernBeforeDegree"]
#[doc = " @HB_OT_MATH_CONSTANT_RADICAL_KERN_AFTER_DEGREE: radicalKernAfterDegree"]
#[doc = " @HB_OT_MATH_CONSTANT_RADICAL_DEGREE_BOTTOM_RAISE_PERCENT: radicalDegreeBottomRaisePercent"]
#[doc = ""]
#[doc = " The 'MATH' table constants, refer to"]
#[doc = " [OpenType documentation](https://docs.microsoft.com/en-us/typography/opentype/spec/math#mathconstants-table)"]
#[doc = " For more explanations."]
#[doc = ""]
#[doc = " Since: 1.3.3"]
pub type hb_ot_math_constant_t = ::std::os::raw::c_uint;
pub const HB_OT_MATH_KERN_TOP_RIGHT: hb_ot_math_kern_t = 0;
pub const HB_OT_MATH_KERN_TOP_LEFT: hb_ot_math_kern_t = 1;
pub const HB_OT_MATH_KERN_BOTTOM_RIGHT: hb_ot_math_kern_t = 2;
pub const HB_OT_MATH_KERN_BOTTOM_LEFT: hb_ot_math_kern_t = 3;
#[doc = " hb_ot_math_kern_t:"]
#[doc = " @HB_OT_MATH_KERN_TOP_RIGHT: The top right corner of the glyph."]
#[doc = " @HB_OT_MATH_KERN_TOP_LEFT: The top left corner of the glyph."]
#[doc = " @HB_OT_MATH_KERN_BOTTOM_RIGHT: The bottom right corner of the glyph."]
#[doc = " @HB_OT_MATH_KERN_BOTTOM_LEFT: The bottom left corner of the glyph."]
#[doc = ""]
#[doc = " The math kerning-table types defined for the four corners"]
#[doc = " of a glyph."]
#[doc = ""]
#[doc = " Since: 1.3.3"]
pub type hb_ot_math_kern_t = ::std::os::raw::c_uint;
#[doc = " hb_ot_math_kern_entry_t:"]
#[doc = " @max_correction_height: The maximum height at which this entry should be used"]
#[doc = " @kern_value: The kern value of the entry"]
#[doc = ""]
#[doc = " Data type to hold math kerning (cut-in) information for a glyph."]
#[doc = ""]
#[doc = " Since: 3.4.0"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hb_ot_math_kern_entry_t {
    pub max_correction_height: hb_position_t,
    pub kern_value: hb_position_t,
}
#[test]
fn bindgen_test_layout_hb_ot_math_kern_entry_t() {
    assert_eq!(
        ::std::mem::size_of::<hb_ot_math_kern_entry_t>(),
        8usize,
        concat!("Size of: ", stringify!(hb_ot_math_kern_entry_t))
    );
    assert_eq!(
        ::std::mem::align_of::<hb_ot_math_kern_entry_t>(),
        4usize,
        concat!("Alignment of ", stringify!(hb_ot_math_kern_entry_t))
    );
    fn test_field_max_correction_height() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<hb_ot_math_kern_entry_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).max_correction_height) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(hb_ot_math_kern_entry_t),
                "::",
                stringify!(max_correction_height)
            )
        );
    }
    test_field_max_correction_height();
    fn test_field_kern_value() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<hb_ot_math_kern_entry_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).kern_value) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(hb_ot_math_kern_entry_t),
                "::",
                stringify!(kern_value)
            )
        );
    }
    test_field_kern_value();
}
#[doc = " hb_ot_math_glyph_variant_t:"]
#[doc = " @glyph: The glyph index of the variant"]
#[doc = " @advance: The advance width of the variant"]
#[doc = ""]
#[doc = " Data type to hold math-variant information for a glyph."]
#[doc = ""]
#[doc = " Since: 1.3.3"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hb_ot_math_glyph_variant_t {
    pub glyph: hb_codepoint_t,
    pub advance: hb_position_t,
}
#[test]
fn bindgen_test_layout_hb_ot_math_glyph_variant_t() {
    assert_eq!(
        ::std::mem::size_of::<hb_ot_math_glyph_variant_t>(),
        8usize,
        concat!("Size of: ", stringify!(hb_ot_math_glyph_variant_t))
    );
    assert_eq!(
        ::std::mem::align_of::<hb_ot_math_glyph_variant_t>(),
        4usize,
        concat!("Alignment of ", stringify!(hb_ot_math_glyph_variant_t))
    );
    fn test_field_glyph() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<hb_ot_math_glyph_variant_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).glyph) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(hb_ot_math_glyph_variant_t),
                "::",
                stringify!(glyph)
            )
        );
    }
    test_field_glyph();
    fn test_field_advance() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<hb_ot_math_glyph_variant_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).advance) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(hb_ot_math_glyph_variant_t),
                "::",
                stringify!(advance)
            )
        );
    }
    test_field_advance();
}
pub const HB_OT_MATH_GLYPH_PART_FLAG_EXTENDER: hb_ot_math_glyph_part_flags_t = 1;
#[doc = " hb_ot_math_glyph_part_flags_t:"]
#[doc = " @HB_OT_MATH_GLYPH_PART_FLAG_EXTENDER: This is an extender glyph part that"]
#[doc = " can be repeated to reach the desired length."]
#[doc = ""]
#[doc = " Flags for math glyph parts."]
#[doc = ""]
#[doc = " Since: 1.3.3"]
pub type hb_ot_math_glyph_part_flags_t = ::std::os::raw::c_uint;
#[doc = " hb_ot_math_glyph_part_t:"]
#[doc = " @glyph: The glyph index of the variant part"]
#[doc = " @start_connector_length: The length of the connector on the starting side of the variant part"]
#[doc = " @end_connector_length: The length of the connector on the ending side of the variant part"]
#[doc = " @full_advance: The total advance of the part"]
#[doc = " @flags: #hb_ot_math_glyph_part_flags_t flags for the part"]
#[doc = ""]
#[doc = " Data type to hold information for a \"part\" component of a math-variant glyph."]
#[doc = " Large variants for stretchable math glyphs (such as parentheses) can be constructed"]
#[doc = " on the fly from parts."]
#[doc = ""]
#[doc = " Since: 1.3.3"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hb_ot_math_glyph_part_t {
    pub glyph: hb_codepoint_t,
    pub start_connector_length: hb_position_t,
    pub end_connector_length: hb_position_t,
    pub full_advance: hb_position_t,
    pub flags: hb_ot_math_glyph_part_flags_t,
}
#[test]
fn bindgen_test_layout_hb_ot_math_glyph_part_t() {
    assert_eq!(
        ::std::mem::size_of::<hb_ot_math_glyph_part_t>(),
        20usize,
        concat!("Size of: ", stringify!(hb_ot_math_glyph_part_t))
    );
    assert_eq!(
        ::std::mem::align_of::<hb_ot_math_glyph_part_t>(),
        4usize,
        concat!("Alignment of ", stringify!(hb_ot_math_glyph_part_t))
    );
    fn test_field_glyph() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<hb_ot_math_glyph_part_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).glyph) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(hb_ot_math_glyph_part_t),
                "::",
                stringify!(glyph)
            )
        );
    }
    test_field_glyph();
    fn test_field_start_connector_length() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<hb_ot_math_glyph_part_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).start_connector_length) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(hb_ot_math_glyph_part_t),
                "::",
                stringify!(start_connector_length)
            )
        );
    }
    test_field_start_connector_length();
    fn test_field_end_connector_length() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<hb_ot_math_glyph_part_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).end_connector_length) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(hb_ot_math_glyph_part_t),
                "::",
                stringify!(end_connector_length)
            )
        );
    }
    test_field_end_connector_length();
    fn test_field_full_advance() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<hb_ot_math_glyph_part_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).full_advance) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(hb_ot_math_glyph_part_t),
                "::",
                stringify!(full_advance)
            )
        );
    }
    test_field_full_advance();
    fn test_field_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<hb_ot_math_glyph_part_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(hb_ot_math_glyph_part_t),
                "::",
                stringify!(flags)
            )
        );
    }
    test_field_flags();
}
extern "C" {
    pub fn hb_ot_math_has_data(face: *mut hb_face_t) -> hb_bool_t;
}
extern "C" {
    pub fn hb_ot_math_get_constant(
        font: *mut hb_font_t,
        constant: hb_ot_math_constant_t,
    ) -> hb_position_t;
}
extern "C" {
    pub fn hb_ot_math_get_glyph_italics_correction(
        font: *mut hb_font_t,
        glyph: hb_codepoint_t,
    ) -> hb_position_t;
}
extern "C" {
    pub fn hb_ot_math_get_glyph_top_accent_attachment(
        font: *mut hb_font_t,
        glyph: hb_codepoint_t,
    ) -> hb_position_t;
}
extern "C" {
    pub fn hb_ot_math_is_glyph_extended_shape(
        face: *mut hb_face_t,
        glyph: hb_codepoint_t,
    ) -> hb_bool_t;
}
extern "C" {
    pub fn hb_ot_math_get_glyph_kerning(
        font: *mut hb_font_t,
        glyph: hb_codepoint_t,
        kern: hb_ot_math_kern_t,
        correction_height: hb_position_t,
    ) -> hb_position_t;
}
extern "C" {
    pub fn hb_ot_math_get_glyph_kernings(
        font: *mut hb_font_t,
        glyph: hb_codepoint_t,
        kern: hb_ot_math_kern_t,
        start_offset: ::std::os::raw::c_uint,
        entries_count: *mut ::std::os::raw::c_uint,
        kern_entries: *mut hb_ot_math_kern_entry_t,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn hb_ot_math_get_glyph_variants(
        font: *mut hb_font_t,
        glyph: hb_codepoint_t,
        direction: hb_direction_t,
        start_offset: ::std::os::raw::c_uint,
        variants_count: *mut ::std::os::raw::c_uint,
        variants: *mut hb_ot_math_glyph_variant_t,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn hb_ot_math_get_min_connector_overlap(
        font: *mut hb_font_t,
        direction: hb_direction_t,
    ) -> hb_position_t;
}
extern "C" {
    pub fn hb_ot_math_get_glyph_assembly(
        font: *mut hb_font_t,
        glyph: hb_codepoint_t,
        direction: hb_direction_t,
        start_offset: ::std::os::raw::c_uint,
        parts_count: *mut ::std::os::raw::c_uint,
        parts: *mut hb_ot_math_glyph_part_t,
        italics_correction: *mut hb_position_t,
    ) -> ::std::os::raw::c_uint;
}
pub const HB_OT_META_TAG_DESIGN_LANGUAGES: hb_ot_meta_tag_t = 1684827751;
pub const HB_OT_META_TAG_SUPPORTED_LANGUAGES: hb_ot_meta_tag_t = 1936485991;
pub const _HB_OT_META_TAG_MAX_VALUE: hb_ot_meta_tag_t = 2147483647;
#[doc = " hb_ot_meta_tag_t:"]
#[doc = " @HB_OT_META_TAG_DESIGN_LANGUAGES: Design languages. Text, using only"]
#[doc = " Basic Latin (ASCII) characters. Indicates languages and/or scripts"]
#[doc = " for the user audiences that the font was primarily designed for."]
#[doc = " @HB_OT_META_TAG_SUPPORTED_LANGUAGES: Supported languages. Text, using"]
#[doc = " only Basic Latin (ASCII) characters. Indicates languages and/or scripts"]
#[doc = " that the font is declared to be capable of supporting."]
#[doc = ""]
#[doc = " Known metadata tags from https://docs.microsoft.com/en-us/typography/opentype/spec/meta"]
#[doc = ""]
#[doc = " Since: 2.6.0"]
pub type hb_ot_meta_tag_t = ::std::os::raw::c_uint;
extern "C" {
    pub fn hb_ot_meta_get_entry_tags(
        face: *mut hb_face_t,
        start_offset: ::std::os::raw::c_uint,
        entries_count: *mut ::std::os::raw::c_uint,
        entries: *mut hb_ot_meta_tag_t,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn hb_ot_meta_reference_entry(
        face: *mut hb_face_t,
        meta_tag: hb_ot_meta_tag_t,
    ) -> *mut hb_blob_t;
}
pub const HB_OT_METRICS_TAG_HORIZONTAL_ASCENDER: hb_ot_metrics_tag_t = 1751216995;
pub const HB_OT_METRICS_TAG_HORIZONTAL_DESCENDER: hb_ot_metrics_tag_t = 1751413603;
pub const HB_OT_METRICS_TAG_HORIZONTAL_LINE_GAP: hb_ot_metrics_tag_t = 1751934832;
pub const HB_OT_METRICS_TAG_HORIZONTAL_CLIPPING_ASCENT: hb_ot_metrics_tag_t = 1751346273;
pub const HB_OT_METRICS_TAG_HORIZONTAL_CLIPPING_DESCENT: hb_ot_metrics_tag_t = 1751346276;
pub const HB_OT_METRICS_TAG_VERTICAL_ASCENDER: hb_ot_metrics_tag_t = 1986098019;
pub const HB_OT_METRICS_TAG_VERTICAL_DESCENDER: hb_ot_metrics_tag_t = 1986294627;
pub const HB_OT_METRICS_TAG_VERTICAL_LINE_GAP: hb_ot_metrics_tag_t = 1986815856;
pub const HB_OT_METRICS_TAG_HORIZONTAL_CARET_RISE: hb_ot_metrics_tag_t = 1751347827;
pub const HB_OT_METRICS_TAG_HORIZONTAL_CARET_RUN: hb_ot_metrics_tag_t = 1751347822;
pub const HB_OT_METRICS_TAG_HORIZONTAL_CARET_OFFSET: hb_ot_metrics_tag_t = 1751347046;
pub const HB_OT_METRICS_TAG_VERTICAL_CARET_RISE: hb_ot_metrics_tag_t = 1986228851;
pub const HB_OT_METRICS_TAG_VERTICAL_CARET_RUN: hb_ot_metrics_tag_t = 1986228846;
pub const HB_OT_METRICS_TAG_VERTICAL_CARET_OFFSET: hb_ot_metrics_tag_t = 1986228070;
pub const HB_OT_METRICS_TAG_X_HEIGHT: hb_ot_metrics_tag_t = 2020108148;
pub const HB_OT_METRICS_TAG_CAP_HEIGHT: hb_ot_metrics_tag_t = 1668311156;
pub const HB_OT_METRICS_TAG_SUBSCRIPT_EM_X_SIZE: hb_ot_metrics_tag_t = 1935833203;
pub const HB_OT_METRICS_TAG_SUBSCRIPT_EM_Y_SIZE: hb_ot_metrics_tag_t = 1935833459;
pub const HB_OT_METRICS_TAG_SUBSCRIPT_EM_X_OFFSET: hb_ot_metrics_tag_t = 1935833199;
pub const HB_OT_METRICS_TAG_SUBSCRIPT_EM_Y_OFFSET: hb_ot_metrics_tag_t = 1935833455;
pub const HB_OT_METRICS_TAG_SUPERSCRIPT_EM_X_SIZE: hb_ot_metrics_tag_t = 1936750707;
pub const HB_OT_METRICS_TAG_SUPERSCRIPT_EM_Y_SIZE: hb_ot_metrics_tag_t = 1936750963;
pub const HB_OT_METRICS_TAG_SUPERSCRIPT_EM_X_OFFSET: hb_ot_metrics_tag_t = 1936750703;
pub const HB_OT_METRICS_TAG_SUPERSCRIPT_EM_Y_OFFSET: hb_ot_metrics_tag_t = 1936750959;
pub const HB_OT_METRICS_TAG_STRIKEOUT_SIZE: hb_ot_metrics_tag_t = 1937011315;
pub const HB_OT_METRICS_TAG_STRIKEOUT_OFFSET: hb_ot_metrics_tag_t = 1937011311;
pub const HB_OT_METRICS_TAG_UNDERLINE_SIZE: hb_ot_metrics_tag_t = 1970168947;
pub const HB_OT_METRICS_TAG_UNDERLINE_OFFSET: hb_ot_metrics_tag_t = 1970168943;
pub const _HB_OT_METRICS_TAG_MAX_VALUE: hb_ot_metrics_tag_t = 2147483647;
#[doc = " hb_ot_metrics_tag_t:"]
#[doc = " @HB_OT_METRICS_TAG_HORIZONTAL_ASCENDER: horizontal ascender."]
#[doc = " @HB_OT_METRICS_TAG_HORIZONTAL_DESCENDER: horizontal descender."]
#[doc = " @HB_OT_METRICS_TAG_HORIZONTAL_LINE_GAP: horizontal line gap."]
#[doc = " @HB_OT_METRICS_TAG_HORIZONTAL_CLIPPING_ASCENT: horizontal clipping ascent."]
#[doc = " @HB_OT_METRICS_TAG_HORIZONTAL_CLIPPING_DESCENT: horizontal clipping descent."]
#[doc = " @HB_OT_METRICS_TAG_VERTICAL_ASCENDER: vertical ascender."]
#[doc = " @HB_OT_METRICS_TAG_VERTICAL_DESCENDER: vertical descender."]
#[doc = " @HB_OT_METRICS_TAG_VERTICAL_LINE_GAP: vertical line gap."]
#[doc = " @HB_OT_METRICS_TAG_HORIZONTAL_CARET_RISE: horizontal caret rise."]
#[doc = " @HB_OT_METRICS_TAG_HORIZONTAL_CARET_RUN: horizontal caret run."]
#[doc = " @HB_OT_METRICS_TAG_HORIZONTAL_CARET_OFFSET: horizontal caret offset."]
#[doc = " @HB_OT_METRICS_TAG_VERTICAL_CARET_RISE: vertical caret rise."]
#[doc = " @HB_OT_METRICS_TAG_VERTICAL_CARET_RUN: vertical caret run."]
#[doc = " @HB_OT_METRICS_TAG_VERTICAL_CARET_OFFSET: vertical caret offset."]
#[doc = " @HB_OT_METRICS_TAG_X_HEIGHT: x height."]
#[doc = " @HB_OT_METRICS_TAG_CAP_HEIGHT: cap height."]
#[doc = " @HB_OT_METRICS_TAG_SUBSCRIPT_EM_X_SIZE: subscript em x size."]
#[doc = " @HB_OT_METRICS_TAG_SUBSCRIPT_EM_Y_SIZE: subscript em y size."]
#[doc = " @HB_OT_METRICS_TAG_SUBSCRIPT_EM_X_OFFSET: subscript em x offset."]
#[doc = " @HB_OT_METRICS_TAG_SUBSCRIPT_EM_Y_OFFSET: subscript em y offset."]
#[doc = " @HB_OT_METRICS_TAG_SUPERSCRIPT_EM_X_SIZE: superscript em x size."]
#[doc = " @HB_OT_METRICS_TAG_SUPERSCRIPT_EM_Y_SIZE: superscript em y size."]
#[doc = " @HB_OT_METRICS_TAG_SUPERSCRIPT_EM_X_OFFSET: superscript em x offset."]
#[doc = " @HB_OT_METRICS_TAG_SUPERSCRIPT_EM_Y_OFFSET: superscript em y offset."]
#[doc = " @HB_OT_METRICS_TAG_STRIKEOUT_SIZE: strikeout size."]
#[doc = " @HB_OT_METRICS_TAG_STRIKEOUT_OFFSET: strikeout offset."]
#[doc = " @HB_OT_METRICS_TAG_UNDERLINE_SIZE: underline size."]
#[doc = " @HB_OT_METRICS_TAG_UNDERLINE_OFFSET: underline offset."]
#[doc = ""]
#[doc = " Metric tags corresponding to [MVAR Value"]
#[doc = " Tags](https://docs.microsoft.com/en-us/typography/opentype/spec/mvar#value-tags)"]
#[doc = ""]
#[doc = " Since: 2.6.0"]
pub type hb_ot_metrics_tag_t = ::std::os::raw::c_uint;
extern "C" {
    pub fn hb_ot_metrics_get_position(
        font: *mut hb_font_t,
        metrics_tag: hb_ot_metrics_tag_t,
        position: *mut hb_position_t,
    ) -> hb_bool_t;
}
extern "C" {
    pub fn hb_ot_metrics_get_position_with_fallback(
        font: *mut hb_font_t,
        metrics_tag: hb_ot_metrics_tag_t,
        position: *mut hb_position_t,
    );
}
extern "C" {
    pub fn hb_ot_metrics_get_variation(
        font: *mut hb_font_t,
        metrics_tag: hb_ot_metrics_tag_t,
    ) -> ::std::os::raw::c_float;
}
extern "C" {
    pub fn hb_ot_metrics_get_x_variation(
        font: *mut hb_font_t,
        metrics_tag: hb_ot_metrics_tag_t,
    ) -> hb_position_t;
}
extern "C" {
    pub fn hb_ot_metrics_get_y_variation(
        font: *mut hb_font_t,
        metrics_tag: hb_ot_metrics_tag_t,
    ) -> hb_position_t;
}
extern "C" {
    pub fn hb_ot_shape_glyphs_closure(
        font: *mut hb_font_t,
        buffer: *mut hb_buffer_t,
        features: *const hb_feature_t,
        num_features: ::std::os::raw::c_uint,
        glyphs: *mut hb_set_t,
    );
}
extern "C" {
    pub fn hb_ot_shape_plan_collect_lookups(
        shape_plan: *mut hb_shape_plan_t,
        table_tag: hb_tag_t,
        lookup_indexes: *mut hb_set_t,
    );
}
extern "C" {
    pub fn hb_ot_var_has_data(face: *mut hb_face_t) -> hb_bool_t;
}
extern "C" {
    pub fn hb_ot_var_get_axis_count(face: *mut hb_face_t) -> ::std::os::raw::c_uint;
}
pub const HB_OT_VAR_AXIS_FLAG_HIDDEN: hb_ot_var_axis_flags_t = 1;
pub const _HB_OT_VAR_AXIS_FLAG_MAX_VALUE: hb_ot_var_axis_flags_t = 2147483647;
#[doc = " hb_ot_var_axis_flags_t:"]
#[doc = " @HB_OT_VAR_AXIS_FLAG_HIDDEN: The axis should not be exposed directly in user interfaces."]
#[doc = ""]
#[doc = " Flags for #hb_ot_var_axis_info_t."]
#[doc = ""]
#[doc = " Since: 2.2.0"]
pub type hb_ot_var_axis_flags_t = ::std::os::raw::c_uint;
#[doc = " hb_ot_var_axis_info_t:"]
#[doc = " @axis_index: Index of the axis in the variation-axis array"]
#[doc = " @tag: The #hb_tag_t tag identifying the design variation of the axis"]
#[doc = " @name_id: The `name` table Name ID that provides display names for the axis"]
#[doc = " @flags: The #hb_ot_var_axis_flags_t flags for the axis"]
#[doc = " @min_value: The minimum value on the variation axis that the font covers"]
#[doc = " @default_value: The position on the variation axis corresponding to the font's defaults"]
#[doc = " @max_value: The maximum value on the variation axis that the font covers"]
#[doc = ""]
#[doc = " Data type for holding variation-axis values."]
#[doc = ""]
#[doc = " The minimum, default, and maximum values are in un-normalized, user scales."]
#[doc = ""]
#[doc = " <note>Note: at present, the only flag defined for @flags is"]
#[doc = " #HB_OT_VAR_AXIS_FLAG_HIDDEN.</note>"]
#[doc = ""]
#[doc = " Since: 2.2.0"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hb_ot_var_axis_info_t {
    pub axis_index: ::std::os::raw::c_uint,
    pub tag: hb_tag_t,
    pub name_id: hb_ot_name_id_t,
    pub flags: hb_ot_var_axis_flags_t,
    pub min_value: ::std::os::raw::c_float,
    pub default_value: ::std::os::raw::c_float,
    pub max_value: ::std::os::raw::c_float,
    pub reserved: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_hb_ot_var_axis_info_t() {
    assert_eq!(
        ::std::mem::size_of::<hb_ot_var_axis_info_t>(),
        32usize,
        concat!("Size of: ", stringify!(hb_ot_var_axis_info_t))
    );
    assert_eq!(
        ::std::mem::align_of::<hb_ot_var_axis_info_t>(),
        4usize,
        concat!("Alignment of ", stringify!(hb_ot_var_axis_info_t))
    );
    fn test_field_axis_index() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<hb_ot_var_axis_info_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).axis_index) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(hb_ot_var_axis_info_t),
                "::",
                stringify!(axis_index)
            )
        );
    }
    test_field_axis_index();
    fn test_field_tag() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<hb_ot_var_axis_info_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tag) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(hb_ot_var_axis_info_t),
                "::",
                stringify!(tag)
            )
        );
    }
    test_field_tag();
    fn test_field_name_id() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<hb_ot_var_axis_info_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).name_id) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(hb_ot_var_axis_info_t),
                "::",
                stringify!(name_id)
            )
        );
    }
    test_field_name_id();
    fn test_field_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<hb_ot_var_axis_info_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(hb_ot_var_axis_info_t),
                "::",
                stringify!(flags)
            )
        );
    }
    test_field_flags();
    fn test_field_min_value() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<hb_ot_var_axis_info_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).min_value) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(hb_ot_var_axis_info_t),
                "::",
                stringify!(min_value)
            )
        );
    }
    test_field_min_value();
    fn test_field_default_value() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<hb_ot_var_axis_info_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).default_value) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(hb_ot_var_axis_info_t),
                "::",
                stringify!(default_value)
            )
        );
    }
    test_field_default_value();
    fn test_field_max_value() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<hb_ot_var_axis_info_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).max_value) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(hb_ot_var_axis_info_t),
                "::",
                stringify!(max_value)
            )
        );
    }
    test_field_max_value();
    fn test_field_reserved() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<hb_ot_var_axis_info_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize
            },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(hb_ot_var_axis_info_t),
                "::",
                stringify!(reserved)
            )
        );
    }
    test_field_reserved();
}
extern "C" {
    pub fn hb_ot_var_get_axis_infos(
        face: *mut hb_face_t,
        start_offset: ::std::os::raw::c_uint,
        axes_count: *mut ::std::os::raw::c_uint,
        axes_array: *mut hb_ot_var_axis_info_t,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn hb_ot_var_find_axis_info(
        face: *mut hb_face_t,
        axis_tag: hb_tag_t,
        axis_info: *mut hb_ot_var_axis_info_t,
    ) -> hb_bool_t;
}
extern "C" {
    pub fn hb_ot_var_get_named_instance_count(face: *mut hb_face_t) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn hb_ot_var_named_instance_get_subfamily_name_id(
        face: *mut hb_face_t,
        instance_index: ::std::os::raw::c_uint,
    ) -> hb_ot_name_id_t;
}
extern "C" {
    pub fn hb_ot_var_named_instance_get_postscript_name_id(
        face: *mut hb_face_t,
        instance_index: ::std::os::raw::c_uint,
    ) -> hb_ot_name_id_t;
}
extern "C" {
    pub fn hb_ot_var_named_instance_get_design_coords(
        face: *mut hb_face_t,
        instance_index: ::std::os::raw::c_uint,
        coords_length: *mut ::std::os::raw::c_uint,
        coords: *mut ::std::os::raw::c_float,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn hb_ot_var_normalize_variations(
        face: *mut hb_face_t,
        variations: *const hb_variation_t,
        variations_length: ::std::os::raw::c_uint,
        coords: *mut ::std::os::raw::c_int,
        coords_length: ::std::os::raw::c_uint,
    );
}
extern "C" {
    pub fn hb_ot_var_normalize_coords(
        face: *mut hb_face_t,
        coords_length: ::std::os::raw::c_uint,
        design_coords: *const ::std::os::raw::c_float,
        normalized_coords: *mut ::std::os::raw::c_int,
    );
}
pub const HB_AAT_LAYOUT_FEATURE_TYPE_INVALID: hb_aat_layout_feature_type_t = 65535;
pub const HB_AAT_LAYOUT_FEATURE_TYPE_ALL_TYPOGRAPHIC: hb_aat_layout_feature_type_t = 0;
pub const HB_AAT_LAYOUT_FEATURE_TYPE_LIGATURES: hb_aat_layout_feature_type_t = 1;
pub const HB_AAT_LAYOUT_FEATURE_TYPE_CURISVE_CONNECTION: hb_aat_layout_feature_type_t = 2;
pub const HB_AAT_LAYOUT_FEATURE_TYPE_LETTER_CASE: hb_aat_layout_feature_type_t = 3;
pub const HB_AAT_LAYOUT_FEATURE_TYPE_VERTICAL_SUBSTITUTION: hb_aat_layout_feature_type_t = 4;
pub const HB_AAT_LAYOUT_FEATURE_TYPE_LINGUISTIC_REARRANGEMENT: hb_aat_layout_feature_type_t = 5;
pub const HB_AAT_LAYOUT_FEATURE_TYPE_NUMBER_SPACING: hb_aat_layout_feature_type_t = 6;
pub const HB_AAT_LAYOUT_FEATURE_TYPE_SMART_SWASH_TYPE: hb_aat_layout_feature_type_t = 8;
pub const HB_AAT_LAYOUT_FEATURE_TYPE_DIACRITICS_TYPE: hb_aat_layout_feature_type_t = 9;
pub const HB_AAT_LAYOUT_FEATURE_TYPE_VERTICAL_POSITION: hb_aat_layout_feature_type_t = 10;
pub const HB_AAT_LAYOUT_FEATURE_TYPE_FRACTIONS: hb_aat_layout_feature_type_t = 11;
pub const HB_AAT_LAYOUT_FEATURE_TYPE_OVERLAPPING_CHARACTERS_TYPE: hb_aat_layout_feature_type_t = 13;
pub const HB_AAT_LAYOUT_FEATURE_TYPE_TYPOGRAPHIC_EXTRAS: hb_aat_layout_feature_type_t = 14;
pub const HB_AAT_LAYOUT_FEATURE_TYPE_MATHEMATICAL_EXTRAS: hb_aat_layout_feature_type_t = 15;
pub const HB_AAT_LAYOUT_FEATURE_TYPE_ORNAMENT_SETS_TYPE: hb_aat_layout_feature_type_t = 16;
pub const HB_AAT_LAYOUT_FEATURE_TYPE_CHARACTER_ALTERNATIVES: hb_aat_layout_feature_type_t = 17;
pub const HB_AAT_LAYOUT_FEATURE_TYPE_DESIGN_COMPLEXITY_TYPE: hb_aat_layout_feature_type_t = 18;
pub const HB_AAT_LAYOUT_FEATURE_TYPE_STYLE_OPTIONS: hb_aat_layout_feature_type_t = 19;
pub const HB_AAT_LAYOUT_FEATURE_TYPE_CHARACTER_SHAPE: hb_aat_layout_feature_type_t = 20;
pub const HB_AAT_LAYOUT_FEATURE_TYPE_NUMBER_CASE: hb_aat_layout_feature_type_t = 21;
pub const HB_AAT_LAYOUT_FEATURE_TYPE_TEXT_SPACING: hb_aat_layout_feature_type_t = 22;
pub const HB_AAT_LAYOUT_FEATURE_TYPE_TRANSLITERATION: hb_aat_layout_feature_type_t = 23;
pub const HB_AAT_LAYOUT_FEATURE_TYPE_ANNOTATION_TYPE: hb_aat_layout_feature_type_t = 24;
pub const HB_AAT_LAYOUT_FEATURE_TYPE_KANA_SPACING_TYPE: hb_aat_layout_feature_type_t = 25;
pub const HB_AAT_LAYOUT_FEATURE_TYPE_IDEOGRAPHIC_SPACING_TYPE: hb_aat_layout_feature_type_t = 26;
pub const HB_AAT_LAYOUT_FEATURE_TYPE_UNICODE_DECOMPOSITION_TYPE: hb_aat_layout_feature_type_t = 27;
pub const HB_AAT_LAYOUT_FEATURE_TYPE_RUBY_KANA: hb_aat_layout_feature_type_t = 28;
pub const HB_AAT_LAYOUT_FEATURE_TYPE_CJK_SYMBOL_ALTERNATIVES_TYPE: hb_aat_layout_feature_type_t =
    29;
pub const HB_AAT_LAYOUT_FEATURE_TYPE_IDEOGRAPHIC_ALTERNATIVES_TYPE: hb_aat_layout_feature_type_t =
    30;
pub const HB_AAT_LAYOUT_FEATURE_TYPE_CJK_VERTICAL_ROMAN_PLACEMENT_TYPE:
    hb_aat_layout_feature_type_t = 31;
pub const HB_AAT_LAYOUT_FEATURE_TYPE_ITALIC_CJK_ROMAN: hb_aat_layout_feature_type_t = 32;
pub const HB_AAT_LAYOUT_FEATURE_TYPE_CASE_SENSITIVE_LAYOUT: hb_aat_layout_feature_type_t = 33;
pub const HB_AAT_LAYOUT_FEATURE_TYPE_ALTERNATE_KANA: hb_aat_layout_feature_type_t = 34;
pub const HB_AAT_LAYOUT_FEATURE_TYPE_STYLISTIC_ALTERNATIVES: hb_aat_layout_feature_type_t = 35;
pub const HB_AAT_LAYOUT_FEATURE_TYPE_CONTEXTUAL_ALTERNATIVES: hb_aat_layout_feature_type_t = 36;
pub const HB_AAT_LAYOUT_FEATURE_TYPE_LOWER_CASE: hb_aat_layout_feature_type_t = 37;
pub const HB_AAT_LAYOUT_FEATURE_TYPE_UPPER_CASE: hb_aat_layout_feature_type_t = 38;
pub const HB_AAT_LAYOUT_FEATURE_TYPE_LANGUAGE_TAG_TYPE: hb_aat_layout_feature_type_t = 39;
pub const HB_AAT_LAYOUT_FEATURE_TYPE_CJK_ROMAN_SPACING_TYPE: hb_aat_layout_feature_type_t = 103;
pub const _HB_AAT_LAYOUT_FEATURE_TYPE_MAX_VALUE: hb_aat_layout_feature_type_t = 2147483647;
#[doc = " hb_aat_layout_feature_type_t:"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_TYPE_INVALID: Initial, unset feature type"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_TYPE_ALL_TYPOGRAPHIC: [All Typographic Features](https://developer.apple.com/fonts/TrueType-Reference-Manual/RM09/AppendixF.html#Type0)"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_TYPE_LIGATURES: [Ligatures](https://developer.apple.com/fonts/TrueType-Reference-Manual/RM09/AppendixF.html#Type1)"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_TYPE_CURISVE_CONNECTION: [Cursive Connection](https://developer.apple.com/fonts/TrueType-Reference-Manual/RM09/AppendixF.html#Type2)"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_TYPE_LETTER_CASE: [Letter Case](https://developer.apple.com/fonts/TrueType-Reference-Manual/RM09/AppendixF.html#Type3)"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_TYPE_VERTICAL_SUBSTITUTION: [Vertical Substitution](https://developer.apple.com/fonts/TrueType-Reference-Manual/RM09/AppendixF.html#Type4)"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_TYPE_LINGUISTIC_REARRANGEMENT: [Linguistic Rearrangement](https://developer.apple.com/fonts/TrueType-Reference-Manual/RM09/AppendixF.html#Type5)"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_TYPE_NUMBER_SPACING: [Number Spacing](https://developer.apple.com/fonts/TrueType-Reference-Manual/RM09/AppendixF.html#Type6)"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_TYPE_SMART_SWASH_TYPE: [Smart Swash](https://developer.apple.com/fonts/TrueType-Reference-Manual/RM09/AppendixF.html#Type8)"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_TYPE_DIACRITICS_TYPE: [Diacritics](https://developer.apple.com/fonts/TrueType-Reference-Manual/RM09/AppendixF.html#Type9)"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_TYPE_VERTICAL_POSITION: [Vertical Position](https://developer.apple.com/fonts/TrueType-Reference-Manual/RM09/AppendixF.html#Type10)"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_TYPE_FRACTIONS: [Fractions](https://developer.apple.com/fonts/TrueType-Reference-Manual/RM09/AppendixF.html#Type11)"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_TYPE_OVERLAPPING_CHARACTERS_TYPE: [Overlapping Characters](https://developer.apple.com/fonts/TrueType-Reference-Manual/RM09/AppendixF.html#Type13)"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_TYPE_TYPOGRAPHIC_EXTRAS: [Typographic Extras](https://developer.apple.com/fonts/TrueType-Reference-Manual/RM09/AppendixF.html#Type14)"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_TYPE_MATHEMATICAL_EXTRAS: [Mathematical Extras](https://developer.apple.com/fonts/TrueType-Reference-Manual/RM09/AppendixF.html#Type15)"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_TYPE_ORNAMENT_SETS_TYPE: [Ornament Sets](https://developer.apple.com/fonts/TrueType-Reference-Manual/RM09/AppendixF.html#Type16)"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_TYPE_CHARACTER_ALTERNATIVES: [Character Alternatives](https://developer.apple.com/fonts/TrueType-Reference-Manual/RM09/AppendixF.html#Type17)"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_TYPE_DESIGN_COMPLEXITY_TYPE: [Design Complexity](https://developer.apple.com/fonts/TrueType-Reference-Manual/RM09/AppendixF.html#Type18)"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_TYPE_STYLE_OPTIONS: [Style Options](https://developer.apple.com/fonts/TrueType-Reference-Manual/RM09/AppendixF.html#Type19)"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_TYPE_CHARACTER_SHAPE: [Character Shape](https://developer.apple.com/fonts/TrueType-Reference-Manual/RM09/AppendixF.html#Type20)"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_TYPE_NUMBER_CASE: [Number Case](https://developer.apple.com/fonts/TrueType-Reference-Manual/RM09/AppendixF.html#Type21)"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_TYPE_TEXT_SPACING: [Text Spacing](https://developer.apple.com/fonts/TrueType-Reference-Manual/RM09/AppendixF.html#Type22)"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_TYPE_TRANSLITERATION: [Transliteration](https://developer.apple.com/fonts/TrueType-Reference-Manual/RM09/AppendixF.html#Type23)"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_TYPE_ANNOTATION_TYPE: [Annotation](https://developer.apple.com/fonts/TrueType-Reference-Manual/RM09/AppendixF.html#Type24)"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_TYPE_KANA_SPACING_TYPE: [Kana Spacing](https://developer.apple.com/fonts/TrueType-Reference-Manual/RM09/AppendixF.html#Type25)"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_TYPE_IDEOGRAPHIC_SPACING_TYPE: [Ideographic Spacing](https://developer.apple.com/fonts/TrueType-Reference-Manual/RM09/AppendixF.html#Type26)"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_TYPE_UNICODE_DECOMPOSITION_TYPE: [Unicode Decomposition](https://developer.apple.com/fonts/TrueType-Reference-Manual/RM09/AppendixF.html#Type27)"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_TYPE_RUBY_KANA: [Ruby Kana](https://developer.apple.com/fonts/TrueType-Reference-Manual/RM09/AppendixF.html#Type28)"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_TYPE_CJK_SYMBOL_ALTERNATIVES_TYPE: [CJK Symbol Alternatives](https://developer.apple.com/fonts/TrueType-Reference-Manual/RM09/AppendixF.html#Type29)"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_TYPE_IDEOGRAPHIC_ALTERNATIVES_TYPE: [Ideographic Alternatives](https://developer.apple.com/fonts/TrueType-Reference-Manual/RM09/AppendixF.html#Type30)"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_TYPE_CJK_VERTICAL_ROMAN_PLACEMENT_TYPE: [CJK Vertical Roman Placement](https://developer.apple.com/fonts/TrueType-Reference-Manual/RM09/AppendixF.html#Type31)"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_TYPE_ITALIC_CJK_ROMAN: [Italic CJK Roman](https://developer.apple.com/fonts/TrueType-Reference-Manual/RM09/AppendixF.html#Type32)"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_TYPE_CASE_SENSITIVE_LAYOUT: [Case Sensitive Layout](https://developer.apple.com/fonts/TrueType-Reference-Manual/RM09/AppendixF.html#Type33)"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_TYPE_ALTERNATE_KANA: [Alternate Kana](https://developer.apple.com/fonts/TrueType-Reference-Manual/RM09/AppendixF.html#Type34)"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_TYPE_STYLISTIC_ALTERNATIVES: [Stylistic Alternatives](https://developer.apple.com/fonts/TrueType-Reference-Manual/RM09/AppendixF.html#Type35)"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_TYPE_CONTEXTUAL_ALTERNATIVES: [Contextual Alternatives](https://developer.apple.com/fonts/TrueType-Reference-Manual/RM09/AppendixF.html#Type36)"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_TYPE_LOWER_CASE: [Lower Case](https://developer.apple.com/fonts/TrueType-Reference-Manual/RM09/AppendixF.html#Type37)"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_TYPE_UPPER_CASE: [Upper Case](https://developer.apple.com/fonts/TrueType-Reference-Manual/RM09/AppendixF.html#Type38)"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_TYPE_LANGUAGE_TAG_TYPE: [Language Tag](https://developer.apple.com/fonts/TrueType-Reference-Manual/RM09/AppendixF.html#Type39)"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_TYPE_CJK_ROMAN_SPACING_TYPE: [CJK Roman Spacing](https://developer.apple.com/fonts/TrueType-Reference-Manual/RM09/AppendixF.html#Type103)"]
#[doc = ""]
#[doc = " The possible feature types defined for AAT shaping, from Apple [Font Feature Registry](https://developer.apple.com/fonts/TrueType-Reference-Manual/RM09/AppendixF.html)."]
#[doc = ""]
#[doc = " Since: 2.2.0"]
pub type hb_aat_layout_feature_type_t = ::std::os::raw::c_uint;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_INVALID: hb_aat_layout_feature_selector_t = 65535;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_ALL_TYPE_FEATURES_ON: hb_aat_layout_feature_selector_t = 0;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_ALL_TYPE_FEATURES_OFF: hb_aat_layout_feature_selector_t =
    1;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_REQUIRED_LIGATURES_ON: hb_aat_layout_feature_selector_t =
    0;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_REQUIRED_LIGATURES_OFF: hb_aat_layout_feature_selector_t =
    1;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_COMMON_LIGATURES_ON: hb_aat_layout_feature_selector_t = 2;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_COMMON_LIGATURES_OFF: hb_aat_layout_feature_selector_t = 3;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_RARE_LIGATURES_ON: hb_aat_layout_feature_selector_t = 4;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_RARE_LIGATURES_OFF: hb_aat_layout_feature_selector_t = 5;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_LOGOS_ON: hb_aat_layout_feature_selector_t = 6;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_LOGOS_OFF: hb_aat_layout_feature_selector_t = 7;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_REBUS_PICTURES_ON: hb_aat_layout_feature_selector_t = 8;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_REBUS_PICTURES_OFF: hb_aat_layout_feature_selector_t = 9;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_DIPHTHONG_LIGATURES_ON: hb_aat_layout_feature_selector_t =
    10;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_DIPHTHONG_LIGATURES_OFF: hb_aat_layout_feature_selector_t =
    11;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_SQUARED_LIGATURES_ON: hb_aat_layout_feature_selector_t =
    12;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_SQUARED_LIGATURES_OFF: hb_aat_layout_feature_selector_t =
    13;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_ABBREV_SQUARED_LIGATURES_ON:
    hb_aat_layout_feature_selector_t = 14;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_ABBREV_SQUARED_LIGATURES_OFF:
    hb_aat_layout_feature_selector_t = 15;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_SYMBOL_LIGATURES_ON: hb_aat_layout_feature_selector_t = 16;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_SYMBOL_LIGATURES_OFF: hb_aat_layout_feature_selector_t =
    17;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_CONTEXTUAL_LIGATURES_ON: hb_aat_layout_feature_selector_t =
    18;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_CONTEXTUAL_LIGATURES_OFF:
    hb_aat_layout_feature_selector_t = 19;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_HISTORICAL_LIGATURES_ON: hb_aat_layout_feature_selector_t =
    20;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_HISTORICAL_LIGATURES_OFF:
    hb_aat_layout_feature_selector_t = 21;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_UNCONNECTED: hb_aat_layout_feature_selector_t = 0;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_PARTIALLY_CONNECTED: hb_aat_layout_feature_selector_t = 1;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_CURSIVE: hb_aat_layout_feature_selector_t = 2;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_UPPER_AND_LOWER_CASE: hb_aat_layout_feature_selector_t = 0;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_ALL_CAPS: hb_aat_layout_feature_selector_t = 1;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_ALL_LOWER_CASE: hb_aat_layout_feature_selector_t = 2;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_SMALL_CAPS: hb_aat_layout_feature_selector_t = 3;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_INITIAL_CAPS: hb_aat_layout_feature_selector_t = 4;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_INITIAL_CAPS_AND_SMALL_CAPS:
    hb_aat_layout_feature_selector_t = 5;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_SUBSTITUTE_VERTICAL_FORMS_ON:
    hb_aat_layout_feature_selector_t = 0;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_SUBSTITUTE_VERTICAL_FORMS_OFF:
    hb_aat_layout_feature_selector_t = 1;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_LINGUISTIC_REARRANGEMENT_ON:
    hb_aat_layout_feature_selector_t = 0;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_LINGUISTIC_REARRANGEMENT_OFF:
    hb_aat_layout_feature_selector_t = 1;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_MONOSPACED_NUMBERS: hb_aat_layout_feature_selector_t = 0;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_PROPORTIONAL_NUMBERS: hb_aat_layout_feature_selector_t = 1;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_THIRD_WIDTH_NUMBERS: hb_aat_layout_feature_selector_t = 2;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_QUARTER_WIDTH_NUMBERS: hb_aat_layout_feature_selector_t =
    3;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_WORD_INITIAL_SWASHES_ON: hb_aat_layout_feature_selector_t =
    0;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_WORD_INITIAL_SWASHES_OFF:
    hb_aat_layout_feature_selector_t = 1;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_WORD_FINAL_SWASHES_ON: hb_aat_layout_feature_selector_t =
    2;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_WORD_FINAL_SWASHES_OFF: hb_aat_layout_feature_selector_t =
    3;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_LINE_INITIAL_SWASHES_ON: hb_aat_layout_feature_selector_t =
    4;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_LINE_INITIAL_SWASHES_OFF:
    hb_aat_layout_feature_selector_t = 5;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_LINE_FINAL_SWASHES_ON: hb_aat_layout_feature_selector_t =
    6;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_LINE_FINAL_SWASHES_OFF: hb_aat_layout_feature_selector_t =
    7;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_NON_FINAL_SWASHES_ON: hb_aat_layout_feature_selector_t = 8;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_NON_FINAL_SWASHES_OFF: hb_aat_layout_feature_selector_t =
    9;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_SHOW_DIACRITICS: hb_aat_layout_feature_selector_t = 0;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_HIDE_DIACRITICS: hb_aat_layout_feature_selector_t = 1;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_DECOMPOSE_DIACRITICS: hb_aat_layout_feature_selector_t = 2;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_NORMAL_POSITION: hb_aat_layout_feature_selector_t = 0;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_SUPERIORS: hb_aat_layout_feature_selector_t = 1;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_INFERIORS: hb_aat_layout_feature_selector_t = 2;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_ORDINALS: hb_aat_layout_feature_selector_t = 3;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_SCIENTIFIC_INFERIORS: hb_aat_layout_feature_selector_t = 4;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_NO_FRACTIONS: hb_aat_layout_feature_selector_t = 0;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_VERTICAL_FRACTIONS: hb_aat_layout_feature_selector_t = 1;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_DIAGONAL_FRACTIONS: hb_aat_layout_feature_selector_t = 2;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_PREVENT_OVERLAP_ON: hb_aat_layout_feature_selector_t = 0;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_PREVENT_OVERLAP_OFF: hb_aat_layout_feature_selector_t = 1;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_HYPHENS_TO_EM_DASH_ON: hb_aat_layout_feature_selector_t =
    0;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_HYPHENS_TO_EM_DASH_OFF: hb_aat_layout_feature_selector_t =
    1;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_HYPHEN_TO_EN_DASH_ON: hb_aat_layout_feature_selector_t = 2;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_HYPHEN_TO_EN_DASH_OFF: hb_aat_layout_feature_selector_t =
    3;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_SLASHED_ZERO_ON: hb_aat_layout_feature_selector_t = 4;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_SLASHED_ZERO_OFF: hb_aat_layout_feature_selector_t = 5;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_FORM_INTERROBANG_ON: hb_aat_layout_feature_selector_t = 6;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_FORM_INTERROBANG_OFF: hb_aat_layout_feature_selector_t = 7;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_SMART_QUOTES_ON: hb_aat_layout_feature_selector_t = 8;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_SMART_QUOTES_OFF: hb_aat_layout_feature_selector_t = 9;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_PERIODS_TO_ELLIPSIS_ON: hb_aat_layout_feature_selector_t =
    10;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_PERIODS_TO_ELLIPSIS_OFF: hb_aat_layout_feature_selector_t =
    11;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_HYPHEN_TO_MINUS_ON: hb_aat_layout_feature_selector_t = 0;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_HYPHEN_TO_MINUS_OFF: hb_aat_layout_feature_selector_t = 1;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_ASTERISK_TO_MULTIPLY_ON: hb_aat_layout_feature_selector_t =
    2;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_ASTERISK_TO_MULTIPLY_OFF:
    hb_aat_layout_feature_selector_t = 3;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_SLASH_TO_DIVIDE_ON: hb_aat_layout_feature_selector_t = 4;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_SLASH_TO_DIVIDE_OFF: hb_aat_layout_feature_selector_t = 5;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_INEQUALITY_LIGATURES_ON: hb_aat_layout_feature_selector_t =
    6;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_INEQUALITY_LIGATURES_OFF:
    hb_aat_layout_feature_selector_t = 7;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_EXPONENTS_ON: hb_aat_layout_feature_selector_t = 8;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_EXPONENTS_OFF: hb_aat_layout_feature_selector_t = 9;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_MATHEMATICAL_GREEK_ON: hb_aat_layout_feature_selector_t =
    10;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_MATHEMATICAL_GREEK_OFF: hb_aat_layout_feature_selector_t =
    11;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_NO_ORNAMENTS: hb_aat_layout_feature_selector_t = 0;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_DINGBATS: hb_aat_layout_feature_selector_t = 1;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_PI_CHARACTERS: hb_aat_layout_feature_selector_t = 2;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_FLEURONS: hb_aat_layout_feature_selector_t = 3;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_DECORATIVE_BORDERS: hb_aat_layout_feature_selector_t = 4;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_INTERNATIONAL_SYMBOLS: hb_aat_layout_feature_selector_t =
    5;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_MATH_SYMBOLS: hb_aat_layout_feature_selector_t = 6;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_NO_ALTERNATES: hb_aat_layout_feature_selector_t = 0;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_DESIGN_LEVEL1: hb_aat_layout_feature_selector_t = 0;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_DESIGN_LEVEL2: hb_aat_layout_feature_selector_t = 1;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_DESIGN_LEVEL3: hb_aat_layout_feature_selector_t = 2;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_DESIGN_LEVEL4: hb_aat_layout_feature_selector_t = 3;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_DESIGN_LEVEL5: hb_aat_layout_feature_selector_t = 4;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_NO_STYLE_OPTIONS: hb_aat_layout_feature_selector_t = 0;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_DISPLAY_TEXT: hb_aat_layout_feature_selector_t = 1;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_ENGRAVED_TEXT: hb_aat_layout_feature_selector_t = 2;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_ILLUMINATED_CAPS: hb_aat_layout_feature_selector_t = 3;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_TITLING_CAPS: hb_aat_layout_feature_selector_t = 4;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_TALL_CAPS: hb_aat_layout_feature_selector_t = 5;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_TRADITIONAL_CHARACTERS: hb_aat_layout_feature_selector_t =
    0;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_SIMPLIFIED_CHARACTERS: hb_aat_layout_feature_selector_t =
    1;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_JIS1978_CHARACTERS: hb_aat_layout_feature_selector_t = 2;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_JIS1983_CHARACTERS: hb_aat_layout_feature_selector_t = 3;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_JIS1990_CHARACTERS: hb_aat_layout_feature_selector_t = 4;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_TRADITIONAL_ALT_ONE: hb_aat_layout_feature_selector_t = 5;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_TRADITIONAL_ALT_TWO: hb_aat_layout_feature_selector_t = 6;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_TRADITIONAL_ALT_THREE: hb_aat_layout_feature_selector_t =
    7;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_TRADITIONAL_ALT_FOUR: hb_aat_layout_feature_selector_t = 8;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_TRADITIONAL_ALT_FIVE: hb_aat_layout_feature_selector_t = 9;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_EXPERT_CHARACTERS: hb_aat_layout_feature_selector_t = 10;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_JIS2004_CHARACTERS: hb_aat_layout_feature_selector_t = 11;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_HOJO_CHARACTERS: hb_aat_layout_feature_selector_t = 12;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_NLCCHARACTERS: hb_aat_layout_feature_selector_t = 13;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_TRADITIONAL_NAMES_CHARACTERS:
    hb_aat_layout_feature_selector_t = 14;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_LOWER_CASE_NUMBERS: hb_aat_layout_feature_selector_t = 0;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_UPPER_CASE_NUMBERS: hb_aat_layout_feature_selector_t = 1;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_PROPORTIONAL_TEXT: hb_aat_layout_feature_selector_t = 0;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_MONOSPACED_TEXT: hb_aat_layout_feature_selector_t = 1;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_HALF_WIDTH_TEXT: hb_aat_layout_feature_selector_t = 2;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_THIRD_WIDTH_TEXT: hb_aat_layout_feature_selector_t = 3;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_QUARTER_WIDTH_TEXT: hb_aat_layout_feature_selector_t = 4;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_ALT_PROPORTIONAL_TEXT: hb_aat_layout_feature_selector_t =
    5;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_ALT_HALF_WIDTH_TEXT: hb_aat_layout_feature_selector_t = 6;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_NO_TRANSLITERATION: hb_aat_layout_feature_selector_t = 0;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_HANJA_TO_HANGUL: hb_aat_layout_feature_selector_t = 1;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_HIRAGANA_TO_KATAKANA: hb_aat_layout_feature_selector_t = 2;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_KATAKANA_TO_HIRAGANA: hb_aat_layout_feature_selector_t = 3;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_KANA_TO_ROMANIZATION: hb_aat_layout_feature_selector_t = 4;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_ROMANIZATION_TO_HIRAGANA:
    hb_aat_layout_feature_selector_t = 5;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_ROMANIZATION_TO_KATAKANA:
    hb_aat_layout_feature_selector_t = 6;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_HANJA_TO_HANGUL_ALT_ONE: hb_aat_layout_feature_selector_t =
    7;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_HANJA_TO_HANGUL_ALT_TWO: hb_aat_layout_feature_selector_t =
    8;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_HANJA_TO_HANGUL_ALT_THREE:
    hb_aat_layout_feature_selector_t = 9;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_NO_ANNOTATION: hb_aat_layout_feature_selector_t = 0;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_BOX_ANNOTATION: hb_aat_layout_feature_selector_t = 1;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_ROUNDED_BOX_ANNOTATION: hb_aat_layout_feature_selector_t =
    2;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_CIRCLE_ANNOTATION: hb_aat_layout_feature_selector_t = 3;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_INVERTED_CIRCLE_ANNOTATION:
    hb_aat_layout_feature_selector_t = 4;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_PARENTHESIS_ANNOTATION: hb_aat_layout_feature_selector_t =
    5;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_PERIOD_ANNOTATION: hb_aat_layout_feature_selector_t = 6;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_ROMAN_NUMERAL_ANNOTATION:
    hb_aat_layout_feature_selector_t = 7;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_DIAMOND_ANNOTATION: hb_aat_layout_feature_selector_t = 8;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_INVERTED_BOX_ANNOTATION: hb_aat_layout_feature_selector_t =
    9;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_INVERTED_ROUNDED_BOX_ANNOTATION:
    hb_aat_layout_feature_selector_t = 10;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_FULL_WIDTH_KANA: hb_aat_layout_feature_selector_t = 0;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_PROPORTIONAL_KANA: hb_aat_layout_feature_selector_t = 1;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_FULL_WIDTH_IDEOGRAPHS: hb_aat_layout_feature_selector_t =
    0;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_PROPORTIONAL_IDEOGRAPHS: hb_aat_layout_feature_selector_t =
    1;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_HALF_WIDTH_IDEOGRAPHS: hb_aat_layout_feature_selector_t =
    2;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_CANONICAL_COMPOSITION_ON:
    hb_aat_layout_feature_selector_t = 0;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_CANONICAL_COMPOSITION_OFF:
    hb_aat_layout_feature_selector_t = 1;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_COMPATIBILITY_COMPOSITION_ON:
    hb_aat_layout_feature_selector_t = 2;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_COMPATIBILITY_COMPOSITION_OFF:
    hb_aat_layout_feature_selector_t = 3;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_TRANSCODING_COMPOSITION_ON:
    hb_aat_layout_feature_selector_t = 4;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_TRANSCODING_COMPOSITION_OFF:
    hb_aat_layout_feature_selector_t = 5;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_NO_RUBY_KANA: hb_aat_layout_feature_selector_t = 0;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_RUBY_KANA: hb_aat_layout_feature_selector_t = 1;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_RUBY_KANA_ON: hb_aat_layout_feature_selector_t = 2;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_RUBY_KANA_OFF: hb_aat_layout_feature_selector_t = 3;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_NO_CJK_SYMBOL_ALTERNATIVES:
    hb_aat_layout_feature_selector_t = 0;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_CJK_SYMBOL_ALT_ONE: hb_aat_layout_feature_selector_t = 1;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_CJK_SYMBOL_ALT_TWO: hb_aat_layout_feature_selector_t = 2;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_CJK_SYMBOL_ALT_THREE: hb_aat_layout_feature_selector_t = 3;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_CJK_SYMBOL_ALT_FOUR: hb_aat_layout_feature_selector_t = 4;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_CJK_SYMBOL_ALT_FIVE: hb_aat_layout_feature_selector_t = 5;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_NO_IDEOGRAPHIC_ALTERNATIVES:
    hb_aat_layout_feature_selector_t = 0;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_IDEOGRAPHIC_ALT_ONE: hb_aat_layout_feature_selector_t = 1;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_IDEOGRAPHIC_ALT_TWO: hb_aat_layout_feature_selector_t = 2;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_IDEOGRAPHIC_ALT_THREE: hb_aat_layout_feature_selector_t =
    3;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_IDEOGRAPHIC_ALT_FOUR: hb_aat_layout_feature_selector_t = 4;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_IDEOGRAPHIC_ALT_FIVE: hb_aat_layout_feature_selector_t = 5;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_CJK_VERTICAL_ROMAN_CENTERED:
    hb_aat_layout_feature_selector_t = 0;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_CJK_VERTICAL_ROMAN_HBASELINE:
    hb_aat_layout_feature_selector_t = 1;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_NO_CJK_ITALIC_ROMAN: hb_aat_layout_feature_selector_t = 0;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_CJK_ITALIC_ROMAN: hb_aat_layout_feature_selector_t = 1;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_CJK_ITALIC_ROMAN_ON: hb_aat_layout_feature_selector_t = 2;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_CJK_ITALIC_ROMAN_OFF: hb_aat_layout_feature_selector_t = 3;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_CASE_SENSITIVE_LAYOUT_ON:
    hb_aat_layout_feature_selector_t = 0;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_CASE_SENSITIVE_LAYOUT_OFF:
    hb_aat_layout_feature_selector_t = 1;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_CASE_SENSITIVE_SPACING_ON:
    hb_aat_layout_feature_selector_t = 2;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_CASE_SENSITIVE_SPACING_OFF:
    hb_aat_layout_feature_selector_t = 3;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_ALTERNATE_HORIZ_KANA_ON: hb_aat_layout_feature_selector_t =
    0;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_ALTERNATE_HORIZ_KANA_OFF:
    hb_aat_layout_feature_selector_t = 1;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_ALTERNATE_VERT_KANA_ON: hb_aat_layout_feature_selector_t =
    2;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_ALTERNATE_VERT_KANA_OFF: hb_aat_layout_feature_selector_t =
    3;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_NO_STYLISTIC_ALTERNATES: hb_aat_layout_feature_selector_t =
    0;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_STYLISTIC_ALT_ONE_ON: hb_aat_layout_feature_selector_t = 2;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_STYLISTIC_ALT_ONE_OFF: hb_aat_layout_feature_selector_t =
    3;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_STYLISTIC_ALT_TWO_ON: hb_aat_layout_feature_selector_t = 4;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_STYLISTIC_ALT_TWO_OFF: hb_aat_layout_feature_selector_t =
    5;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_STYLISTIC_ALT_THREE_ON: hb_aat_layout_feature_selector_t =
    6;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_STYLISTIC_ALT_THREE_OFF: hb_aat_layout_feature_selector_t =
    7;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_STYLISTIC_ALT_FOUR_ON: hb_aat_layout_feature_selector_t =
    8;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_STYLISTIC_ALT_FOUR_OFF: hb_aat_layout_feature_selector_t =
    9;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_STYLISTIC_ALT_FIVE_ON: hb_aat_layout_feature_selector_t =
    10;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_STYLISTIC_ALT_FIVE_OFF: hb_aat_layout_feature_selector_t =
    11;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_STYLISTIC_ALT_SIX_ON: hb_aat_layout_feature_selector_t =
    12;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_STYLISTIC_ALT_SIX_OFF: hb_aat_layout_feature_selector_t =
    13;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_STYLISTIC_ALT_SEVEN_ON: hb_aat_layout_feature_selector_t =
    14;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_STYLISTIC_ALT_SEVEN_OFF: hb_aat_layout_feature_selector_t =
    15;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_STYLISTIC_ALT_EIGHT_ON: hb_aat_layout_feature_selector_t =
    16;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_STYLISTIC_ALT_EIGHT_OFF: hb_aat_layout_feature_selector_t =
    17;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_STYLISTIC_ALT_NINE_ON: hb_aat_layout_feature_selector_t =
    18;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_STYLISTIC_ALT_NINE_OFF: hb_aat_layout_feature_selector_t =
    19;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_STYLISTIC_ALT_TEN_ON: hb_aat_layout_feature_selector_t =
    20;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_STYLISTIC_ALT_TEN_OFF: hb_aat_layout_feature_selector_t =
    21;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_STYLISTIC_ALT_ELEVEN_ON: hb_aat_layout_feature_selector_t =
    22;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_STYLISTIC_ALT_ELEVEN_OFF:
    hb_aat_layout_feature_selector_t = 23;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_STYLISTIC_ALT_TWELVE_ON: hb_aat_layout_feature_selector_t =
    24;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_STYLISTIC_ALT_TWELVE_OFF:
    hb_aat_layout_feature_selector_t = 25;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_STYLISTIC_ALT_THIRTEEN_ON:
    hb_aat_layout_feature_selector_t = 26;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_STYLISTIC_ALT_THIRTEEN_OFF:
    hb_aat_layout_feature_selector_t = 27;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_STYLISTIC_ALT_FOURTEEN_ON:
    hb_aat_layout_feature_selector_t = 28;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_STYLISTIC_ALT_FOURTEEN_OFF:
    hb_aat_layout_feature_selector_t = 29;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_STYLISTIC_ALT_FIFTEEN_ON:
    hb_aat_layout_feature_selector_t = 30;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_STYLISTIC_ALT_FIFTEEN_OFF:
    hb_aat_layout_feature_selector_t = 31;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_STYLISTIC_ALT_SIXTEEN_ON:
    hb_aat_layout_feature_selector_t = 32;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_STYLISTIC_ALT_SIXTEEN_OFF:
    hb_aat_layout_feature_selector_t = 33;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_STYLISTIC_ALT_SEVENTEEN_ON:
    hb_aat_layout_feature_selector_t = 34;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_STYLISTIC_ALT_SEVENTEEN_OFF:
    hb_aat_layout_feature_selector_t = 35;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_STYLISTIC_ALT_EIGHTEEN_ON:
    hb_aat_layout_feature_selector_t = 36;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_STYLISTIC_ALT_EIGHTEEN_OFF:
    hb_aat_layout_feature_selector_t = 37;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_STYLISTIC_ALT_NINETEEN_ON:
    hb_aat_layout_feature_selector_t = 38;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_STYLISTIC_ALT_NINETEEN_OFF:
    hb_aat_layout_feature_selector_t = 39;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_STYLISTIC_ALT_TWENTY_ON: hb_aat_layout_feature_selector_t =
    40;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_STYLISTIC_ALT_TWENTY_OFF:
    hb_aat_layout_feature_selector_t = 41;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_CONTEXTUAL_ALTERNATES_ON:
    hb_aat_layout_feature_selector_t = 0;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_CONTEXTUAL_ALTERNATES_OFF:
    hb_aat_layout_feature_selector_t = 1;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_SWASH_ALTERNATES_ON: hb_aat_layout_feature_selector_t = 2;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_SWASH_ALTERNATES_OFF: hb_aat_layout_feature_selector_t = 3;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_CONTEXTUAL_SWASH_ALTERNATES_ON:
    hb_aat_layout_feature_selector_t = 4;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_CONTEXTUAL_SWASH_ALTERNATES_OFF:
    hb_aat_layout_feature_selector_t = 5;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_DEFAULT_LOWER_CASE: hb_aat_layout_feature_selector_t = 0;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_LOWER_CASE_SMALL_CAPS: hb_aat_layout_feature_selector_t =
    1;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_LOWER_CASE_PETITE_CAPS: hb_aat_layout_feature_selector_t =
    2;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_DEFAULT_UPPER_CASE: hb_aat_layout_feature_selector_t = 0;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_UPPER_CASE_SMALL_CAPS: hb_aat_layout_feature_selector_t =
    1;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_UPPER_CASE_PETITE_CAPS: hb_aat_layout_feature_selector_t =
    2;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_HALF_WIDTH_CJK_ROMAN: hb_aat_layout_feature_selector_t = 0;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_PROPORTIONAL_CJK_ROMAN: hb_aat_layout_feature_selector_t =
    1;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_DEFAULT_CJK_ROMAN: hb_aat_layout_feature_selector_t = 2;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_FULL_WIDTH_CJK_ROMAN: hb_aat_layout_feature_selector_t = 3;
pub const _HB_AAT_LAYOUT_FEATURE_SELECTOR_MAX_VALUE: hb_aat_layout_feature_selector_t = 2147483647;
#[doc = " hb_aat_layout_feature_selector_t:"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_SELECTOR_INVALID: Initial, unset feature selector"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_SELECTOR_ALL_TYPE_FEATURES_ON: for #HB_AAT_LAYOUT_FEATURE_TYPE_ALL_TYPOGRAPHIC"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_SELECTOR_ALL_TYPE_FEATURES_OFF: for #HB_AAT_LAYOUT_FEATURE_TYPE_ALL_TYPOGRAPHIC"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_SELECTOR_REQUIRED_LIGATURES_ON: for #HB_AAT_LAYOUT_FEATURE_TYPE_LIGATURES"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_SELECTOR_REQUIRED_LIGATURES_OFF: for #HB_AAT_LAYOUT_FEATURE_TYPE_LIGATURES"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_SELECTOR_COMMON_LIGATURES_ON: for #HB_AAT_LAYOUT_FEATURE_TYPE_LIGATURES"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_SELECTOR_COMMON_LIGATURES_OFF: for #HB_AAT_LAYOUT_FEATURE_TYPE_LIGATURES"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_SELECTOR_RARE_LIGATURES_ON: for #HB_AAT_LAYOUT_FEATURE_TYPE_LIGATURES"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_SELECTOR_RARE_LIGATURES_OFF: for #HB_AAT_LAYOUT_FEATURE_TYPE_LIGATURES"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_SELECTOR_LOGOS_ON: for #HB_AAT_LAYOUT_FEATURE_TYPE_LIGATURES"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_SELECTOR_LOGOS_OFF: for #HB_AAT_LAYOUT_FEATURE_TYPE_LIGATURES"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_SELECTOR_REBUS_PICTURES_ON: for #HB_AAT_LAYOUT_FEATURE_TYPE_LIGATURES"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_SELECTOR_REBUS_PICTURES_OFF: for #HB_AAT_LAYOUT_FEATURE_TYPE_LIGATURES"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_SELECTOR_DIPHTHONG_LIGATURES_ON: for #HB_AAT_LAYOUT_FEATURE_TYPE_LIGATURES"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_SELECTOR_DIPHTHONG_LIGATURES_OFF: for #HB_AAT_LAYOUT_FEATURE_TYPE_LIGATURES"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_SELECTOR_SQUARED_LIGATURES_ON: for #HB_AAT_LAYOUT_FEATURE_TYPE_LIGATURES"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_SELECTOR_SQUARED_LIGATURES_OFF: for #HB_AAT_LAYOUT_FEATURE_TYPE_LIGATURES"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_SELECTOR_ABBREV_SQUARED_LIGATURES_ON: for #HB_AAT_LAYOUT_FEATURE_TYPE_LIGATURES"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_SELECTOR_ABBREV_SQUARED_LIGATURES_OFF: for #HB_AAT_LAYOUT_FEATURE_TYPE_LIGATURES"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_SELECTOR_SYMBOL_LIGATURES_ON: for #HB_AAT_LAYOUT_FEATURE_TYPE_LIGATURES"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_SELECTOR_SYMBOL_LIGATURES_OFF: for #HB_AAT_LAYOUT_FEATURE_TYPE_LIGATURES"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_SELECTOR_CONTEXTUAL_LIGATURES_ON: for #HB_AAT_LAYOUT_FEATURE_TYPE_LIGATURES"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_SELECTOR_CONTEXTUAL_LIGATURES_OFF: for #HB_AAT_LAYOUT_FEATURE_TYPE_LIGATURES"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_SELECTOR_HISTORICAL_LIGATURES_ON: for #HB_AAT_LAYOUT_FEATURE_TYPE_LIGATURES"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_SELECTOR_HISTORICAL_LIGATURES_OFF: for #HB_AAT_LAYOUT_FEATURE_TYPE_LIGATURES"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_SELECTOR_UNCONNECTED: for #HB_AAT_LAYOUT_FEATURE_TYPE_LIGATURES"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_SELECTOR_PARTIALLY_CONNECTED: for #HB_AAT_LAYOUT_FEATURE_TYPE_LIGATURES"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_SELECTOR_CURSIVE: for #HB_AAT_LAYOUT_FEATURE_TYPE_LIGATURES"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_SELECTOR_UPPER_AND_LOWER_CASE: Deprecated"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_SELECTOR_ALL_CAPS: Deprecated"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_SELECTOR_ALL_LOWER_CASE: Deprecated"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_SELECTOR_SMALL_CAPS: Deprecated"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_SELECTOR_INITIAL_CAPS: Deprecated"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_SELECTOR_INITIAL_CAPS_AND_SMALL_CAPS: Deprecated"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_SELECTOR_SUBSTITUTE_VERTICAL_FORMS_ON: for #HB_AAT_LAYOUT_FEATURE_TYPE_VERTICAL_SUBSTITUTION"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_SELECTOR_SUBSTITUTE_VERTICAL_FORMS_OFF: for #HB_AAT_LAYOUT_FEATURE_TYPE_VERTICAL_SUBSTITUTION"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_SELECTOR_LINGUISTIC_REARRANGEMENT_ON: for #HB_AAT_LAYOUT_FEATURE_TYPE_LINGUISTIC_REARRANGEMENT"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_SELECTOR_LINGUISTIC_REARRANGEMENT_OFF: for #HB_AAT_LAYOUT_FEATURE_TYPE_LINGUISTIC_REARRANGEMENT"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_SELECTOR_MONOSPACED_NUMBERS: for #HB_AAT_LAYOUT_FEATURE_TYPE_NUMBER_SPACING"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_SELECTOR_PROPORTIONAL_NUMBERS: for #HB_AAT_LAYOUT_FEATURE_TYPE_NUMBER_SPACING"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_SELECTOR_THIRD_WIDTH_NUMBERS: for #HB_AAT_LAYOUT_FEATURE_TYPE_NUMBER_SPACING"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_SELECTOR_QUARTER_WIDTH_NUMBERS: for #HB_AAT_LAYOUT_FEATURE_TYPE_NUMBER_SPACING"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_SELECTOR_WORD_INITIAL_SWASHES_ON: for #HB_AAT_LAYOUT_FEATURE_TYPE_SMART_SWASH_TYPE"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_SELECTOR_WORD_INITIAL_SWASHES_OFF: for #HB_AAT_LAYOUT_FEATURE_TYPE_SMART_SWASH_TYPE"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_SELECTOR_WORD_FINAL_SWASHES_ON: for #HB_AAT_LAYOUT_FEATURE_TYPE_SMART_SWASH_TYPE"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_SELECTOR_WORD_FINAL_SWASHES_OFF: for #HB_AAT_LAYOUT_FEATURE_TYPE_SMART_SWASH_TYPE"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_SELECTOR_LINE_INITIAL_SWASHES_ON: for #HB_AAT_LAYOUT_FEATURE_TYPE_SMART_SWASH_TYPE"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_SELECTOR_LINE_INITIAL_SWASHES_OFF: for #HB_AAT_LAYOUT_FEATURE_TYPE_SMART_SWASH_TYPE"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_SELECTOR_LINE_FINAL_SWASHES_ON: for #HB_AAT_LAYOUT_FEATURE_TYPE_SMART_SWASH_TYPE"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_SELECTOR_LINE_FINAL_SWASHES_OFF: for #HB_AAT_LAYOUT_FEATURE_TYPE_SMART_SWASH_TYPE"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_SELECTOR_NON_FINAL_SWASHES_ON: for #HB_AAT_LAYOUT_FEATURE_TYPE_SMART_SWASH_TYPE"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_SELECTOR_NON_FINAL_SWASHES_OFF: for #HB_AAT_LAYOUT_FEATURE_TYPE_SMART_SWASH_TYPE"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_SELECTOR_SHOW_DIACRITICS: for #HB_AAT_LAYOUT_FEATURE_TYPE_DIACRITICS_TYPE"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_SELECTOR_HIDE_DIACRITICS: for #HB_AAT_LAYOUT_FEATURE_TYPE_DIACRITICS_TYPE"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_SELECTOR_DECOMPOSE_DIACRITICS: for #HB_AAT_LAYOUT_FEATURE_TYPE_DIACRITICS_TYPE"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_SELECTOR_NORMAL_POSITION: for #HB_AAT_LAYOUT_FEATURE_TYPE_VERTICAL_POSITION"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_SELECTOR_SUPERIORS: for #HB_AAT_LAYOUT_FEATURE_TYPE_VERTICAL_POSITION"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_SELECTOR_INFERIORS: for #HB_AAT_LAYOUT_FEATURE_TYPE_VERTICAL_POSITION"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_SELECTOR_ORDINALS: for #HB_AAT_LAYOUT_FEATURE_TYPE_VERTICAL_POSITION"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_SELECTOR_SCIENTIFIC_INFERIORS: for #HB_AAT_LAYOUT_FEATURE_TYPE_VERTICAL_POSITION"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_SELECTOR_NO_FRACTIONS: for #HB_AAT_LAYOUT_FEATURE_TYPE_FRACTIONS"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_SELECTOR_VERTICAL_FRACTIONS: for #HB_AAT_LAYOUT_FEATURE_TYPE_FRACTIONS"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_SELECTOR_DIAGONAL_FRACTIONS: for #HB_AAT_LAYOUT_FEATURE_TYPE_FRACTIONS"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_SELECTOR_PREVENT_OVERLAP_ON: for #HB_AAT_LAYOUT_FEATURE_TYPE_OVERLAPPING_CHARACTERS_TYPE"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_SELECTOR_PREVENT_OVERLAP_OFF: for #HB_AAT_LAYOUT_FEATURE_TYPE_OVERLAPPING_CHARACTERS_TYPE"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_SELECTOR_HYPHENS_TO_EM_DASH_ON: for #HB_AAT_LAYOUT_FEATURE_TYPE_TYPOGRAPHIC_EXTRAS"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_SELECTOR_HYPHENS_TO_EM_DASH_OFF: for #HB_AAT_LAYOUT_FEATURE_TYPE_TYPOGRAPHIC_EXTRAS"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_SELECTOR_HYPHEN_TO_EN_DASH_ON: for #HB_AAT_LAYOUT_FEATURE_TYPE_TYPOGRAPHIC_EXTRAS"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_SELECTOR_HYPHEN_TO_EN_DASH_OFF: for #HB_AAT_LAYOUT_FEATURE_TYPE_TYPOGRAPHIC_EXTRAS"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_SELECTOR_SLASHED_ZERO_ON: for #HB_AAT_LAYOUT_FEATURE_TYPE_TYPOGRAPHIC_EXTRAS"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_SELECTOR_SLASHED_ZERO_OFF: for #HB_AAT_LAYOUT_FEATURE_TYPE_TYPOGRAPHIC_EXTRAS"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_SELECTOR_FORM_INTERROBANG_ON: for #HB_AAT_LAYOUT_FEATURE_TYPE_TYPOGRAPHIC_EXTRAS"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_SELECTOR_FORM_INTERROBANG_OFF: for #HB_AAT_LAYOUT_FEATURE_TYPE_TYPOGRAPHIC_EXTRAS"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_SELECTOR_SMART_QUOTES_ON: for #HB_AAT_LAYOUT_FEATURE_TYPE_TYPOGRAPHIC_EXTRAS"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_SELECTOR_SMART_QUOTES_OFF: for #HB_AAT_LAYOUT_FEATURE_TYPE_TYPOGRAPHIC_EXTRAS"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_SELECTOR_PERIODS_TO_ELLIPSIS_ON: for #HB_AAT_LAYOUT_FEATURE_TYPE_TYPOGRAPHIC_EXTRAS"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_SELECTOR_PERIODS_TO_ELLIPSIS_OFF: for #HB_AAT_LAYOUT_FEATURE_TYPE_TYPOGRAPHIC_EXTRAS"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_SELECTOR_HYPHEN_TO_MINUS_ON: for #HB_AAT_LAYOUT_FEATURE_TYPE_MATHEMATICAL_EXTRAS"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_SELECTOR_HYPHEN_TO_MINUS_OFF: for #HB_AAT_LAYOUT_FEATURE_TYPE_MATHEMATICAL_EXTRAS"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_SELECTOR_ASTERISK_TO_MULTIPLY_ON: for #HB_AAT_LAYOUT_FEATURE_TYPE_MATHEMATICAL_EXTRAS"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_SELECTOR_ASTERISK_TO_MULTIPLY_OFF: for #HB_AAT_LAYOUT_FEATURE_TYPE_MATHEMATICAL_EXTRAS"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_SELECTOR_SLASH_TO_DIVIDE_ON: for #HB_AAT_LAYOUT_FEATURE_TYPE_MATHEMATICAL_EXTRAS"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_SELECTOR_SLASH_TO_DIVIDE_OFF: for #HB_AAT_LAYOUT_FEATURE_TYPE_MATHEMATICAL_EXTRAS"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_SELECTOR_INEQUALITY_LIGATURES_ON: for #HB_AAT_LAYOUT_FEATURE_TYPE_MATHEMATICAL_EXTRAS"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_SELECTOR_INEQUALITY_LIGATURES_OFF: for #HB_AAT_LAYOUT_FEATURE_TYPE_MATHEMATICAL_EXTRAS"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_SELECTOR_EXPONENTS_ON: for #HB_AAT_LAYOUT_FEATURE_TYPE_MATHEMATICAL_EXTRAS"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_SELECTOR_EXPONENTS_OFF: for #HB_AAT_LAYOUT_FEATURE_TYPE_MATHEMATICAL_EXTRAS"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_SELECTOR_MATHEMATICAL_GREEK_ON: for #HB_AAT_LAYOUT_FEATURE_TYPE_MATHEMATICAL_EXTRAS"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_SELECTOR_MATHEMATICAL_GREEK_OFF: for #HB_AAT_LAYOUT_FEATURE_TYPE_MATHEMATICAL_EXTRAS"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_SELECTOR_NO_ORNAMENTS: for #HB_AAT_LAYOUT_FEATURE_TYPE_ORNAMENT_SETS_TYPE"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_SELECTOR_DINGBATS: for #HB_AAT_LAYOUT_FEATURE_TYPE_ORNAMENT_SETS_TYPE"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_SELECTOR_PI_CHARACTERS: for #HB_AAT_LAYOUT_FEATURE_TYPE_ORNAMENT_SETS_TYPE"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_SELECTOR_FLEURONS: for #HB_AAT_LAYOUT_FEATURE_TYPE_ORNAMENT_SETS_TYPE"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_SELECTOR_DECORATIVE_BORDERS: for #HB_AAT_LAYOUT_FEATURE_TYPE_ORNAMENT_SETS_TYPE"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_SELECTOR_INTERNATIONAL_SYMBOLS: for #HB_AAT_LAYOUT_FEATURE_TYPE_ORNAMENT_SETS_TYPE"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_SELECTOR_MATH_SYMBOLS: for #HB_AAT_LAYOUT_FEATURE_TYPE_ORNAMENT_SETS_TYPE"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_SELECTOR_NO_ALTERNATES: for #HB_AAT_LAYOUT_FEATURE_TYPE_CHARACTER_ALTERNATIVES"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_SELECTOR_DESIGN_LEVEL1: for #HB_AAT_LAYOUT_FEATURE_TYPE_DESIGN_COMPLEXITY_TYPE"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_SELECTOR_DESIGN_LEVEL2: for #HB_AAT_LAYOUT_FEATURE_TYPE_DESIGN_COMPLEXITY_TYPE"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_SELECTOR_DESIGN_LEVEL3: for #HB_AAT_LAYOUT_FEATURE_TYPE_DESIGN_COMPLEXITY_TYPE"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_SELECTOR_DESIGN_LEVEL4: for #HB_AAT_LAYOUT_FEATURE_TYPE_DESIGN_COMPLEXITY_TYPE"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_SELECTOR_DESIGN_LEVEL5: for #HB_AAT_LAYOUT_FEATURE_TYPE_DESIGN_COMPLEXITY_TYPE"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_SELECTOR_NO_STYLE_OPTIONS: for #HB_AAT_LAYOUT_FEATURE_TYPE_STYLE_OPTIONS"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_SELECTOR_DISPLAY_TEXT: for #HB_AAT_LAYOUT_FEATURE_TYPE_STYLE_OPTIONS"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_SELECTOR_ENGRAVED_TEXT: for #HB_AAT_LAYOUT_FEATURE_TYPE_STYLE_OPTIONS"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_SELECTOR_ILLUMINATED_CAPS: for #HB_AAT_LAYOUT_FEATURE_TYPE_STYLE_OPTIONS"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_SELECTOR_TITLING_CAPS: for #HB_AAT_LAYOUT_FEATURE_TYPE_STYLE_OPTIONS"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_SELECTOR_TALL_CAPS: for #HB_AAT_LAYOUT_FEATURE_TYPE_STYLE_OPTIONS"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_SELECTOR_TRADITIONAL_CHARACTERS: for #HB_AAT_LAYOUT_FEATURE_TYPE_CHARACTER_SHAPE"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_SELECTOR_SIMPLIFIED_CHARACTERS: for #HB_AAT_LAYOUT_FEATURE_TYPE_CHARACTER_SHAPE"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_SELECTOR_JIS1978_CHARACTERS: for #HB_AAT_LAYOUT_FEATURE_TYPE_CHARACTER_SHAPE"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_SELECTOR_JIS1983_CHARACTERS: for #HB_AAT_LAYOUT_FEATURE_TYPE_CHARACTER_SHAPE"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_SELECTOR_JIS1990_CHARACTERS: for #HB_AAT_LAYOUT_FEATURE_TYPE_CHARACTER_SHAPE"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_SELECTOR_TRADITIONAL_ALT_ONE: for #HB_AAT_LAYOUT_FEATURE_TYPE_CHARACTER_SHAPE"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_SELECTOR_TRADITIONAL_ALT_TWO: for #HB_AAT_LAYOUT_FEATURE_TYPE_CHARACTER_SHAPE"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_SELECTOR_TRADITIONAL_ALT_THREE: for #HB_AAT_LAYOUT_FEATURE_TYPE_CHARACTER_SHAPE"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_SELECTOR_TRADITIONAL_ALT_FOUR: for #HB_AAT_LAYOUT_FEATURE_TYPE_CHARACTER_SHAPE"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_SELECTOR_TRADITIONAL_ALT_FIVE: for #HB_AAT_LAYOUT_FEATURE_TYPE_CHARACTER_SHAPE"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_SELECTOR_EXPERT_CHARACTERS: for #HB_AAT_LAYOUT_FEATURE_TYPE_CHARACTER_SHAPE"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_SELECTOR_JIS2004_CHARACTERS: for #HB_AAT_LAYOUT_FEATURE_TYPE_CHARACTER_SHAPE"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_SELECTOR_HOJO_CHARACTERS: for #HB_AAT_LAYOUT_FEATURE_TYPE_CHARACTER_SHAPE"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_SELECTOR_NLCCHARACTERS: for #HB_AAT_LAYOUT_FEATURE_TYPE_CHARACTER_SHAPE"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_SELECTOR_TRADITIONAL_NAMES_CHARACTERS: for #HB_AAT_LAYOUT_FEATURE_TYPE_CHARACTER_SHAPE"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_SELECTOR_LOWER_CASE_NUMBERS: for #HB_AAT_LAYOUT_FEATURE_TYPE_NUMBER_CASE"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_SELECTOR_UPPER_CASE_NUMBERS: for #HB_AAT_LAYOUT_FEATURE_TYPE_NUMBER_CASE"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_SELECTOR_PROPORTIONAL_TEXT: for #HB_AAT_LAYOUT_FEATURE_TYPE_TEXT_SPACING"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_SELECTOR_MONOSPACED_TEXT: for #HB_AAT_LAYOUT_FEATURE_TYPE_TEXT_SPACING"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_SELECTOR_HALF_WIDTH_TEXT: for #HB_AAT_LAYOUT_FEATURE_TYPE_TEXT_SPACING"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_SELECTOR_THIRD_WIDTH_TEXT: for #HB_AAT_LAYOUT_FEATURE_TYPE_TEXT_SPACING"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_SELECTOR_QUARTER_WIDTH_TEXT: for #HB_AAT_LAYOUT_FEATURE_TYPE_TEXT_SPACING"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_SELECTOR_ALT_PROPORTIONAL_TEXT: for #HB_AAT_LAYOUT_FEATURE_TYPE_TEXT_SPACING"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_SELECTOR_ALT_HALF_WIDTH_TEXT: for #HB_AAT_LAYOUT_FEATURE_TYPE_TEXT_SPACING"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_SELECTOR_NO_TRANSLITERATION: for #HB_AAT_LAYOUT_FEATURE_TYPE_TRANSLITERATION"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_SELECTOR_HANJA_TO_HANGUL: for #HB_AAT_LAYOUT_FEATURE_TYPE_TRANSLITERATION"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_SELECTOR_HIRAGANA_TO_KATAKANA: for #HB_AAT_LAYOUT_FEATURE_TYPE_TRANSLITERATION"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_SELECTOR_KATAKANA_TO_HIRAGANA: for #HB_AAT_LAYOUT_FEATURE_TYPE_TRANSLITERATION"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_SELECTOR_KANA_TO_ROMANIZATION: for #HB_AAT_LAYOUT_FEATURE_TYPE_TRANSLITERATION"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_SELECTOR_ROMANIZATION_TO_HIRAGANA: for #HB_AAT_LAYOUT_FEATURE_TYPE_TRANSLITERATION"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_SELECTOR_ROMANIZATION_TO_KATAKANA: for #HB_AAT_LAYOUT_FEATURE_TYPE_TRANSLITERATION"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_SELECTOR_HANJA_TO_HANGUL_ALT_ONE: for #HB_AAT_LAYOUT_FEATURE_TYPE_TRANSLITERATION"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_SELECTOR_HANJA_TO_HANGUL_ALT_TWO: for #HB_AAT_LAYOUT_FEATURE_TYPE_TRANSLITERATION"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_SELECTOR_HANJA_TO_HANGUL_ALT_THREE: for #HB_AAT_LAYOUT_FEATURE_TYPE_TRANSLITERATION"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_SELECTOR_NO_ANNOTATION: for #HB_AAT_LAYOUT_FEATURE_TYPE_ANNOTATION_TYPE"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_SELECTOR_BOX_ANNOTATION: for #HB_AAT_LAYOUT_FEATURE_TYPE_ANNOTATION_TYPE"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_SELECTOR_ROUNDED_BOX_ANNOTATION: for #HB_AAT_LAYOUT_FEATURE_TYPE_ANNOTATION_TYPE"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_SELECTOR_CIRCLE_ANNOTATION: for #HB_AAT_LAYOUT_FEATURE_TYPE_ANNOTATION_TYPE"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_SELECTOR_INVERTED_CIRCLE_ANNOTATION: for #HB_AAT_LAYOUT_FEATURE_TYPE_ANNOTATION_TYPE"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_SELECTOR_PARENTHESIS_ANNOTATION: for #HB_AAT_LAYOUT_FEATURE_TYPE_ANNOTATION_TYPE"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_SELECTOR_PERIOD_ANNOTATION: for #HB_AAT_LAYOUT_FEATURE_TYPE_ANNOTATION_TYPE"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_SELECTOR_ROMAN_NUMERAL_ANNOTATION: for #HB_AAT_LAYOUT_FEATURE_TYPE_ANNOTATION_TYPE"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_SELECTOR_DIAMOND_ANNOTATION: for #HB_AAT_LAYOUT_FEATURE_TYPE_ANNOTATION_TYPE"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_SELECTOR_INVERTED_BOX_ANNOTATION: for #HB_AAT_LAYOUT_FEATURE_TYPE_ANNOTATION_TYPE"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_SELECTOR_INVERTED_ROUNDED_BOX_ANNOTATION: for #HB_AAT_LAYOUT_FEATURE_TYPE_ANNOTATION_TYPE"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_SELECTOR_FULL_WIDTH_KANA: for #HB_AAT_LAYOUT_FEATURE_TYPE_KANA_SPACING_TYPE"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_SELECTOR_PROPORTIONAL_KANA: for #HB_AAT_LAYOUT_FEATURE_TYPE_KANA_SPACING_TYPE"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_SELECTOR_FULL_WIDTH_IDEOGRAPHS: for #HB_AAT_LAYOUT_FEATURE_TYPE_IDEOGRAPHIC_SPACING_TYPE"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_SELECTOR_PROPORTIONAL_IDEOGRAPHS: for #HB_AAT_LAYOUT_FEATURE_TYPE_IDEOGRAPHIC_SPACING_TYPE"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_SELECTOR_HALF_WIDTH_IDEOGRAPHS: for #HB_AAT_LAYOUT_FEATURE_TYPE_IDEOGRAPHIC_SPACING_TYPE"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_SELECTOR_CANONICAL_COMPOSITION_ON: for #HB_AAT_LAYOUT_FEATURE_TYPE_UNICODE_DECOMPOSITION_TYPE"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_SELECTOR_CANONICAL_COMPOSITION_OFF: for #HB_AAT_LAYOUT_FEATURE_TYPE_UNICODE_DECOMPOSITION_TYPE"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_SELECTOR_COMPATIBILITY_COMPOSITION_ON: for #HB_AAT_LAYOUT_FEATURE_TYPE_UNICODE_DECOMPOSITION_TYPE"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_SELECTOR_COMPATIBILITY_COMPOSITION_OFF: for #HB_AAT_LAYOUT_FEATURE_TYPE_UNICODE_DECOMPOSITION_TYPE"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_SELECTOR_TRANSCODING_COMPOSITION_ON: for #HB_AAT_LAYOUT_FEATURE_TYPE_UNICODE_DECOMPOSITION_TYPE"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_SELECTOR_TRANSCODING_COMPOSITION_OFF: for #HB_AAT_LAYOUT_FEATURE_TYPE_UNICODE_DECOMPOSITION_TYPE"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_SELECTOR_NO_RUBY_KANA: Deprecated; use #HB_AAT_LAYOUT_FEATURE_SELECTOR_RUBY_KANA_OFF instead"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_SELECTOR_RUBY_KANA: Deprecated; use #HB_AAT_LAYOUT_FEATURE_SELECTOR_RUBY_KANA_ON instead"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_SELECTOR_RUBY_KANA_ON: for #HB_AAT_LAYOUT_FEATURE_TYPE_RUBY_KANA"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_SELECTOR_RUBY_KANA_OFF: for #HB_AAT_LAYOUT_FEATURE_TYPE_RUBY_KANA"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_SELECTOR_NO_CJK_SYMBOL_ALTERNATIVES: for #HB_AAT_LAYOUT_FEATURE_TYPE_CJK_SYMBOL_ALTERNATIVES_TYPE"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_SELECTOR_CJK_SYMBOL_ALT_ONE: for #HB_AAT_LAYOUT_FEATURE_TYPE_CJK_SYMBOL_ALTERNATIVES_TYPE"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_SELECTOR_CJK_SYMBOL_ALT_TWO: for #HB_AAT_LAYOUT_FEATURE_TYPE_CJK_SYMBOL_ALTERNATIVES_TYPE"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_SELECTOR_CJK_SYMBOL_ALT_THREE: for #HB_AAT_LAYOUT_FEATURE_TYPE_CJK_SYMBOL_ALTERNATIVES_TYPE"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_SELECTOR_CJK_SYMBOL_ALT_FOUR: for #HB_AAT_LAYOUT_FEATURE_TYPE_CJK_SYMBOL_ALTERNATIVES_TYPE"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_SELECTOR_CJK_SYMBOL_ALT_FIVE: for #HB_AAT_LAYOUT_FEATURE_TYPE_CJK_SYMBOL_ALTERNATIVES_TYPE"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_SELECTOR_NO_IDEOGRAPHIC_ALTERNATIVES: for #HB_AAT_LAYOUT_FEATURE_TYPE_IDEOGRAPHIC_ALTERNATIVES_TYPE"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_SELECTOR_IDEOGRAPHIC_ALT_ONE: for #HB_AAT_LAYOUT_FEATURE_TYPE_IDEOGRAPHIC_ALTERNATIVES_TYPE"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_SELECTOR_IDEOGRAPHIC_ALT_TWO: for #HB_AAT_LAYOUT_FEATURE_TYPE_IDEOGRAPHIC_ALTERNATIVES_TYPE"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_SELECTOR_IDEOGRAPHIC_ALT_THREE: for #HB_AAT_LAYOUT_FEATURE_TYPE_IDEOGRAPHIC_ALTERNATIVES_TYPE"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_SELECTOR_IDEOGRAPHIC_ALT_FOUR: for #HB_AAT_LAYOUT_FEATURE_TYPE_IDEOGRAPHIC_ALTERNATIVES_TYPE"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_SELECTOR_IDEOGRAPHIC_ALT_FIVE: for #HB_AAT_LAYOUT_FEATURE_TYPE_IDEOGRAPHIC_ALTERNATIVES_TYPE"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_SELECTOR_CJK_VERTICAL_ROMAN_CENTERED: for #HB_AAT_LAYOUT_FEATURE_TYPE_CJK_VERTICAL_ROMAN_PLACEMENT_TYPE"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_SELECTOR_CJK_VERTICAL_ROMAN_HBASELINE: for #HB_AAT_LAYOUT_FEATURE_TYPE_CJK_VERTICAL_ROMAN_PLACEMENT_TYPE"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_SELECTOR_NO_CJK_ITALIC_ROMAN: Deprecated; use #HB_AAT_LAYOUT_FEATURE_SELECTOR_CJK_ITALIC_ROMAN_OFF instead"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_SELECTOR_CJK_ITALIC_ROMAN: Deprecated; use #HB_AAT_LAYOUT_FEATURE_SELECTOR_CJK_ITALIC_ROMAN_ON instead"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_SELECTOR_CJK_ITALIC_ROMAN_ON: for #HB_AAT_LAYOUT_FEATURE_TYPE_ITALIC_CJK_ROMAN"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_SELECTOR_CJK_ITALIC_ROMAN_OFF: for #HB_AAT_LAYOUT_FEATURE_TYPE_ITALIC_CJK_ROMAN"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_SELECTOR_CASE_SENSITIVE_LAYOUT_ON: for #HB_AAT_LAYOUT_FEATURE_TYPE_CASE_SENSITIVE_LAYOUT"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_SELECTOR_CASE_SENSITIVE_LAYOUT_OFF: for #HB_AAT_LAYOUT_FEATURE_TYPE_CASE_SENSITIVE_LAYOUT"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_SELECTOR_CASE_SENSITIVE_SPACING_ON: for #HB_AAT_LAYOUT_FEATURE_TYPE_CASE_SENSITIVE_LAYOUT"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_SELECTOR_CASE_SENSITIVE_SPACING_OFF: for #HB_AAT_LAYOUT_FEATURE_TYPE_CASE_SENSITIVE_LAYOUT"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_SELECTOR_ALTERNATE_HORIZ_KANA_ON: for #HB_AAT_LAYOUT_FEATURE_TYPE_ALTERNATE_KANA"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_SELECTOR_ALTERNATE_HORIZ_KANA_OFF: for #HB_AAT_LAYOUT_FEATURE_TYPE_ALTERNATE_KANA"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_SELECTOR_ALTERNATE_VERT_KANA_ON: for #HB_AAT_LAYOUT_FEATURE_TYPE_ALTERNATE_KANA"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_SELECTOR_ALTERNATE_VERT_KANA_OFF: for #HB_AAT_LAYOUT_FEATURE_TYPE_ALTERNATE_KANA"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_SELECTOR_NO_STYLISTIC_ALTERNATES: for #HB_AAT_LAYOUT_FEATURE_TYPE_STYLISTIC_ALTERNATIVES"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_SELECTOR_STYLISTIC_ALT_ONE_ON: for #HB_AAT_LAYOUT_FEATURE_TYPE_STYLISTIC_ALTERNATIVES"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_SELECTOR_STYLISTIC_ALT_ONE_OFF: for #HB_AAT_LAYOUT_FEATURE_TYPE_STYLISTIC_ALTERNATIVES"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_SELECTOR_STYLISTIC_ALT_TWO_ON: for #HB_AAT_LAYOUT_FEATURE_TYPE_STYLISTIC_ALTERNATIVES"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_SELECTOR_STYLISTIC_ALT_TWO_OFF: for #HB_AAT_LAYOUT_FEATURE_TYPE_STYLISTIC_ALTERNATIVES"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_SELECTOR_STYLISTIC_ALT_THREE_ON: for #HB_AAT_LAYOUT_FEATURE_TYPE_STYLISTIC_ALTERNATIVES"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_SELECTOR_STYLISTIC_ALT_THREE_OFF: for #HB_AAT_LAYOUT_FEATURE_TYPE_STYLISTIC_ALTERNATIVES"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_SELECTOR_STYLISTIC_ALT_FOUR_ON: for #HB_AAT_LAYOUT_FEATURE_TYPE_STYLISTIC_ALTERNATIVES"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_SELECTOR_STYLISTIC_ALT_FOUR_OFF: for #HB_AAT_LAYOUT_FEATURE_TYPE_STYLISTIC_ALTERNATIVES"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_SELECTOR_STYLISTIC_ALT_FIVE_ON: for #HB_AAT_LAYOUT_FEATURE_TYPE_STYLISTIC_ALTERNATIVES"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_SELECTOR_STYLISTIC_ALT_FIVE_OFF: for #HB_AAT_LAYOUT_FEATURE_TYPE_STYLISTIC_ALTERNATIVES"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_SELECTOR_STYLISTIC_ALT_SIX_ON: for #HB_AAT_LAYOUT_FEATURE_TYPE_STYLISTIC_ALTERNATIVES"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_SELECTOR_STYLISTIC_ALT_SIX_OFF: for #HB_AAT_LAYOUT_FEATURE_TYPE_STYLISTIC_ALTERNATIVES"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_SELECTOR_STYLISTIC_ALT_SEVEN_ON: for #HB_AAT_LAYOUT_FEATURE_TYPE_STYLISTIC_ALTERNATIVES"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_SELECTOR_STYLISTIC_ALT_SEVEN_OFF: for #HB_AAT_LAYOUT_FEATURE_TYPE_STYLISTIC_ALTERNATIVES"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_SELECTOR_STYLISTIC_ALT_EIGHT_ON: for #HB_AAT_LAYOUT_FEATURE_TYPE_STYLISTIC_ALTERNATIVES"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_SELECTOR_STYLISTIC_ALT_EIGHT_OFF: for #HB_AAT_LAYOUT_FEATURE_TYPE_STYLISTIC_ALTERNATIVES"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_SELECTOR_STYLISTIC_ALT_NINE_ON: for #HB_AAT_LAYOUT_FEATURE_TYPE_STYLISTIC_ALTERNATIVES"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_SELECTOR_STYLISTIC_ALT_NINE_OFF: for #HB_AAT_LAYOUT_FEATURE_TYPE_STYLISTIC_ALTERNATIVES"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_SELECTOR_STYLISTIC_ALT_TEN_ON: for #HB_AAT_LAYOUT_FEATURE_TYPE_STYLISTIC_ALTERNATIVES"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_SELECTOR_STYLISTIC_ALT_TEN_OFF: for #HB_AAT_LAYOUT_FEATURE_TYPE_STYLISTIC_ALTERNATIVES"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_SELECTOR_STYLISTIC_ALT_ELEVEN_ON: for #HB_AAT_LAYOUT_FEATURE_TYPE_STYLISTIC_ALTERNATIVES"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_SELECTOR_STYLISTIC_ALT_ELEVEN_OFF: for #HB_AAT_LAYOUT_FEATURE_TYPE_STYLISTIC_ALTERNATIVES"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_SELECTOR_STYLISTIC_ALT_TWELVE_ON: for #HB_AAT_LAYOUT_FEATURE_TYPE_STYLISTIC_ALTERNATIVES"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_SELECTOR_STYLISTIC_ALT_TWELVE_OFF: for #HB_AAT_LAYOUT_FEATURE_TYPE_STYLISTIC_ALTERNATIVES"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_SELECTOR_STYLISTIC_ALT_THIRTEEN_ON: for #HB_AAT_LAYOUT_FEATURE_TYPE_STYLISTIC_ALTERNATIVES"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_SELECTOR_STYLISTIC_ALT_THIRTEEN_OFF: for #HB_AAT_LAYOUT_FEATURE_TYPE_STYLISTIC_ALTERNATIVES"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_SELECTOR_STYLISTIC_ALT_FOURTEEN_ON: for #HB_AAT_LAYOUT_FEATURE_TYPE_STYLISTIC_ALTERNATIVES"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_SELECTOR_STYLISTIC_ALT_FOURTEEN_OFF: for #HB_AAT_LAYOUT_FEATURE_TYPE_STYLISTIC_ALTERNATIVES"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_SELECTOR_STYLISTIC_ALT_FIFTEEN_ON: for #HB_AAT_LAYOUT_FEATURE_TYPE_STYLISTIC_ALTERNATIVES"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_SELECTOR_STYLISTIC_ALT_FIFTEEN_OFF: for #HB_AAT_LAYOUT_FEATURE_TYPE_STYLISTIC_ALTERNATIVES"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_SELECTOR_STYLISTIC_ALT_SIXTEEN_ON: for #HB_AAT_LAYOUT_FEATURE_TYPE_STYLISTIC_ALTERNATIVES"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_SELECTOR_STYLISTIC_ALT_SIXTEEN_OFF: for #HB_AAT_LAYOUT_FEATURE_TYPE_STYLISTIC_ALTERNATIVES"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_SELECTOR_STYLISTIC_ALT_SEVENTEEN_ON: for #HB_AAT_LAYOUT_FEATURE_TYPE_STYLISTIC_ALTERNATIVES"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_SELECTOR_STYLISTIC_ALT_SEVENTEEN_OFF: for #HB_AAT_LAYOUT_FEATURE_TYPE_STYLISTIC_ALTERNATIVES"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_SELECTOR_STYLISTIC_ALT_EIGHTEEN_ON: for #HB_AAT_LAYOUT_FEATURE_TYPE_STYLISTIC_ALTERNATIVES"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_SELECTOR_STYLISTIC_ALT_EIGHTEEN_OFF: for #HB_AAT_LAYOUT_FEATURE_TYPE_STYLISTIC_ALTERNATIVES"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_SELECTOR_STYLISTIC_ALT_NINETEEN_ON: for #HB_AAT_LAYOUT_FEATURE_TYPE_STYLISTIC_ALTERNATIVES"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_SELECTOR_STYLISTIC_ALT_NINETEEN_OFF: for #HB_AAT_LAYOUT_FEATURE_TYPE_STYLISTIC_ALTERNATIVES"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_SELECTOR_STYLISTIC_ALT_TWENTY_ON: for #HB_AAT_LAYOUT_FEATURE_TYPE_STYLISTIC_ALTERNATIVES"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_SELECTOR_STYLISTIC_ALT_TWENTY_OFF: for #HB_AAT_LAYOUT_FEATURE_TYPE_STYLISTIC_ALTERNATIVES"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_SELECTOR_CONTEXTUAL_ALTERNATES_ON: for #HB_AAT_LAYOUT_FEATURE_TYPE_CONTEXTUAL_ALTERNATIVES"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_SELECTOR_CONTEXTUAL_ALTERNATES_OFF: for #HB_AAT_LAYOUT_FEATURE_TYPE_CONTEXTUAL_ALTERNATIVES"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_SELECTOR_SWASH_ALTERNATES_ON: for #HB_AAT_LAYOUT_FEATURE_TYPE_CONTEXTUAL_ALTERNATIVES"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_SELECTOR_SWASH_ALTERNATES_OFF: for #HB_AAT_LAYOUT_FEATURE_TYPE_CONTEXTUAL_ALTERNATIVES"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_SELECTOR_CONTEXTUAL_SWASH_ALTERNATES_ON: for #HB_AAT_LAYOUT_FEATURE_TYPE_CONTEXTUAL_ALTERNATIVES"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_SELECTOR_CONTEXTUAL_SWASH_ALTERNATES_OFF: for #HB_AAT_LAYOUT_FEATURE_TYPE_CONTEXTUAL_ALTERNATIVES"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_SELECTOR_DEFAULT_LOWER_CASE: for #HB_AAT_LAYOUT_FEATURE_TYPE_LOWER_CASE"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_SELECTOR_LOWER_CASE_SMALL_CAPS: for #HB_AAT_LAYOUT_FEATURE_TYPE_LOWER_CASE"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_SELECTOR_LOWER_CASE_PETITE_CAPS: for #HB_AAT_LAYOUT_FEATURE_TYPE_LOWER_CASE"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_SELECTOR_DEFAULT_UPPER_CASE: for #HB_AAT_LAYOUT_FEATURE_TYPE_UPPER_CASE"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_SELECTOR_UPPER_CASE_SMALL_CAPS: for #HB_AAT_LAYOUT_FEATURE_TYPE_UPPER_CASE"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_SELECTOR_UPPER_CASE_PETITE_CAPS: for #HB_AAT_LAYOUT_FEATURE_TYPE_UPPER_CASE"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_SELECTOR_HALF_WIDTH_CJK_ROMAN: for #HB_AAT_LAYOUT_FEATURE_TYPE_CJK_ROMAN_SPACING_TYPE"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_SELECTOR_PROPORTIONAL_CJK_ROMAN: for #HB_AAT_LAYOUT_FEATURE_TYPE_CJK_ROMAN_SPACING_TYPE"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_SELECTOR_DEFAULT_CJK_ROMAN: for #HB_AAT_LAYOUT_FEATURE_TYPE_CJK_ROMAN_SPACING_TYPE"]
#[doc = " @HB_AAT_LAYOUT_FEATURE_SELECTOR_FULL_WIDTH_CJK_ROMAN: for #HB_AAT_LAYOUT_FEATURE_TYPE_CJK_ROMAN_SPACING_TYPE"]
#[doc = ""]
#[doc = " The selectors defined for specifying AAT feature settings."]
#[doc = ""]
#[doc = " Since: 2.2.0"]
pub type hb_aat_layout_feature_selector_t = ::std::os::raw::c_uint;
extern "C" {
    pub fn hb_aat_layout_get_feature_types(
        face: *mut hb_face_t,
        start_offset: ::std::os::raw::c_uint,
        feature_count: *mut ::std::os::raw::c_uint,
        features: *mut hb_aat_layout_feature_type_t,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn hb_aat_layout_feature_type_get_name_id(
        face: *mut hb_face_t,
        feature_type: hb_aat_layout_feature_type_t,
    ) -> hb_ot_name_id_t;
}
#[doc = " hb_aat_layout_feature_selector_info_t:"]
#[doc = " @name_id: The selector's name identifier"]
#[doc = " @enable: The value to turn the selector on"]
#[doc = " @disable: The value to turn the selector off"]
#[doc = ""]
#[doc = " Structure representing a setting for an #hb_aat_layout_feature_type_t."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hb_aat_layout_feature_selector_info_t {
    pub name_id: hb_ot_name_id_t,
    pub enable: hb_aat_layout_feature_selector_t,
    pub disable: hb_aat_layout_feature_selector_t,
    pub reserved: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_hb_aat_layout_feature_selector_info_t() {
    assert_eq!(
        ::std::mem::size_of::<hb_aat_layout_feature_selector_info_t>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(hb_aat_layout_feature_selector_info_t)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<hb_aat_layout_feature_selector_info_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(hb_aat_layout_feature_selector_info_t)
        )
    );
    fn test_field_name_id() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<hb_aat_layout_feature_selector_info_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).name_id) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(hb_aat_layout_feature_selector_info_t),
                "::",
                stringify!(name_id)
            )
        );
    }
    test_field_name_id();
    fn test_field_enable() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<hb_aat_layout_feature_selector_info_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).enable) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(hb_aat_layout_feature_selector_info_t),
                "::",
                stringify!(enable)
            )
        );
    }
    test_field_enable();
    fn test_field_disable() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<hb_aat_layout_feature_selector_info_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).disable) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(hb_aat_layout_feature_selector_info_t),
                "::",
                stringify!(disable)
            )
        );
    }
    test_field_disable();
    fn test_field_reserved() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<hb_aat_layout_feature_selector_info_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(hb_aat_layout_feature_selector_info_t),
                "::",
                stringify!(reserved)
            )
        );
    }
    test_field_reserved();
}
extern "C" {
    pub fn hb_aat_layout_feature_type_get_selector_infos(
        face: *mut hb_face_t,
        feature_type: hb_aat_layout_feature_type_t,
        start_offset: ::std::os::raw::c_uint,
        selector_count: *mut ::std::os::raw::c_uint,
        selectors: *mut hb_aat_layout_feature_selector_info_t,
        default_index: *mut ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn hb_aat_layout_has_substitution(face: *mut hb_face_t) -> hb_bool_t;
}
extern "C" {
    pub fn hb_aat_layout_has_positioning(face: *mut hb_face_t) -> hb_bool_t;
}
extern "C" {
    pub fn hb_aat_layout_has_tracking(face: *mut hb_face_t) -> hb_bool_t;
}
